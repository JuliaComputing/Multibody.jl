<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Components · Multibody.jl</title><meta name="title" content="Components · Multibody.jl"/><meta property="og:title" content="Components · Multibody.jl"/><meta property="twitter:title" content="Components · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/pendulum/">Getting started: Pendulum</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="../examples/spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="../examples/three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="../examples/sensors/">Sensors</a></li><li><a class="tocitem" href="../examples/spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="../examples/gearbox/">Gearbox</a></li><li><a class="tocitem" href="../examples/free_motion/">Free motions</a></li><li><a class="tocitem" href="../examples/prescribed_pose/">Prescribed motions</a></li><li><a class="tocitem" href="../examples/kinematic_loops/">Kinematic loops</a></li><li><a class="tocitem" href="../examples/robot/">Industrial robot</a></li><li><a class="tocitem" href="../examples/ropes_and_cables/">Ropes, cables and chains</a></li><li><a class="tocitem" href="../examples/swing/">Swing</a></li><li><a class="tocitem" href="../examples/space/">Bodies in space</a></li><li><a class="tocitem" href="../examples/gyroscopic_effects/">Gyroscopic effects</a></li><li><a class="tocitem" href="../examples/wheel/">Wheels</a></li><li><a class="tocitem" href="../examples/suspension/">Suspension systems</a></li><li><a class="tocitem" href="../examples/quad/">Quadrotor with cable-suspended load</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../frames/">Frames</a></li><li><a class="tocitem" href="../joints/">Joints</a></li><li class="is-active"><a class="tocitem" href>Components</a></li><li><a class="tocitem" href="../forces/">Forces</a></li><li><a class="tocitem" href="../sensors/">Sensors</a></li><li><a class="tocitem" href="../trajectory_planning/">Trajectory planning</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../rotations/">Rotations and orientation</a></li><li><a class="tocitem" href="../rendering/">3D rendering</a></li><li><a class="tocitem" href="../urdf/">URDF import</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Components</a></li><li class="is-active"><a href>Components</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Components</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h1><p>The perhaps most fundamental component is a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, this component has a single flange, <code>frame_a</code>, which is used to connect the body to other components. This component has a mass, a vector <code>r_cm</code> from <code>frame_a</code> to the center of mass, and a moment of inertia tensor <code>I</code> in the center of mass. The body can be thought of as a point mass with a moment of inertia tensor.</p><p>A mass with a shape can be modeled using a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>. The primary difference between a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a> and a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is that the latter has an additional flange, <code>frame_b</code>, which is used to connect the body to other components. The translation between <code>flange_a</code> and <code>flange_b</code> is determined by the vector <code>r</code>. The <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is suitable to model, e.g., cylinders, rods, and boxes.</p><p>A rod without a mass (just a translation), is modeled using <a href="#Multibody.FixedTranslation-Tuple{}"><code>FixedTranslation</code></a>.</p><ul><li><a href="#Multibody.BodyBox"><code>Multibody.BodyBox</code></a></li><li><a href="#Multibody.BodyCylinder"><code>Multibody.BodyCylinder</code></a></li><li><a href="#Multibody.PlanarMechanics.BodyShape"><code>Multibody.PlanarMechanics.BodyShape</code></a></li><li><a href="#Multibody.PlanarMechanics.Damper"><code>Multibody.PlanarMechanics.Damper</code></a></li><li><a href="#Multibody.PlanarMechanics.DifferentialGear"><code>Multibody.PlanarMechanics.DifferentialGear</code></a></li><li><a href="#Multibody.PlanarMechanics.Fixed"><code>Multibody.PlanarMechanics.Fixed</code></a></li><li><a href="#Multibody.PlanarMechanics.FixedTranslation"><code>Multibody.PlanarMechanics.FixedTranslation</code></a></li><li><a href="#Multibody.PlanarMechanics.IdealPlanetary"><code>Multibody.PlanarMechanics.IdealPlanetary</code></a></li><li><a href="#Multibody.PlanarMechanics.SimpleWheel"><code>Multibody.PlanarMechanics.SimpleWheel</code></a></li><li><a href="#Multibody.PlanarMechanics.Spring"><code>Multibody.PlanarMechanics.Spring</code></a></li><li><a href="#Multibody.PlanarMechanics.SpringDamper"><code>Multibody.PlanarMechanics.SpringDamper</code></a></li><li><a href="#Multibody.world"><code>Multibody.world</code></a></li><li><a href="#Multibody.AccSensor-Tuple{}"><code>Multibody.AccSensor</code></a></li><li><a href="#Multibody.AxisControlBus-Tuple{}"><code>Multibody.AxisControlBus</code></a></li><li><a href="#Multibody.AxisType2-Tuple{}"><code>Multibody.AxisType2</code></a></li><li><a href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a></li><li><a href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a></li><li><a href="#Multibody.Fixed-Tuple{}"><code>Multibody.Fixed</code></a></li><li><a href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a></li><li><a href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a></li><li><a href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Multibody.PlanarMechanics.Body</code></a></li><li><a href="#Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}"><code>Multibody.PlanarMechanics.SlipBasedWheelJoint</code></a></li><li><a href="#Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_form</code></a></li><li><a href="#Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_triple</code></a></li><li><a href="#Multibody.Pose-Tuple{}"><code>Multibody.Pose</code></a></li><li><a href="#Multibody.Position-Tuple{}"><code>Multibody.Position</code></a></li><li><a href="#Multibody.RollingConstraintVerticalWheel-Tuple{}"><code>Multibody.RollingConstraintVerticalWheel</code></a></li><li><a href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a></li><li><a href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a></li><li><a href="#Multibody.RollingWheelSet-Tuple{}"><code>Multibody.RollingWheelSet</code></a></li><li><a href="#Multibody.RollingWheelSetJoint-Tuple{}"><code>Multibody.RollingWheelSetJoint</code></a></li><li><a href="#Multibody.Rope-Tuple{}"><code>Multibody.Rope</code></a></li><li><a href="#Multibody.SlipWheelJoint-Tuple{}"><code>Multibody.SlipWheelJoint</code></a></li><li><a href="#Multibody.SlippingWheel-Tuple{}"><code>Multibody.SlippingWheel</code></a></li><li><a href="#Multibody.World-Tuple{}"><code>Multibody.World</code></a></li><li><a href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a></li><li><a href="#Multibody.ori"><code>Multibody.ori</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyBox" href="#Multibody.BodyBox"><code>Multibody.BodyBox</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyBox(; name, m = 1, r = [1, 0, 0], r_shape = [0, 0, 0], width_dir = [0,1,0])</code></pre><p>Rigid body with box shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the box data. Optionally, the box may be hollow. The (outer) box shape is used in the animation, the hollow part is not shown in the animation. The two connector frames <code>frame_a</code> and <code>frame_b</code> are always parallel to each other.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (structural parameter) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_shape</code>: (structural parameter) Vector from <code>frame_a</code> to box origin, resolved in <code>frame_a</code></li><li><code>width_dir</code>: (structural parameter) Vector in width direction of box, resolved in <code>frame_a</code></li><li><code>length_dir</code>: (structural parameter) Vector in length direction of box, resolved in <code>frame_a</code></li><li><code>length</code>: (structural parameter) Length of box</li><li><code>width = 0.3length</code>: Width of box</li><li><code>height = width</code>: Height of box</li><li><code>inner_width</code>: Width of inner box surface (0 &lt;= inner_width &lt;= width)</li><li><code>inner_height</code>: Height of inner box surface (0 &lt;= inner_height &lt;= height)</li><li><code>density = 7700</code>: Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)</li><li><code>color</code>: Color of box in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L823-L840">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyCylinder" href="#Multibody.BodyCylinder"><code>Multibody.BodyCylinder</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyCylinder(; name, m = 1, r = [0.1, 0, 0], r_shape = [0, 0, 0], dir = r - r_shape, length = _norm(r - r_shape), diameter = 1, inner_diameter = 0, density = 7700, color = purple)</code></pre><p>Rigid body with cylinder shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the cylinder data. Optionally, the cylinder may be hollow. The two connector frames <code>frame_a</code> and <code>frame_b</code> are always parallel to each other.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (Structural parameter) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_shape</code>: (Structural parameter) Vector from <code>frame_a</code> to cylinder origin, resolved in <code>frame_a</code></li><li><code>dir</code>: Vector in length direction of cylinder, resolved in <code>frame_a</code></li><li><code>length</code>: Length of cylinder</li><li><code>diameter</code>: Diameter of cylinder</li><li><code>inner_diameter</code>: Inner diameter of cylinder (0 &lt;= inner_diameter &lt;= diameter)</li><li><code>density</code>: Density of cylinder <a href="e.g., steel: 7700 .. 7900, wood : 400 .. 800">kg/m³</a></li><li><code>color</code>: Color of cylinder in animations</li></ul><p><strong>Variables</strong></p><ul><li><code>r_0</code>: Position vector from origin of world frame to origin of <code>frame_a</code></li><li><code>v_0</code>: Absolute velocity of <code>frame_a</code>, resolved in world frame (= D(r_0))</li><li><code>a_0</code>: Absolute acceleration of <code>frame_a</code> resolved in world frame (= D(v_0))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L712-L731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.world" href="#Multibody.world"><code>Multibody.world</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The world component is the root of all multibody models. It is a fixed frame with a parallel gravitational field and a gravity vector specified by the unit direction <code>world.n</code> (defaults to [0, -1, 0]) and magnitude <code>world.g</code> (defaults to 9.80665).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L64-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AccSensor-Tuple{}" href="#Multibody.AccSensor-Tuple{}"><code>Multibody.AccSensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AccSensor(;name)</code></pre><p>Ideal rotational sensor to measure the absolute flange angular acceleration</p><p><strong>Connectors:</strong></p><ul><li><code>flange</code>: <a href="@ref">Flange</a> Flange of shaft from which sensor information shall be measured</li><li><code>a</code>: <a href="@ref">RealOutput</a> Absolute angular acceleration of flange</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/robot/robot_components.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AxisControlBus-Tuple{}" href="#Multibody.AxisControlBus-Tuple{}"><code>Multibody.AxisControlBus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@connector AxisControlBus(; name)</code></pre><ul><li><code>motion_ref(t) = 0</code>: = true, if reference motion is not in rest</li><li><code>angle_ref(t) = 0</code>: Reference angle of axis flange</li><li><code>angle(t) = 0</code>: Angle of axis flange</li><li><code>speed_ref(t) = 0</code>: Reference speed of axis flange</li><li><code>speed(t) = 0</code>: Speed of axis flange</li><li><code>acceleration_ref(t) = 0</code>: Reference acceleration of axis flange</li><li><code>acceleration(t) = 0</code>: Acceleration of axis flange</li><li><code>current_ref(t) = 0</code>: Reference current of motor</li><li><code>current(t) = 0</code>: Current of motor</li><li><code>motorAngle(t) = 0</code>: Angle of motor flange</li><li><code>motorSpeed(t) = 0</code>: Speed of motor flange</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/robot/robot_components.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AxisType2-Tuple{}" href="#Multibody.AxisType2-Tuple{}"><code>Multibody.AxisType2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AxisType2(; name)</code></pre><p>Axis model of the r3 joints 4,5,6</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/robot/robot_components.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Body-Tuple{}" href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Body(; name, m = 1, r_cm, isroot = false, phi0 = zeros(3), phid0 = zeros(3), r_0 = zeros(3), state_priority = 2, quat = false, sparse_I = false)</code></pre><p>Representing a body with 3 translational and 3 rotational degrees-of-freedom.</p><p>This component has a single frame, <code>frame_a</code>. To represent bodies with more than one frame, see <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>, <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a>, <a href="#Multibody.BodyBox"><code>BodyBox</code></a>. The inertia tensor is defined with respect to a coordinate system that is parallel to <code>frame_a</code> with the origin at the center of mass of the body.</p><p><strong>Performance optimization</strong></p><ul><li><code>sparse_I</code>: If <code>true</code>, the zero elements of the inerita matrix are considered &quot;structurally zero&quot;, and this fact is used to optimize performance. When this option is enabled, the elements of the inertia matrix that were zero when the component was created cannot changed without reinstantiating the component. This performance optimization may be useful, e.g., when the inertia matrix is known to be diagonal.</li></ul><p><strong>Parameters</strong></p><ul><li><code>m</code>: Mass</li><li><code>r_cm</code>: Vector from <code>frame_a</code> to center of mass, resolved in <code>frame_a</code></li><li><code>I_11, I_22, I_33, I_21, I_31, I_32</code>: Inertia-matrix elements</li><li><code>isroot</code>: Indicate whether this component is the root of the system, useful when there are no joints in the model.</li><li><code>phi0</code>: Initial orientation, only applicable if <code>isroot = true</code> and <code>quat = false</code></li><li><code>phid0</code>: Initial angular velocity</li></ul><p><strong>Variables</strong></p><ul><li><code>r_0</code>: Position vector from origin of world frame to origin of <code>frame_a</code></li><li><code>v_0</code>: Absolute velocity of <code>frame_a</code>, resolved in world frame (= D(r_0))</li><li><code>a_0</code>: Absolute acceleration of <code>frame_a</code> resolved in world frame (= D(v_0))</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius</code>: Radius of the joint in animations</li><li><code>cylinder_radius</code>: Radius of the cylinder from frame to COM in animations (only drawn if <code>r_cm</code> is non-zero). Defaults to <code>radius/2</code></li><li><code>color</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L300-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyShape-Tuple{}" href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyShape(; name, m = 1, r, kwargs...)</code></pre><p>The <code>BodyShape</code> component is similar to a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, but it has two frames and a vector <code>r</code> that describes the translation between them, while the body has a single frame only.</p><ul><li><code>r</code>: Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li>All <code>kwargs</code> are passed to the internal <code>Body</code> component.</li><li><code>shapefile</code>: A path::String to a CAD model that can be imported by MeshIO for 3D rendering. If none is provided, a cylinder shape is rendered.</li></ul><p>See also <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a> and <a href="#Multibody.BodyBox"><code>BodyBox</code></a> for body components with predefined shapes and automatically computed inertial properties based on geometry and density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L473-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Fixed-Tuple{}" href="#Multibody.Fixed-Tuple{}"><code>Multibody.Fixed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fixed(; name, r = [0, 0, 0], render = true)</code></pre><p>A component rigidly attached to the world frame with translation <code>r</code> between the world and the <code>frame_b</code>. The position vector <code>r</code> is resolved in the world frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedRotation-Tuple{}" href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedRotation(; name, r, n, sequence, isroot = false, angle)</code></pre><p>Fixed translation followed by a fixed rotation of <code>frame_b</code> with respect to <code>frame_a</code></p><ul><li><code>r</code>: Translation vector</li><li><code>n</code>: Axis of rotation, resolved in frame_a</li><li><code>angle</code>: Angle of rotation around <code>n</code>, given in radians</li></ul><p>To obtain an axis-angle representation of any rotation, see <a href="../rotations/#Conversion-between-orientation-formats">Conversion between orientation formats</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L237-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedTranslation-Tuple{}" href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedTranslation(; name, r)</code></pre><p>Fixed translation of <code>frame_b</code> with respect to <code>frame_a</code> with position vector <code>r</code> resolved in <code>frame_a</code>.</p><p>Can be thought of as a massless rod. For a massive rod, see <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> or <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L205-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Pose-Tuple{}" href="#Multibody.Pose-Tuple{}"><code>Multibody.Pose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Pose(; name, r = [0, 0, 0], R, q, render = true)</code></pre><p>Forced movement of a flange according to a reference position <code>r</code> and reference orientation <code>R</code>. The reference arrays <code>r</code> and <code>R</code> are resolved in the world frame, and may be any symbolic expression. As an alternative to specifying <code>R</code>, it is possible to specify a quaternion <code>q</code> (4-vector quaternion with real part first).</p><p>Example usage:</p><pre><code class="nohighlight hljs">using Multibody.Rotations
R = RotXYZ(0, 0.5sin(t), 0)
@named rot = Multibody.Pose(; r=[sin(t), 0, 0], R)</code></pre><p><strong>Arguments</strong></p><ul><li><code>r</code>: Position vector from world frame to frame_b, resolved in world frame</li><li><code>R</code>: Reference orientation matrix</li><li><code>q</code>: Reference quaternion (optional alternative to <code>R</code>)</li><li><code>render</code>: Render the component in animations</li><li><code>normalize</code>: If a quaternion is provided, normalize the quaternion (default = true)</li></ul><p>See also <a href="#Multibody.Position-Tuple{}"><code>Position</code></a> for a component that allows for only forced translation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L134-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Position-Tuple{}" href="#Multibody.Position-Tuple{}"><code>Multibody.Position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Position(; name, r = [0, 0, 0], render = true, fixed_oreintation = true)</code></pre><p>Forced movement of a flange according to a reference position <code>r</code>. Similar to <a href="#Multibody.Fixed-Tuple{}"><code>Fixed</code></a>, but <code>r</code> is not a parameter, and may thus be any time-varying symbolic expression. The reference position vector <code>r</code> is resolved in the world frame. Example: <code>r = [sin(t), 0, 0]</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>r</code>: Position vector from world frame to frame_b, resolved in world frame</li><li><code>render</code>: Render the component in animations</li><li><code>fixed_oreintation</code>: If <code>true</code>, the orientation of the frame is fixed to the world frame. If <code>false</code>, the orientation is free to change.</li></ul><p>See also <a href="#Multibody.Pose-Tuple{}"><code>Pose</code></a> for a component that allows for forced orientation as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Rope-Tuple{}" href="#Multibody.Rope-Tuple{}"><code>Multibody.Rope</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rope(; name, l = 1, n = 10, m = 1, c = 0, d = 0, kwargs)</code></pre><p>Model a rope (string / cable) of length <code>l</code> and mass <code>m</code>.</p><p>The rope is modeled as a series of <code>n</code> links, each connected by a <a href="../joints/#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> joint. The links are either fixed in length (default, modeled using <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>) or flexible, in which case they are modeled as a <a href="@ref"><code>Translational.Spring</code></a> and <a href="@ref"><code>Translational.Damper</code></a> in parallel with a <a href="../joints/#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint with a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a> adding mass to the center of the link segment. The flexibility is controlled by the parameters <code>c</code> and <code>d</code>, which are the stiffness and damping coefficients of the spring and damper, respectively. The default values are <code>c = 0</code> and <code>d = 0</code>, which corresponds to a stiff rope.</p><ul><li><code>l</code>: Unstretched length of rope</li><li><code>n</code>: Number of links used to model the rope. For accurate approximations to continuously flexible ropes, a large number may be required.</li><li><code>m</code>: The total mass of the rope. Each rope segment will have mass <code>m / n</code>.</li><li><code>c</code>: The equivalent stiffness of the rope, i.e., the rope will act like a spring with stiffness <code>c</code>. </li><li><code>d</code>: The equivalent damping in the stretching direction of the rope, i.e., the taught rope will act like a damper with damping <code>d</code>.</li><li><code>d_joint</code>: Viscous damping in the joints between the links. A positive value makes the rope dissipate energy while flexing (as opposed to the damping <code>d</code> which dissipats energy due to stretching).</li><li><code>dir</code>: A vector of norm 1 indicating the initial direction of the rope.</li></ul><p><strong>Damping</strong></p><p>There are three different methods of adding damping to the rope:</p><ul><li>Damping in the stretching direction of the rope, controlled by the parameter <code>d</code>.</li><li>Damping in flexing of the rope, modeled as viscous friction in the joints between the links, controlled by the parameter <code>d_joint</code>.</li><li>Air resistance to the rope moving through the air, controlled by the parameter <code>air_resistance</code>. This damping is quadratic in the velocity (<span>$f_d ~ -||v||v$</span>) of each link relative to the world frame.</li></ul><p><strong>Rendering</strong></p><ul><li><code>color = [255, 219, 120, 255]./255</code></li><li><code>radius = 0.05f0</code></li><li><code>jointradius=0</code></li><li><code>jointcolor=color</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L540-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.World-Tuple{}" href="#Multibody.World-Tuple{}"><code>Multibody.World</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">World(; name, render=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.gravity_acceleration-Tuple{Any}" href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute the gravity acceleration, resolved in world frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.ori" href="#Multibody.ori"><code>Multibody.ori</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ori(frame, varw = false)</code></pre><p>Get the orientation of <code>sys</code> as a <code>RotationMatrix</code> object. See also <a href="../rotations/#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>. <code>ori(frame).R</code> is the rotation matrix that rotates a vector from the world coordinate system to the local frame.</p><p>For frames, the orientation is stored in the metadata field of the system as <code>sys.metadata[:orientation]</code>.</p><p>If <code>varw = true</code>, the angular velocity variables <code>w</code> of the frame is also included in the <code>RotationMatrix</code> object, otherwise <code>w</code> is derived as the time derivative of <code>R</code>. <code>varw = true</code> is primarily used when selecting a component as root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/components.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingConstraintVerticalWheel-Tuple{}" href="#Multibody.RollingConstraintVerticalWheel-Tuple{}"><code>Multibody.RollingConstraintVerticalWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingConstraintVerticalWheel(;
    name,
    radius = 0.3,
    lateral_sliding_constraint = true,
)</code></pre><p>Rolling constraint for wheel that is always perpendicular to x-z plane</p><p>Joint for a wheel rolling on the x-z plane of the world frame intended for an idealized wheelset. To meet this objective, the wheel always runs upright and enables no slip in the longitudinal direction of the wheel/ground contact. On the contrary, the wheel can optionally slip in the lateral direction which is reasonable for the wheelset where just one of the wheels should be laterally constrained. The frame <code>frame_a</code> is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. A wheel body collecting the mass and inertia</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>name</code>: Name of the rolling wheel joint component</li><li><code>radius</code>: Wheel radius</li><li><code>lateral_sliding_constraint</code>: true, if lateral sliding constraint taken into account, = false if lateral force = 0 (needed to avoid overconstraining if two ideal rolling wheels are connect on one axis)</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: Frame for the wheel joint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L543-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheel-Tuple{}" href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheel(; name, radius, m, I_axis, I_long, width=0.035, x0, y0, kwargs...)</code></pre><p>Ideal rolling wheel on flat surface y=0 (5 positional, 3 velocity degrees of freedom)</p><p>A wheel rolling on the x-z plane of the world frame including wheel mass. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. The wheel can not take off but it can incline toward the ground. The frame <code>frame_a</code> is placed in the wheel center point and rotates with the wheel itself. A <a href="../joints/#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint rotationg around <code>n = [0, 1, 0]</code> is required to attach the wheel to a wheel axis.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>name</code>: Name of the rolling wheel component</li><li><code>radius</code>: Radius of the wheel</li><li><code>m</code>: Mass of the wheel</li><li><code>I_axis</code>: Moment of inertia of the wheel along its axis</li><li><code>I_long</code>: Moment of inertia of the wheel perpendicular to its axis</li><li><code>width</code>: Width of the wheel (default: 0.035)</li><li><code>x0</code>: Initial x-position of the wheel axis</li><li><code>z0</code>: Initial z-position of the wheel axis</li><li><code>kwargs...</code>: Additional keyword arguments passed to the <code>RollingWheelJoint</code> function</li></ul><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles  (y: like rotational velocity of a spinning coin, z: wheel forward spin speed, x: wheel falling over speed)</li></ul><p><strong>Named components:</strong></p><ul><li><code>frame_a</code>: Frame for the wheel component</li><li><code>wheeljoint</code>: Rolling wheel joint representing the wheel&#39;s contact with the road surface</li></ul><div class="admonition is-success"><header class="admonition-header">Rendering tip</header><div class="admonition-body"><p>Due to the symmetry of the wheel, it can be hard to discern how the wheel is rotating in animations. Try enabling rendering of the frame of the wheel by setting </p><pre><code class="nohighlight hljs">wheel.frame_a.render =&gt; true;
wheel.frame_a.length =&gt; 1.1radius;
wheel.frame_a.radius =&gt; 0.02radius;</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L182-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelJoint-Tuple{}" href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelJoint(; name, radius, angles, x0, y0, z0)</code></pre><p>Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane y=0). See <a href="#Multibody.RollingWheel-Tuple{}"><code>RollingWheel</code></a> for a realistic wheel model with inertia.</p><p>A joint for a wheel rolling on the x-z plane of the world frame. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. This is simply gained by two non-holonomic constraint equations on velocity level defined for both longitudinal and lateral direction of the wheel. There is also a holonomic constraint equation on position level granting a permanent contact of the wheel to the ground, i.e. the wheel can not take off.</p><p>The origin of the frame <code>frame_a</code> is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. The z-axis of <code>frame_a</code> is identical with the wheel spin axis, i.e. the wheel rotates about z-axis of <code>frame_a</code>. A wheel body collecting the mass and inertia should be connected to this frame.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>angles</code>: Angles to rotate world-frame into frame_a around y-, z-, x-axis</li><li><code>surface</code>: By default, the wheel is rolling on a flat xz plane. A function <code>surface = (x, z)-&gt;y</code> may be provided to define a road surface. The function should return the height of the road at <code>(x, z)</code>.</li></ul><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>y</code>: y-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li><li><code>r_road_0</code>: Position vector from world frame to contact point on road, resolved in world frame</li><li><code>f_wheel_0</code>: Force vector on wheel, resolved in world frame</li><li><code>f_n</code>: Contact force acting on wheel in normal direction</li><li><code>f_lat</code>: Contact force acting on wheel in lateral direction</li><li><code>f_long</code>: Contact force acting on wheel in longitudinal direction</li><li><code>err</code>: Absolute value of <code>(r_road_0 - frame_a.r_0) - radius</code> (must be zero; used for checking)</li><li><code>e_axis_0</code>: Unit vector along wheel axis, resolved in world frame</li><li><code>delta_0</code>: Distance vector from wheel center to contact point</li><li><code>e_n_0</code>: Unit vector in normal direction of road at contact point, resolved in world frame</li><li><code>e_lat_0</code>: Unit vector in lateral direction of road at contact point, resolved in world frame</li><li><code>e_long_0</code>: Unit vector in longitudinal direction of road at contact point, resolved in world frame</li><li><code>s</code>: Road surface parameter 1</li><li><code>w</code>: Road surface parameter 2</li><li><code>e_s_0</code>: Road heading at <code>(s,w)</code>, resolved in world frame (unit vector)</li><li><code>v_0</code>: Velocity of wheel center, resolved in world frame</li><li><code>w_0</code>: Angular velocity of wheel, resolved in world frame</li><li><code>vContact_0</code>: Velocity of contact point, resolved in world frame</li></ul><p><strong>Connector frames</strong></p><ul><li><code>frame_a</code>: Frame for the wheel joint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelSet-Tuple{}" href="#Multibody.RollingWheelSet-Tuple{}"><code>Multibody.RollingWheelSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelSet(;
    name,
    radius = 0.3,
    m_wheel = 1.0,
    I_axis = 1.0,
    I_long = 1.0,
    track = 1.0,
    state_priority = 1,
    x0 = 0,
    z0 = 0,
    phi0 = 0,
    theta1_0 = 0,
    theta2_0 = 0,
    der_theta1_0 = 0,
    der_theta2_0 = 0,
    width_wheel = 0.01,
    color = [0.3, 0.3, 0.3, 1],
    render = true,
    iscut = false,
)</code></pre><p>Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis</p><p>Two wheels are connected by an axis and can rotate around this axis. The wheels are rolling on the x-z plane of the world frame. The coordinate system attached to the center of the wheel axis (<code>frame_middle</code>) is constrained so that it is always parallel to the x-z plane. If all generalized coordinates are zero, <code>frame_middle</code> is parallel to the world frame.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>iscut</code>: if more than one wheel set is connected to the same rigid body, <code>iscut</code> must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.</li><li><code>radius</code>: Radius of one wheel</li><li><code>m_wheel</code>: Mass of one wheel</li><li><code>I_axis</code>: Moment of inertia of one wheel around its rotation axis</li><li><code>I_long</code>: Moment of inertia of one wheel perpendicular to its rotation axis</li><li><code>track</code>: Distance between the two wheels (= axle track)</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_middle</code>: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)</li><li><code>frame1</code>: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>frame2</code>: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>axis1</code>: 1-dim. Rotational flange that drives the left wheel</li><li><code>axis2</code>: 1-dim. Rotational flange that drives the right wheel</li><li><code>support</code>: Support of 1D axes</li></ul><p>To connect driving torques or friction to rotation of the wheels, connect between <code>axis1</code> and <code>support</code>, and <code>axis2</code> and <code>support</code> respectively. To connect the wheel set to, e.g., a body, connect the <code>frame_middle</code> to the body frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L778-L821">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelSetJoint-Tuple{}" href="#Multibody.RollingWheelSetJoint-Tuple{}"><code>Multibody.RollingWheelSetJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelSetJoint(;
    name,
    radius = 0.3,
    track = 1.0,
    state_priority = 1,
    x0 = 0,
    z0 = 0,
    phi0 = 0,
    theta1_0 = 0,
    theta2_0 = 0,
    der_theta1_0 = 0,
    der_theta2_0 = 0,
    render = true,
    iscut = false,
)</code></pre><p>Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)</p><p>An assembly joint for a wheelset rolling on the x-z plane of the world frame. The frames <code>frame1</code> and <code>frame2</code> are connected to rotating wheels; the <code>frame_middle</code> moves in a plane parallel to the x-z plane of the world and should be connected to the vehicle body.</p><p>To work properly, the gravity acceleration vector g of the world must point in the negative y-axis (default)</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>iscut</code>: if more than one wheel set is connected to the same rigid body, <code>iscut</code> must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.</li><li><code>radius</code>: Radius of one wheel</li><li><code>track</code>: Distance between the two wheels (= axle track)</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_middle</code>: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)</li><li><code>frame1</code>: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>frame2</code>: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>axis1</code>: 1-dim. Rotational flange that drives the joint</li><li><code>axis2</code>: 1-dim. Rotational flange that drives the joint</li><li><code>support</code>: Support of 1-dim axes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L638-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SlipWheelJoint-Tuple{}" href="#Multibody.SlipWheelJoint-Tuple{}"><code>Multibody.SlipWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlipWheelJoint(; name, radius, angles = zeros(3), der_angles = zeros(3), x0 = 0, y0 = radius, z0 = 0, sequence, iscut = false, surface = nothing, vAdhesion_min = 0.1, vSlide_min = 0.1, sAdhesion = 0.04, sSlide = 0.12, mu_A = 0.8, mu_S = 0.6, phi_roll = 0, w_roll = 0)</code></pre><p>Joint for a wheel with slip rolling on a surface.</p><div class="admonition is-success"><header class="admonition-header">Integrator choice</header><div class="admonition-body"><p>The slip model contains a discontinuity in the second derivative at the transitions between adhesion and sliding. This can cause problems for integrators, in particular BDF-type integrators.</p></div></div><div class="admonition is-category-warn"><header class="admonition-header">Normal force</header><div class="admonition-body"><p>The wheel cannot leave the ground. Make sure that the normal force <code>f_n</code> never becomes negative.</p></div></div><p><strong>Parameters</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>vAdhesion_min</code>: Minimum adhesion velocity</li><li><code>vSlide_min</code>: Minimum sliding velocity</li><li><code>sAdhesion</code>: Adhesion slippage</li><li><code>sSlide</code>: Sliding slippage</li><li><code>mu_A</code>: Friction coefficient at adhesion</li><li><code>mu_S</code>: Friction coefficient at sliding</li><li><code>surface</code>: By default, the wheel is rolling on a flat xz plane. A function <code>surface = (x, z)-&gt;y</code> may be provided to define a road surface. The function should return the height of the road at <code>(x, z)</code>. Note: if a function that depends on parameters is provided, make sure the parameters are scoped appropriately using, e.g., <code>ParentScope</code>.</li><li><code>state</code>: (structural) whether or not the component has angular state variables. Default is <code>true</code>.</li></ul><p><strong>State and iscut</strong></p><p>When the wheel is mounted on an axis that is rooted, one may either supply <code>state=false</code> or <code>iscut = true</code>. With <code>state = false</code>, the angular state variables are not included in the wheel and there is thus no kinematic chain introduced. This reduces the total number of variables in the system. if the angular variables are required, one may instead pass <code>iscut=true</code> to cut the kinematic loop that is introduced when coupling the angles of the wheel to the orientation of the <code>frame_a</code>, unless this is cut elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L267-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SlippingWheel-Tuple{}" href="#Multibody.SlippingWheel-Tuple{}"><code>Multibody.SlippingWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlippingWheel(; name, radius, m, I_axis, I_long, width = 0.035, x0=0, z0=0,
                  angles = zeros(3), der_angles = zeros(3), kwargs...)</code></pre><p>Wheel with slip rolling on a surface.</p><p><strong>Parameters</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>m</code>: Mass of the wheel</li><li><code>I_axis</code>: Moment of inertia of the wheel along its axis</li><li><code>I_long</code>: Moment of inertia of the wheel perpendicular to its axis</li><li><code>width</code>: Width of the wheel (for rendering)</li><li><code>x0</code>: Initial x-position of the wheel axis</li><li><code>z0</code>: Initial z-position of the wheel axis</li><li><code>state</code>: (structural) whether or not the component has angular state variables. </li></ul><p><strong>Variables</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the wheel component</li></ul><p><strong>Examples</strong></p><p>See <a href="https://help.juliahub.com/multibody/dev/examples/wheel/">Docs: Wheels</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/wheels.jl#L471-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.BodyShape" href="#Multibody.PlanarMechanics.BodyShape"><code>Multibody.PlanarMechanics.BodyShape</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyShape(; name, r = [1,0], r_cm = 0.5*r, gy = -9.80665)</code></pre><p>The <code>BodyShape</code> component is similar to a <a href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Body</code></a>, but it has two frames and a vector <code>r</code> that describes the translation between them, while the body has a single frame only.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (Structural) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_cm</code>: (Structural) Vector from <code>frame_a</code> to the center of mass resolved in <code>frame_a</code></li></ul><p><strong>Subsystems</strong></p><ul><li><code>translation</code>: <a href="#Multibody.PlanarMechanics.FixedTranslation">FixedTranslation</a> Fixed translation between <code>frame_a</code> and <code>frame_b</code></li><li><code>translation_cm</code>: <a href="#Multibody.PlanarMechanics.FixedTranslation">FixedTranslation</a> Fixed translation between <code>frame_a</code> and the center of mass</li><li><code>body</code>: <a href="#Multibody.PlanarMechanics.Body-Tuple{}">Body</a> Body component placed at center of mass. This component holds the inertial properties</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L97-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Damper" href="#Multibody.PlanarMechanics.Damper"><code>Multibody.PlanarMechanics.Damper</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Damper(; name, d = 1, s_small = 1.e-10)</code></pre><p>Linear (velocity dependent) damper</p><p><strong>Parameters:</strong></p><ul><li><code>d</code>: [N.s/m] Damping constant </li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L273-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.DifferentialGear" href="#Multibody.PlanarMechanics.DifferentialGear"><code>Multibody.PlanarMechanics.DifferentialGear</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DifferentialGear(; name)</code></pre><p>A 1D-rotational component that is a variant of a planetary gear and can be used to distribute the torque equally among the wheels on one axis.</p><p><strong>Connectors:</strong></p><ul><li><code>flange_b</code> (Rotational.Flange) Flange for the input torque</li><li><code>flange_left</code> (Rotational.Flange) Flange for the left output torque</li><li><code>flange_right</code> (Rotational.Flange) Flange for the right output torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L778-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Fixed" href="#Multibody.PlanarMechanics.Fixed"><code>Multibody.PlanarMechanics.Fixed</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fixed(; name, r = [0.0, 0.0], phi = 0.0)</code></pre><p>Frame fixed in the planar world frame at a given position and orientation</p><p><strong>Parameters:</strong></p><ul><li><code>r</code>: [m, m] Fixed absolute x,y-position, resolved in world frame</li><li><code>phi</code>: [rad] Fixed angle</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_b</code>: 2-dim. Coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.FixedTranslation" href="#Multibody.PlanarMechanics.FixedTranslation"><code>Multibody.PlanarMechanics.FixedTranslation</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedTranslation(; name, r::AbstractArray, l)</code></pre><p>A fixed translation between two components (rigid rod)</p><p><strong>Parameters:</strong></p><ul><li><code>rx</code>: [m] Fixed x-length of the rod resolved w.r.t to body frame_a at phi = 0</li><li><code>ry</code>: [m] Fixed y-length of the rod resolved w.r.t to body frame_a at phi = 0</li><li><code>radius</code>: [m] Radius of the rod in animations</li><li><code>render</code>: [Bool] Render the rod in animations</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L144-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.IdealPlanetary" href="#Multibody.PlanarMechanics.IdealPlanetary"><code>Multibody.PlanarMechanics.IdealPlanetary</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdealPlanetary(; name, ratio = 2)</code></pre><p>The IdealPlanetary gear box is an ideal gear without inertia, elasticity, damping or backlash consisting of an inner sun wheel, an outer ring wheel and a planet wheel located between sun and ring wheel. The bearing of the planet wheel shaft is fixed in the planet carrier. The component can be connected to other elements at the sun, ring and/or carrier flanges. It is not possible to connect to the planet wheel. If inertia shall not be neglected, the sun, ring and carrier inertias can be easily added by attaching inertias (= model Inertia) to the corresponding connectors. The inertias of the planet wheels are always neglected.</p><p>The ideal planetary gearbox is uniquely defined by the ratio of the number of ring teeth <span>$z_r$</span> with respect to the number of sun teeth <span>$z_s$</span>. For example, if there are 100 ring teeth and 50 sun teeth then ratio = <span>$z_r/z_s = 2$</span>. The number of planet teeth <span>$z_p$</span> has to fulfill the following relationship:</p><p class="math-container">\[z_p = (z_r - z_s) / 2\]</p><p>Therefore, in the above example <span>$z_p = 25$</span> is required.</p><p>According to the overall convention, the positive direction of all vectors, especially the absolute angular velocities and cut-torques in the flanges, are along the axis vector displayed in the icon.</p><p><strong>Parameters:</strong></p><ul><li><code>ratio</code>: Number of ring teeth/sun teeth</li></ul><p><strong>Connectors:</strong></p><ul><li><code>sun</code> (Rotational.Flange) Sun wheel</li><li><code>carrier</code> (Rotational.Flange) Planet carrier</li><li><code>ring</code> (Rotational.Flange) Ring wheel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L741-L761">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SimpleWheel" href="#Multibody.PlanarMechanics.SimpleWheel"><code>Multibody.PlanarMechanics.SimpleWheel</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleWheel(; name, radius = 0.3, color = [1, 0, 0, 1], μ = 1e9)</code></pre><p>Simple wheel model with viscous lateral friction and a driving torque</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> (Frame) Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>thrust</code> (RealInput) Input for the longitudinal force applied to the wheel</li></ul><p><strong>Parameters:</strong></p><ul><li><code>μ</code>: [Ns/m] Viscous friction coefficient</li><li><code>radius</code>: [m] Radius of the wheel</li><li><code>color</code>: Color of the wheel in animations</li></ul><p><strong>Variables:</strong></p><ul><li><code>θ</code>: [rad] Wheel angle</li><li><code>Vx</code>: [m/s] Longitudinal velocity (resolved in local frame)</li><li><code>Vy</code>: [m/s] Lateral velocity (resolved in local frame)</li><li><code>Fy</code>: [N] Lateral friction force</li><li><code>Fx</code>: [N] Applied longitudinal wheel force</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L425-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Spring" href="#Multibody.PlanarMechanics.Spring"><code>Multibody.PlanarMechanics.Spring</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spring(; name, c_x = 1, c_y = 1, c_phi = 1e5, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)</code></pre><p>Linear 2D translational spring</p><p><strong>Parameters:</strong></p><ul><li><code>c_x</code>: [N/m] Spring constant in x dir</li><li><code>c_y</code>: [N/m] Spring constant in y dir</li><li><code>c_phi</code>: [N.m/rad] Spring constant in phi dir</li><li><code>s_relx0</code>: [m] Unstretched spring length</li><li><code>s_rely0</code>: [m] Unstretched spring length</li><li><code>phi_rel0</code>: [rad] Unstretched spring angle</li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li><li><code>num_windings</code>: [Int] Number of windings of the coil when rendered</li><li><code>color = [0,0,1,1]</code> Color of the spring in animations</li><li><code>render = true</code> Render the spring in animations</li><li><code>radius = 0.1</code> Radius of spring when rendered</li><li><code>N = 200</code> Number of points in mesh when rendered</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L200-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SpringDamper" href="#Multibody.PlanarMechanics.SpringDamper"><code>Multibody.PlanarMechanics.SpringDamper</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpringDamper(; name, c_x = 1, c_y = 1, c_phi = 1e5, d_x = 1, d_y = 1, d_phi = 1, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)</code></pre><p>Linear 2D translational spring damper model</p><p><strong>Parameters:</strong></p><ul><li><code>c_x</code>: [N/m] Spring constant in x dir</li><li><code>c_y</code>: [N/m] Spring constant in y dir</li><li><code>c_phi</code>: [N.m/rad] Spring constant in phi dir</li><li><code>d_x</code>: [N.s/m] Damping constant in x dir</li><li><code>d_y</code>: [N.s/m] Damping constant in y dir</li><li><code>d_phi</code>: [N.m.s/rad] Damping constant in phi dir</li><li><code>s_relx0</code>: [m] Unstretched spring length</li><li><code>s_rely0</code>: [m] Unstretched spring length</li><li><code>phi_rel0</code>: [rad] Unstretched spring angle</li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li><li><code>num_windings</code>: [Int] Number of windings of the coil when rendered</li><li><code>color = [0,0,1,1]</code> Color of the spring in animations</li><li><code>render = true</code> Render the spring in animations</li><li><code>radius = 0.1</code> Radius of spring when rendered</li><li><code>N = 200</code> Number of points in mesh when rendered</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L334-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Body-Tuple{}" href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Multibody.PlanarMechanics.Body</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Body(; name, m=1, I=0.1, r=0, gy=-9.80665, radius=0.1, render=true, color=Multibody.purple)</code></pre><p>Body component with mass and inertia</p><p><strong>Parameters:</strong></p><ul><li><code>m</code>: [kg] mass of the body</li><li><code>I</code>: [kg.m²] inertia of the body with respect to the origin of <code>frame</code> along the z-axis of <code>frame</code></li><li><code>r</code>: [m, m] Translational position x,y-position</li><li><code>gy</code>: [m/s²] gravity field acting on the mass in the y-direction, positive value acts in the positive direction defaults to -9.80665</li><li><code>radius</code>: [m] Radius of the body in animations</li><li><code>render</code>: [Bool] Render the body in animations</li><li><code>color</code>: [Array{Float64,1}] Color of the body in animations</li></ul><p><strong>Variables:</strong></p><ul><li><code>r</code>: [m, m] x,y position</li><li><code>v</code>: [m/s, m/s] x,y velocity</li><li><code>a</code>: [m/s², m/s²] x,y acceleration</li><li><code>phi</code>: [rad] rotation angle (counterclockwise)</li><li><code>w</code>: [rad/s] angular velocity</li><li><code>α</code>: [rad/s²] angular acceleration</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame</code>: 2-dim. Coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L31-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}" href="#Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}"><code>Multibody.PlanarMechanics.SlipBasedWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlipBasedWheelJoint(;
    name,
    r = [1, 0],
    N,
    vAdhesion_min,
    vSlide_min,
    sAdhesion,
    sSlide,
    mu_A,
    mu_S,
    render = true,
    color = [0.1, 0.1, 0.1, 1],
    z = 0,
    diameter = 0.1,
    width = diameter * 0.6,
    radius = 0.1,
    w_roll = nothing,
)</code></pre><p>Slip-based wheel joint</p><p>The ideal wheel joint models the behavior of a wheel rolling on a x,y-plane whose contact patch has slip-dependent friction characteristics. This is an approximation for wheels with a rim and a rubber tire.</p><p>The force depends with friction characteristics on the slip. The slip is split into two components:</p><ul><li>lateral slip: the lateral velocity divided by the rolling velocity.</li><li>longitudinal slip: the longitudinal slip velocity divided by the rolling velocity.</li></ul><p>For low rolling velocity this definition become ill-conditioned. Hence a dry-friction model is used for low rolling velocities. For <strong>zero rolling velocity</strong>, the intitialization might fail if automatic differentiation is used. Either start with a non-zero (but tiny) rolling velocity or pass <code>autodiff=false</code> to the solver.</p><p>The radius of the wheel can be specified by the parameter <code>radius</code>. The driving direction (for <code>phi = 0</code>) can be specified by the parameter <code>r</code>. The normal load is set by <code>N</code>.</p><p>The wheel contains a 2D connector <code>frame_a</code> for the steering on the plane. The rolling motion of the wheel can be actuated by the 1D connector <code>flange_a</code>.</p><p>In addition there is an input <code>dynamicLoad</code> for a dynamic component of the normal load.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> (Frame) Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>flange_a</code> (Rotational.Flange) Flange for the rolling motion</li><li><code>dynamicLoad</code> (Blocks.RealInput) Input for the dynamic component of the normal load (must be connected)</li></ul><p><strong>Terminology:</strong></p><ul><li><em>Adhesion</em> refers to the peak of the traction curve, where the slip is such that the maximum amount of traction is generated.</li><li><em>Sliding velocity</em> refers to the velocity at which the traction curve saturates and stays constant with increased slip velocity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L597-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}" href="#Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit_S_form(x_min, x_max, y_min, y_max, x)</code></pre><p>Returns a S-shaped transition</p><p>A smooth transition between points <code>(x_min, y_min)</code> and <code>(x_max, y_max)</code>. The transition is done in such a way that the function&#39;s 1st derivative is continuous for all <code>x</code>. The higher derivatives are discontinuous at input points.</p><pre><code class="nohighlight hljs">x_min = -0.4
x_max = 0.6
y_max = 1.4
y_min = 1.2

julia&gt; plot(x-&gt;Multibody.PlanarMechanics.limit_S_form(x_min, x_max, y_min, y_max, x), -1, 1, legend=false)
         ┌────────────────────────────────────────┐ 
   1.406 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⡠⠔⠒⠒⠒⠒⠒⠒⠒⠂⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠃⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡔⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   1.194 │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⠉⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         └────────────────────────────────────────┘ 
         ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L544-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}" href="#Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_triple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit_S_triple(x_max, x_sat, y_max, y_sat, x)</code></pre><p>Returns a point-symmetric Triple S-Function</p><p>A point symmetric interpolation between points <code>(0, 0), (x_max, y_max) and (x_sat, y_sat)</code>, provided <code>x_max &lt; x_sat</code>. The approximation is done in such a way that the function&#39;s 1st derivative is zero at points <code>(x_max, y_max)</code> and <code>(x_sat, y_sat)</code>. Thus, the function&#39;s 1st derivative is continuous for all <code>x</code>. The higher derivatives are discontinuous at these points.</p><pre><code class="nohighlight hljs">x_max = 0.2
x_sat = 0.5
y_max = 1.4
y_sat = 1.2

plot(x-&gt;Multibody.PlanarMechanics.limit_S_triple(x_max, x_sat, y_max, y_sat, x), -1, 1)
vline!([x_max x_sat], label=[&quot;x_max&quot; &quot;x_sat&quot;])

            ┌────────────────────────────────────────┐ 
    1.48385 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⡔⠢⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⡜⠀⠀⠀⠈⠉⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠂⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⣀⡀⠀⠀⠀⡜⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   -1.48377 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠒⠦⠼⠁⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            └────────────────────────────────────────┘ 
            ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/a8a917e4678ba8a944fb7e80c7eb111ad256c2a2/src/PlanarMechanics/components.jl#L497-L532">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../joints/">« Joints</a><a class="docs-footer-nextpage" href="../forces/">Forces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 1 October 2024 03:55">Tuesday 1 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
