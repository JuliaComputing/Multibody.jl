<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started: Pendulum · Multibody.jl</title><meta name="title" content="Getting started: Pendulum · Multibody.jl"/><meta property="og:title" content="Getting started: Pendulum · Multibody.jl"/><meta property="twitter:title" content="Getting started: Pendulum · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting started: Pendulum</a><ul class="internal"><li><a class="tocitem" href="#Modeling-the-pendulum"><span>Modeling the pendulum</span></a></li><li><a class="tocitem" href="#3D-Animation"><span>3D Animation</span></a></li><li><a class="tocitem" href="#Adding-damping"><span>Adding damping</span></a></li><li><a class="tocitem" href="#A-linear-pendulum?"><span>A linear pendulum?</span></a></li><li><a class="tocitem" href="#Going-3D"><span>Going 3D</span></a></li><li><a class="tocitem" href="#Orientations-and-directions"><span>Orientations and directions</span></a></li><li><a class="tocitem" href="#Control-design-example:-Pendulum-on-cart"><span>Control-design example: Pendulum on cart</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="../spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="../three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="../sensors/">Sensors</a></li><li><a class="tocitem" href="../spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="../gearbox/">Gearbox</a></li><li><a class="tocitem" href="../free_motion/">Free motions</a></li><li><a class="tocitem" href="../prescribed_pose/">Prescribed motions</a></li><li><a class="tocitem" href="../kinematic_loops/">Kinematic loops</a></li><li><a class="tocitem" href="../robot/">Industrial robot</a></li><li><a class="tocitem" href="../ropes_and_cables/">Ropes, cables and chains</a></li><li><a class="tocitem" href="../swing/">Swing</a></li><li><a class="tocitem" href="../space/">Bodies in space</a></li><li><a class="tocitem" href="../gyroscopic_effects/">Gyroscopic effects</a></li><li><a class="tocitem" href="../wheel/">Wheels</a></li><li><a class="tocitem" href="../suspension/">Suspension systems</a></li><li><a class="tocitem" href="../quad/">Quadrotor with cable-suspended load</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../../frames/">Frames</a></li><li><a class="tocitem" href="../../joints/">Joints</a></li><li><a class="tocitem" href="../../components/">Components</a></li><li><a class="tocitem" href="../../forces/">Forces</a></li><li><a class="tocitem" href="../../sensors/">Sensors</a></li><li><a class="tocitem" href="../../trajectory_planning/">Trajectory planning</a></li><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../../rotations/">Rotations and orientation</a></li><li><a class="tocitem" href="../../rendering/">3D rendering</a></li><li><a class="tocitem" href="../../urdf/">URDF import</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting started: Pendulum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started: Pendulum</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;"><a class="docs-heading-anchor" href="#Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;">Pendulum–The &quot;Hello World of multi-body dynamics&quot;</a><a id="Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;" title="Permalink"></a></h1><p>This beginners tutorial will start by modeling a pendulum pivoted around the origin in the world frame. The world frame is a constant that lives inside the Multibody module, all multibody models are &quot;grounded&quot; in the same world, i.e., the <code>world</code> component must be included exactly once in all models, at the top level.</p><p>To start, we load the required packages</p><pre><code class="language-julia hljs">using ModelingToolkit
using Multibody, JuliaSimCompiler
using OrdinaryDiffEq # Contains the ODE solver we will use
using Plots</code></pre><p>We then access the world frame and time variable from the Multibody module</p><pre><code class="language-julia hljs">t = Multibody.t
world = Multibody.world</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model world with 19 (25) equations
Unknowns (16):
  (n_inner(t))[1]
  (n_inner(t))[2]
  (n_inner(t))[3]
  g_inner(t)
  mu_inner(t)
  render_inner(t)
  point_gravity_inner(t)
  (frame_b₊r_0(t))[1] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊r_0(t))[2] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊r_0(t))[3] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊f(t))[1]: Cut force resolved in connector frame
  (frame_b₊f(t))[2]: Cut force resolved in connector frame
  (frame_b₊f(t))[3]: Cut force resolved in connector frame
  (frame_b₊tau(t))[1]: Cut torque resolved in connector frame
  (frame_b₊tau(t))[2]: Cut torque resolved in connector frame
  (frame_b₊tau(t))[3]: Cut torque resolved in connector frame
Parameters (10):
  n[1] [defaults to 0.0]: gravity direction
  n[2] [defaults to -1.0]: gravity direction
  n[3] [defaults to 0.0]: gravity direction
  g [defaults to 9.80665]: gravitational acceleration of world
  mu [defaults to 3.986e14]: Gravity field constant [m³/s²] (default = field constant of earth)
  point_gravity [defaults to false]
  render [defaults to true]
  frame_b₊render [defaults to false]
  frame_b₊length [defaults to 1.0]
  frame_b₊radius [defaults to 0.1]</code></pre><p>Unless otherwise specified, the world defaults to having a gravitational field pointing in the negative <span>$y$</span> direction and a gravitational acceleration of <span>$9.81$</span> (See <a href="../space/#Bodies-in-space">Bodies in space</a> for more options).</p><h2 id="Modeling-the-pendulum"><a class="docs-heading-anchor" href="#Modeling-the-pendulum">Modeling the pendulum</a><a id="Modeling-the-pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-the-pendulum" title="Permalink"></a></h2><p>Our simple pendulum will initially consist of a <a href="../../components/#Multibody.Body-Tuple{}"><code>Body</code></a> (point mass) and a <a href="../../joints/#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint (the pivot joint). We construct these elements by calling their constructors</p><pre><code class="language-julia hljs">@named joint = Revolute(n = [0, 0, 1], isroot = true)
@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])</code></pre><p>The <code>n</code> argument to <a href="../../joints/#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> denotes the rotational axis of the joint, this vector must have <code>norm(n) == 1</code>. We also indicate that the revolute joint is the root of the kinematic tree, i.e., the potential state of the joint will serve as the state variables for the system.</p><p>The <a href="../../components/#Multibody.Body-Tuple{}"><code>Body</code></a> is constructed by providing its mass, <code>m</code>, and the vector <code>r_cm</code> from its mounting frame, <code>body.frame_a</code>, to the center of mass. Since the world by default has the gravity field pointing along the negative <span>$y$</span> axis, we place the center of mass along the <span>$x$</span>-axis to make the pendulum swing back and forth. The body is not selected as the root of the kinematic tree, since we have a joint in this system, but if we had attached the body directly to, e.g., a spring, we could set the body to be the root and avoid having to introduce an &quot;artificial joint&quot;, which is otherwise needed in order to have at least one component that has a potential state.</p><p>To connect the components together, we create a vector of connections using the <code>connect</code> function. A joint typically has two frames, <code>frame_a</code> and <code>frame_b</code>. In this example, the first frame of the joint is attached to the world frame, and the body is attached to the second frame of the joint, i.e., the joint allows the body to swing back and forth. The order of the connections is not important for ModelingToolkit, but it&#39;s good practice to follow some convention, here, we start at the world and progress outwards in the kinematic tree.</p><pre><code class="language-julia hljs">connections = [
    connect(world.frame_b, joint.frame_a)
    connect(joint.frame_b, body.frame_a)
]</code></pre><p>With all components and connections defined, we can create an <code>ODESystem</code> like so:</p><pre><code class="language-julia hljs">@named model = ODESystem(connections, t, systems=[world, joint, body])
model = complete(model)</code></pre><p>The <code>ODESystem</code> is the fundamental model type in ModelingToolkit used for multibody-type models.</p><p>Before we can simulate the system, we must perform model check using the function <a href="#Multibody.multibody"><code>multibody</code></a> and compilation using <a href="@ref"><code>structural_simplify</code></a></p><pre><code class="language-julia hljs">ssys = structural_simplify(multibody(model))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ScheduledSystem with state (2):
 joint₊phi
 joint₊w</code></pre><p>This results in a simplified model with the minimum required variables and equations to be able to simulate the system efficiently. This step rewrites all <code>connect</code> statements into the appropriate equations, and removes any redundant variables and equations. To simulate the pendulum, we require two state variables, one for angle and one for angular velocity, we can see above that these state variables have indeed been chosen.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.multibody" href="#Multibody.multibody"><code>Multibody.multibody</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multibody(model)</code></pre><p>Perform validity checks on the model, such as the precense of exactly one world component in the top level of the model, and transform the model into an <code>IRSystem</code> object for passing into <code>structural_simplify</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/083796e7997ef2e8e085918ad314e2d4c8b17e9e/src/Multibody.jl#L72-L76">source</a></section></article><p>We are now ready to create an <code>ODEProblem</code> and simulate it. We use the <code>Rodas4</code> solver from OrdinaryDiffEq.jl, and pass a dictionary for the initial conditions. We specify only initial condition for some variables, for those variables where no initial condition is specified, the default initial condition defined the model will be used.</p><pre><code class="language-julia hljs">D = Differential(t)
defs = Dict() # We may specify the initial condition here
prob = ODEProblem(ssys, defs, (0, 3.35))

sol = solve(prob, Rodas4())
plot(sol, idxs = joint.phi, title=&quot;Pendulum&quot;)</code></pre><img src="2dcf1208.svg" alt="Example block output"/><p>The solution <code>sol</code> can be plotted directly if the Plots package is loaded. The figure indicates that the pendulum swings back and forth without any damping. To add damping as well, we could add a <code>Damper</code> from the <code>ModelingToolkitStandardLibrary.Mechanical.Rotational</code> module to the revolute joint. We do this below</p><h2 id="3D-Animation"><a class="docs-heading-anchor" href="#3D-Animation">3D Animation</a><a id="3D-Animation-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Animation" title="Permalink"></a></h2><p>Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:</p><pre><code class="language-julia hljs">import GLMakie # GLMakie is another alternative, suitable for interactive plots
Multibody.render(model, sol; filename = &quot;pendulum.gif&quot;) # Use &quot;pendulum.mp4&quot; for a video file</code></pre><p><img src="../pendulum.gif" alt="animation"/></p><p>By default, the world frame is indicated using the convention x: red, y: green, z: blue. The animation shows how the simple <a href="../../components/#Multibody.Body-Tuple{}"><code>Body</code></a> represents a point mass with inertial properties at a particular distance <code>r_cm</code> away from its mounting flange <code>frame_a</code>. The cylinder that is shown connecting the pivot point to the body is for visualization purposes only, it does not have any inertial properties. To model a more physically motivated pendulum rod, we could have used a <a href="../../components/#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> component, which has two mounting flanges instead of one. The <a href="../../components/#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> component is shown in several of the examples available in the example sections of the documentation.</p><h2 id="Adding-damping"><a class="docs-heading-anchor" href="#Adding-damping">Adding damping</a><a id="Adding-damping-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-damping" title="Permalink"></a></h2><p>To add damping to the pendulum such that the pendulum will eventually come to rest, we add a <a href="../../forces/#Multibody.Damper-Tuple{}"><code>Damper</code></a> to the revolute joint. The damping coefficient is given by <code>d</code>, and the damping force is proportional to the angular velocity of the joint. To add the damper to the revolute joint, we must create the joint with the keyword argument <code>axisflange = true</code>, this adds two internal flanges to the joint to which you can attach components from the <code>ModelingToolkitStandardLibrary.Mechanical.Rotational</code> module (1-dimensional components). We then connect one of the flanges of the damper to the axis flange of the joint, and the other damper flange to the support flange which is rigidly attached to the world.</p><pre><code class="language-julia hljs">@named damper = Rotational.Damper(d = 0.3)
@named joint = Revolute(n = [0, 0, 1], isroot = true, axisflange = true)

connections = [connect(world.frame_b, joint.frame_a)
               connect(damper.flange_b, joint.axis)
               connect(joint.support, damper.flange_a)
               connect(body.frame_a, joint.frame_b)]

@named model = ODESystem(connections, t, systems = [world, joint, body, damper])
model = complete(model)
ssys = structural_simplify(multibody(model))

prob = ODEProblem(ssys, [damper.phi_rel =&gt; 1], (0, 10))

sol = solve(prob, Rodas4())
plot(sol, idxs = joint.phi, title=&quot;Damped pendulum&quot;)</code></pre><img src="c26d3fc9.svg" alt="Example block output"/><p>This time we see that the pendulum loses energy and eventually comes to rest at the stable equilibrium point <span>$\pi / 2$</span>.</p><pre><code class="language-julia hljs">Multibody.render(model, sol; filename = &quot;pendulum_damped.gif&quot;)</code></pre><p><img src="../pendulum_damped.gif" alt="animation damped"/></p><h2 id="A-linear-pendulum?"><a class="docs-heading-anchor" href="#A-linear-pendulum?">A linear pendulum?</a><a id="A-linear-pendulum?-1"></a><a class="docs-heading-anchor-permalink" href="#A-linear-pendulum?" title="Permalink"></a></h2><p>When we think of a pendulum, we typically think of a rotary pendulum that is rotating around a pivot point like in the examples above.  A mass suspended in a spring can be though of as a linear pendulum (often referred to as a harmonic oscillator rather than a pendulum), and we show here how we can construct a model of such a device. This time around, we make use of a <a href="../../joints/#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint rather than a <a href="../../joints/#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint. A <a href="https://en.wikipedia.org/wiki/Prismatic_joint">prismatic joint</a> has one positional degree of freedom, compared to the single rotational degree of freedom for the revolute joint.</p><pre><code class="language-julia hljs">@named body_0 = Body(; m = 1, isroot = false, r_cm = [0, 0, 0])
@named damper = Translational.Damper(d=1)
@named spring = Translational.Spring(c=10)
@named joint = Prismatic(n = [0, 1, 0], axisflange = true)

connections = [connect(world.frame_b, joint.frame_a)
               connect(damper.flange_b, spring.flange_b, joint.axis)
               connect(joint.support, damper.flange_a, spring.flange_a)
               connect(body_0.frame_a, joint.frame_b)]

@named model = ODESystem(connections, t, systems = [world, joint, body_0, damper, spring])
model = complete(model)
ssys = structural_simplify(multibody(model))

prob = ODEProblem(ssys, [], (0, 10))

sol = solve(prob, Rodas4())
Plots.plot(sol, idxs = joint.s, title=&quot;Mass-spring-damper system&quot;)</code></pre><img src="1c0faf02.svg" alt="Example block output"/><p>As is hopefully evident from the little code snippet above, this linear pendulum model has a lot in common with the rotary pendulum. In this example, we connected both the spring and a damper to the same axis flange in the joint. This time, the components came from the <code>Translational</code> submodule of ModelingToolkitStandardLibrary rather than the <code>Rotational</code> submodule. Also here do we pass <code>axisflange</code> when we create the joint to make sure that it is equipped with the flanges <code>support</code> and <code>axis</code> needed to connect the translational components.</p><pre><code class="language-julia hljs">Multibody.render(model, sol; filename = &quot;linear_pend.gif&quot;, framerate=24)</code></pre><p><img src="../linear_pend.gif" alt="linear pendulum"/></p><h3 id="Why-do-we-need-a-joint?"><a class="docs-heading-anchor" href="#Why-do-we-need-a-joint?">Why do we need a joint?</a><a id="Why-do-we-need-a-joint?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-we-need-a-joint?" title="Permalink"></a></h3><p>In the example above, we introduced a prismatic joint to model the oscillating motion of the mass-spring system. In reality, we can suspend a mass in a spring without any joint, so why do we need one here? The answer is that we do not, in fact, need the joint, but if we connect the spring directly to the world, we need to make the body (mass) the root object of the kinematic tree instead:</p><pre><code class="language-julia hljs">@named root_body = Body(; m = 1, isroot = true, r_cm = [0, 1, 0], phi0 = [0, 1, 0])
@named multibody_spring = Multibody.Spring(c=10)

connections = [connect(world.frame_b, multibody_spring.frame_a)
                connect(root_body.frame_a, multibody_spring.frame_b)]

@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body])
model = complete(model)
ssys = structural_simplify(multibody(model))

defs = Dict(collect(root_body.r_0) .=&gt; [0, 1e-3, 0]) # The spring has a singularity at zero length, so we start some distance away

prob = ODEProblem(ssys, defs, (0, 10))

sol = solve(prob, Rodas4())
plot(sol, idxs = multibody_spring.r_rel_0[2], title=&quot;Mass-spring system without joint&quot;)</code></pre><img src="d9aeacb3.svg" alt="Example block output"/><p>Here, we used a <a href="../../forces/#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> instead of connecting a <code>Translational.Spring</code> to a joint. The <code>Translational.Spring</code>, alongside other components from <code>ModelingToolkitStandardLibrary.Mechanical</code>, is a 1-dimensional object, whereas multibody components are 3-dimensional objects.</p><p>Internally, the <a href="../../forces/#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> contains a <code>Translational.Spring</code>, attached between two flanges, so we could actually add a damper to the system as well:</p><pre><code class="language-julia hljs">push!(connections, connect(multibody_spring.spring2d.flange_a, damper.flange_a))
push!(connections, connect(multibody_spring.spring2d.flange_b, damper.flange_b))

@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body, damper])
model = complete(model)
ssys = structural_simplify(multibody(model))
prob = ODEProblem(ssys, defs, (0, 10))

sol = solve(prob, Rodas4(), u0 = prob.u0 .+ 1e-5 .* randn.())
plot(sol, idxs = multibody_spring.r_rel_0[2], title=&quot;Mass-spring-damper without joint&quot;)</code></pre><img src="9617ae7c.svg" alt="Example block output"/><p>The figure above should look identical to the simulation of the mass-spring-damper further above.</p><h2 id="Going-3D"><a class="docs-heading-anchor" href="#Going-3D">Going 3D</a><a id="Going-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Going-3D" title="Permalink"></a></h2><p>The systems we have modeled so far have all been <em>planar</em> mechanisms. We now extend this to a 3-dimensional system, the <a href="https://en.wikipedia.org/wiki/Furuta_pendulum"><em>Furuta pendulum</em></a>.</p><p>This pendulum, sometimes referred to as a <em>rotary pendulum</em>, has two joints, one in the &quot;shoulder&quot;, which is typically configured to rotate around the gravitational axis, and one in the &quot;elbow&quot;, which is typically configured to rotate around the axis of the upper arm. The upper arm is attached to the shoulder joint, and the lower arm is attached to the elbow joint. The tip of the pendulum is attached to the lower arm.</p><pre><code class="language-julia hljs">using ModelingToolkit, Multibody, JuliaSimCompiler, OrdinaryDiffEq, Plots
import ModelingToolkitStandardLibrary.Mechanical.Rotational.Damper as RDamper
import Multibody.Rotations

@mtkmodel FurutaPendulum begin
    @components begin
        world = World()
        shoulder_joint = Revolute(n = [0, 1, 0], axisflange = true)
        elbow_joint    = Revolute(n = [0, 0, 1], axisflange = true, phi0=0.1)
        upper_arm = BodyShape(; m = 0.1, r = [0, 0, 0.6], radius=0.04)
        lower_arm = BodyShape(; m = 0.1, r = [0, 0.6, 0], radius=0.04)
        tip = Body(; m = 0.3)

        damper1 = RDamper(d = 0.07)
        damper2 = RDamper(d = 0.07)
    end
    @equations begin
        connect(world.frame_b, shoulder_joint.frame_a)
        connect(shoulder_joint.frame_b, upper_arm.frame_a)
        connect(upper_arm.frame_b, elbow_joint.frame_a)
        connect(elbow_joint.frame_b, lower_arm.frame_a)
        connect(lower_arm.frame_b, tip.frame_a)

        connect(shoulder_joint.axis, damper1.flange_a)
        connect(shoulder_joint.support, damper1.flange_b)

        connect(elbow_joint.axis, damper2.flange_a)
        connect(elbow_joint.support, damper2.flange_b)

    end
end

@named model = FurutaPendulum()
model = complete(model)
ssys = structural_simplify(multibody(model))

prob = ODEProblem(ssys, [model.shoulder_joint.phi =&gt; 0.0, model.elbow_joint.phi =&gt; 0.1], (0, 10))
sol = solve(prob, Rodas4())
plot(sol, layout=4)</code></pre><img src="e3d78353.svg" alt="Example block output"/><p>In the animation below, we visualize the path that the origin of the pendulum tip traces by providing the tip frame in a vector of frames passed to <code>traces</code></p><pre><code class="language-julia hljs">import GLMakie
Multibody.render(model, sol, filename = &quot;furuta.gif&quot;, traces=[model.tip.frame_a])</code></pre><p><img src="../furuta.gif" alt="furuta"/></p><h2 id="Orientations-and-directions"><a class="docs-heading-anchor" href="#Orientations-and-directions">Orientations and directions</a><a id="Orientations-and-directions-1"></a><a class="docs-heading-anchor-permalink" href="#Orientations-and-directions" title="Permalink"></a></h2><p>Let&#39;s break down how to think about directions and orientations when building 3D mechanisms. In the example above, we started with the shoulder joint, this joint rotated around the gravitational axis, <code>n = [0, 1, 0]</code>. When this joint is positioned in joint coordinate <code>shoulder_joint.phi = 0</code>, its <code>frame_a</code> and <code>frame_b</code> will coincide. When the joint rotates, <code>frame_b</code> will rotate around the axis <code>n</code> of <code>frame_a</code>. The <code>frame_a</code> of the joint is attached to the world, so the joint will rotate around the world&#39;s <code>y</code>-axis:</p><pre><code class="language-julia hljs">get_rot(sol, model.shoulder_joint.frame_b, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 RotMatrix3{Float64} with indices SOneTo(3)×SOneTo(3):
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre><p>we see that at time <span>$t = 0$</span>, we have no rotation of <code>frame_b</code> around the <span>$y$</span> axis of the world (frames are always resolved in the world frame), but a second into the simulation, we have:</p><pre><code class="language-julia hljs">R1 = get_rot(sol, model.shoulder_joint.frame_b, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 RotMatrix3{Float64} with indices SOneTo(3)×SOneTo(3):
 0.739387  0.0  -0.67328
 0.0       1.0   0.0
 0.67328   0.0   0.739387</code></pre><p>Here, the <code>frame_b</code> has rotated around the <span>$y$</span> axis of the world (if you are not familiar with rotation matrices, we can ask for the rotation axis and angle)</p><pre><code class="language-julia hljs">using Multibody.Rotations
rotation_axis(R1), rotation_angle(R1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([6.734077305763844e-63, -1.0, 0.0], 0.7386364712179742)</code></pre><p>This rotation axis and angle should correspond to the joint coordinate (the orientation described by an axis and an angle is invariant to a multiplication of both by -1)</p><pre><code class="language-julia hljs">sol(1, idxs=model.shoulder_joint.phi)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.7386364712179742</code></pre><div class="admonition is-info"><header class="admonition-header">Convention</header><div class="admonition-body"><p>The convention used in <a href="../../rotations/#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a> is to return the rotation matrix <span>$R_{World}^{Local}$</span> that rotates a coordinate from the local frame to the world frame, <span>$r_{World} = R_{World}^{Local} r_{Local}$</span>.</p></div></div><p>Here, we made use of the function <a href="../../rotations/#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>, we will now make use of also <a href="../../rotations/#Multibody.get_trans-Tuple{Any, Any, Number}"><code>get_trans</code></a> and <a href="../../rotations/#Multibody.get_frame-Tuple{Any, Any, Any}"><code>get_frame</code></a>.</p><p>The next body is the upper arm. This body has an extent of <code>0.6</code> in the <span>$z$</span> direction, as measured in its local <code>frame_a</code></p><pre><code class="language-julia hljs">get_trans(sol, model.upper_arm.frame_b, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.0
 0.6</code></pre><p>One second into the simulation, the upper arm has rotated around the <span>$y$</span> axis of the world</p><pre><code class="language-julia hljs">rb1 = get_trans(sol, model.upper_arm.frame_b, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -0.4039682171904861
  0.0
  0.44363236976120235</code></pre><p>If we look at the variable <code>model.upper_arm.r</code>, we do not see this rotation!</p><pre><code class="language-julia hljs">arm_r = sol(1, idxs=collect(model.upper_arm.r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 0.0
 0.0
 0.6</code></pre><p>The reason is that this variable is resolved in the local <code>frame_a</code> and not in the world frame. To transform this variable to the world frame, we may multiply with the rotation matrix of <code>frame_a</code> which is always resolved in the world frame:</p><pre><code class="language-julia hljs">get_rot(sol, model.upper_arm.frame_a, 1)*arm_r</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -0.4039682171904861
  0.0
  0.44363236976120235</code></pre><p>We now get the same result has when we asked for the translation vector of <code>frame_b</code> above.</p><p>Slightly more formally, let <span>$R_A^B$</span> denote the rotation matrix that rotates a vector expressed in a frame <span>$A$</span> into one that is expressed in frame <span>$B$</span>, i.e., <span>$r_B = R_B^A r_A$</span>. We have then just performed the transformation <span>$r_W = R_W^A r_A$</span>, where <span>$W$</span> denotes the world frame, and <span>$A$</span> denotes <code>body.frame_a</code>.</p><p>The next joint, the elbow joint, has the rotational axis <code>n = [0, 0, 1]</code>. This indicates that the joint rotates around the <span>$z$</span>-axis of its <code>frame_a</code>. Since the upper arm was oriented along the <span>$z$</span> direction, the joint is rotating around the axis that coincides with the upper arm. </p><p>The lower arm is finally having an extent along the <span>$y$</span>-axis. At the final time when the pendulum motion has been fully damped, we see that the second frame of this body ends up with an <span>$y$</span>-coordinate of <code>-0.6</code>:</p><pre><code class="language-julia hljs">get_trans(sol, model.lower_arm.frame_b, 12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -0.0007983770794975084
 -0.599999999979659
  0.5999994688484717</code></pre><p>If we rotate the vector of extent of the lower arm to the world frame, we indeed see that the only coordinate that is nonzero is the <span>$y$</span> coordinate:</p><pre><code class="language-julia hljs">get_rot(sol, model.lower_arm.frame_a, 12)*sol(12, idxs=collect(model.lower_arm.r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
  4.940552441510778e-6
 -0.599999999979659
  6.614727408270282e-9</code></pre><p>The reason that the latter vector differs from <code>get_trans(sol, model.lower_arm.frame_b, 12)</code> above is that <code>get_trans(sol, model.lower_arm.frame_b, 12)</code> has been <em>translated</em> as well. To both translate and rotate <code>model.lower_arm.r</code> into the world frame, we must use the full transformation matrix <span>$T_W^A \in SE(3)$</span>:</p><pre><code class="language-julia hljs">r_A = sol(12, idxs=collect(model.lower_arm.r))
r_A = [r_A; 1] # Homogeneous coordinates

get_frame(sol, model.lower_arm.frame_a, 12)*r_A</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 -0.0007983770794975084
 -0.599999999979659
  0.5999994688484717
  1.0</code></pre><p>the vector is now coinciding with <code>get_trans(sol, model.lower_arm.frame_b, 12)</code>.</p><h2 id="Control-design-example:-Pendulum-on-cart"><a class="docs-heading-anchor" href="#Control-design-example:-Pendulum-on-cart">Control-design example: Pendulum on cart</a><a id="Control-design-example:-Pendulum-on-cart-1"></a><a class="docs-heading-anchor-permalink" href="#Control-design-example:-Pendulum-on-cart" title="Permalink"></a></h2><p>We will now demonstrate a complete workflow including</p><ul><li>Modeling</li><li>Linearization</li><li>Control design</li></ul><p>We will continue the pendulum theme and design an inverted pendulum on cart. The cart is modeled as <a href="../../components/#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> with specified mass, and <code>shape = &quot;box&quot;</code> to render it as a box in animations. The cart is moving along the <span>$x$</span>-axis by means of a <a href="../../joints/#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint, and the pendulum is attached to the cart by means of a <a href="../../joints/#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint. The pendulum is a <a href="../../components/#Multibody.BodyCylinder"><code>BodyCylinder</code></a> with a diameter of <code>0.015</code>, the mass and inertia properties are automatically computed using the geometrical dimensions and the density (which defaults to that of steel). A force is applied to the cart by means of a <code>TranslationalModelica.Force</code> component.</p><p>We start by putting the model together and control it in open loop using a simple periodic input signal:</p><pre><code class="language-julia hljs">import ModelingToolkitStandardLibrary.Mechanical.TranslationalModelica
import ModelingToolkitStandardLibrary.Blocks
using Plots
gray = [0.5, 0.5, 0.5, 1]
@mtkmodel Cartpole begin
    @structural_parameters begin
        use_world = false
    end
    @components begin
        if use_world
            fixed = World()
        else
            # In case we wrap this model in an outer model below, we place the world there instead
            fixed = Fixed()
        end
        cart = BodyShape(m = 1, r = [0.2, 0, 0], color=[0.2, 0.2, 0.2, 1], shape=&quot;box&quot;)
        mounting_point = FixedTranslation(r = [0.1, 0, 0])
        prismatic = Prismatic(n = [1, 0, 0], axisflange = true, color=gray, state_priority=100)
        revolute = Revolute(n = [0, 0, 1], axisflange = false, state_priority=100)
        pendulum = BodyCylinder(r = [0, 0.5, 0], diameter = 0.015, color=gray)
        motor = TranslationalModelica.Force(use_support = true)
        tip = Body(m = 0.05)
    end
    @variables begin
        u(t) = 0
        x(t)
        v(t)
        phi(t)
        w(t)
    end
    @equations begin
        connect(fixed.frame_b, prismatic.frame_a)
        connect(prismatic.frame_b, cart.frame_a, mounting_point.frame_a)
        connect(mounting_point.frame_b, revolute.frame_a)
        connect(revolute.frame_b, pendulum.frame_a)
        connect(pendulum.frame_b, tip.frame_a)
        connect(motor.flange, prismatic.axis)
        connect(prismatic.support, motor.support)
        u ~ motor.f.u
        x ~ prismatic.s
        v ~ prismatic.v
        phi ~ revolute.phi
        w ~ revolute.w
    end
end
@mtkmodel CartWithInput begin
    @components begin
        world = World()
        cartpole = Cartpole()
        input = Blocks.Cosine(frequency=1, amplitude=1)
    end
    @equations begin
        connect(input.output, :u, cartpole.motor.f)
    end
end
@named model = CartWithInput()
model = complete(model)
ssys = structural_simplify(multibody(model))
prob = ODEProblem(ssys, [model.cartpole.prismatic.s =&gt; 0.0, model.cartpole.revolute.phi =&gt; 0.1], (0, 10))
sol = solve(prob, Tsit5())
plot(sol, layout=4)</code></pre><img src="f6bae72b.svg" alt="Example block output"/><p>As usual, we render the simulation in 3D to get a better feel for the system:</p><pre><code class="language-julia hljs">import GLMakie
Multibody.render(model, sol, filename = &quot;cartpole.gif&quot;, traces=[model.cartpole.pendulum.frame_b])</code></pre><p><img src="../cartpole.gif" alt="cartpole"/></p><h3 id="Adding-feedback"><a class="docs-heading-anchor" href="#Adding-feedback">Adding feedback</a><a id="Adding-feedback-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-feedback" title="Permalink"></a></h3><p>We will attempt to stabilize the pendulum in the upright position by using feedback control. To design the controller, we linearize the model in the upward equilibrium position and design an infinite-horizon LQR controller using ControlSystems.jl. We then connect the controller to the motor on the cart. See also <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/cartpole/">RobustAndOptimalControl.jl: Control design for a pendulum on a cart</a> for a similar example with more detail on the control design.</p><h3 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h3><p>We start by linearizing the model in the upward equilibrium position using the function <code>ModelingToolkit.linearize</code>.</p><pre><code class="language-julia hljs">import ModelingToolkit: D_nounits as D
using LinearAlgebra
@named cp = Cartpole(use_world = true)
cp = complete(cp)
inputs = [cp.u] # Input to the linearized system
outputs = [cp.x, cp.phi, cp.v, cp.w] # These are the outputs of the linearized system
op = Dict([ # Operating point to linearize in
    cp.u =&gt; 0
    cp.revolute.phi =&gt; 0 # Pendulum pointing upwards
]
)
matrices, simplified_sys = linearize(multibody(cp), inputs, outputs; op)
matrices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [0.0 0.0 0.0 1.0; 0.0 0.0 1.0 0.0; 4.474102070258828 0.0 0.0 0.0; 39.683507165892394 0.0 0.0 0.0], B = [0.0; 0.0; 0.8415814526118872; 2.3385955754360115;;], C = [0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0], D = [0.0; 0.0; 0.0; 0.0;;])</code></pre><p>This gives us the matrices <span>$A,B,C,D$</span> in a linearized statespace representation of the system. To make these easier to work with, we load the control packages and call <code>named_ss</code> instead of <code>linearize</code> to get a named statespace object instead:</p><pre><code class="language-julia hljs">using ControlSystemsMTK
lsys = named_ss(multibody(cp), inputs, outputs; op) # identical to linearize, but packages the resulting matrices in a named statespace object for convenience</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cp: NamedControlSystemsBase.StateSpace{ControlSystemsBase.Continuous, Float64}
A = 
  0.0                0.0  0.0  1.0
  0.0                0.0  1.0  0.0
  4.474102070258828  0.0  0.0  0.0
 39.683507165892394  0.0  0.0  0.0
B = 
 0.0
 0.0
 0.8415814526118872
 2.3385955754360115
C = 
 0.0  1.0  0.0  0.0
 1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0
D = 
 0.0
 0.0
 0.0
 0.0

Continuous-time state-space model
With state  names: revolute₊phi prismatic₊s prismatic₊v revolute₊w
     input  names: u(t)
     output names: x(t) phi(t) v(t) w(t)
</code></pre><h3 id="LQR-Control-design"><a class="docs-heading-anchor" href="#LQR-Control-design">LQR Control design</a><a id="LQR-Control-design-1"></a><a class="docs-heading-anchor-permalink" href="#LQR-Control-design" title="Permalink"></a></h3><p>With a linear statespace object in hand, we can proceed to design an LQR or LQG controller. We will design both an LQR and an LQG controller in order to demonstrate two possible workflows.</p><p>The LQR contorller is designed using the function <code>ControlSystemsBase.lqr</code>, and it takes the two cost matrices <code>Q1</code> and <code>Q2</code> penalizing state deviation and control action respectively. The LQG controller is designed using <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#LQG-design"><code>RobustAndOptimalControl.LQGProblem</code></a>, and this function additionally takes the covariance matrices <code>r1, R2</code> for a Kalman filter. Before we call <code>LQGProblem</code> we partition the linearized system into an <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/api/#RobustAndOptimalControl.ExtendedStateSpace"><code>ExtendedStateSpace</code></a> object using the <a href="@https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/api/#RobustAndOptimalControl.partition-Tuple{AbstractStateSpace}"><code>partition</code></a> function, this indicates what inputs of the system are available for control and what are considered disturbances, and what outputs of the system are available for measurement. In this case, we assume that we have access to the cart position and the pendulum angle, and we control the cart position. The remaining two outputs are still important for the performance, but we cannot measure them and will rely on the Kalman filter to estimate them. When we call <a href="https://juliacontrol.github.io/ControlSystems.jl/dev/lib/analysis/#ControlSystemsBase.observer_controller-Tuple{Any,%20AbstractMatrix,%20AbstractMatrix}"><code>observer_controller</code></a> we get a linear system that represents the combined state estimator and state feedback controller. This linear system is then converted to an <code>ODESystem</code> by the function <code>LQGSystem</code>.</p><p>Since the function <code>lqr</code> operates on the state vector, and we have access to the specified output vector, we make use of the system <span>$C$</span> matrix to reformulate the problem in terms of the outputs. This relies on the <span>$C$</span> matrix being full rank, which is the case here since our outputs include a complete state realization of the system. This is of no concern when using the <code>LQGProblem</code> structure since we penalize outputs rather than the state in this case. </p><p>To make the simulation interesting, we make a change in the reference position of the cart after a few seconds. </p><pre><code class="language-julia hljs">using ControlSystemsBase, RobustAndOptimalControl
C = lsys.C
Q1 = Diagonal([10, 10, 10, 1])
Q2 = Diagonal([0.1])

R1 = Diagonal([1])
R2 = Diagonal([0.01, 0.01])

lqg = LQGProblem(partition(lsys, u = [:u], y = [:x, :phi]), Q1, Q2, R1, R2)
Lmat = lqr(lsys, C&#39;Q1*C, Q2)/C # Alternatively, compute LQR feedback gain. The multiplication by the C matrix is to handle the difference between state and output

LQGSystem(args...; kwargs...) = ODESystem(observer_controller(lqg); kwargs...)

@mtkmodel CartWithFeedback begin
    @components begin
        world = World()
        cartpole = Cartpole()
        reference = Blocks.Step(start_time = 5, height=0.5)
        control_saturation = Blocks.Limiter(y_max = 10) # To limit the control signal magnitude
        # controller = Blocks.MatrixGain(K = Lmat) # uncomment to use LQR controller instead
        controller = LQGSystem()
    end
    begin
        namespaced_outputs = ModelingToolkit.renamespace.(:cartpole, outputs) # Give outputs correct namespace, they are variables in the cartpole system
    end
    @equations begin
        controller.input.u[1] ~ reference.output.u - namespaced_outputs[1] # reference cart position - cartpole.x
        controller.input.u[2] ~ 0 - namespaced_outputs[2] # cartpole.phi
        # controller.input.u[3] ~ 0 - namespaced_outputs[3] # cartpole.v # uncomment if using LQR controller instead
        # controller.input.u[4] ~ 0 - namespaced_outputs[4] # cartpole.w

        connect(controller.output, control_saturation.input)
        connect(control_saturation.output, cartpole.motor.f)
    end
end
@named model = CartWithFeedback()
model = complete(model)
ssys = structural_simplify(multibody(model))
prob = ODEProblem(ssys, [model.cartpole.prismatic.s =&gt; 0.1, model.cartpole.revolute.phi =&gt; 0.35], (0, 10))
sol = solve(prob, Tsit5())
cp = model.cartpole
plot(sol, idxs=[cp.prismatic.s, cp.revolute.phi, cp.motor.f.u], layout=3)
plot!(sol, idxs=model.reference.output.u, sp=1, l=(:black, :dash), legend=:bottomright)</code></pre><img src="4cf75ede.svg" alt="Example block output"/><pre><code class="language-julia hljs">Multibody.render(model, sol, filename = &quot;inverted_cartpole.gif&quot;, x=1, z=1)</code></pre><p><img src="../inverted_cartpole.gif" alt="inverted cartpole"/></p><h3 id="Swing-up"><a class="docs-heading-anchor" href="#Swing-up">Swing up</a><a id="Swing-up-1"></a><a class="docs-heading-anchor-permalink" href="#Swing-up" title="Permalink"></a></h3><p>Below, we add also an energy-based swing-up controller. For more details this kind of swing-up controller, see <a href="https://www.youtube.com/watch?v=RhF2NMCYoiw">Part 7: Control of rotary pendulum using Julia: Swing up control (YouTube)</a></p><pre><code class="language-julia hljs">&quot;Compute total energy, kinetic + potential, for a body rotating around the z-axis of the world&quot;
function energy(body, w)
    g = GlobalScope(world.g_inner)
    m = body.m
    d2 = body.r_cm[1]^2 + body.r_cm[2]^2 # Squared distance from
    I = body.I_33 + m*d2 # Parallel axis theorem
    r_cm_worldframe = Multibody.resolve1(ori(body.frame_a), body.r_cm)[2] # Rotate the distance from frame_a to the center of mass to the world frame
    1/2*I*w^2 + 2m*g*(body.frame_a.r_0[2] + r_cm_worldframe) # Assuming rotation around the z-axis
end

normalize_angle(x::Number) = mod(x+3.1415, 2pi)-3.1415

@mtkmodel CartWithSwingup begin
    @components begin
        world = World()
        cartpole = Cartpole()
        L = Blocks.MatrixGain(K = Lmat) # Here we use the LQR controller instead
        control_saturation = Blocks.Limiter(y_max = 12) # To limit the control signal magnitude
    end
    @variables begin
        phi(t)
        w(t)
        E(t), [description = &quot;Total energy of the pendulum&quot;]
        u_swing(t), [description = &quot;Swing-up control signal&quot;]
        switching_condition(t)::Bool, [description = &quot;Switching condition that indicates when stabilizing controller is active&quot;]
    end
    @parameters begin
        Er = 3.825676486352941 # Total energy of the cartpole at the top equilibrium position
    end
    begin
        namespaced_outputs = ModelingToolkit.renamespace.(:cartpole, outputs) # Give outputs correct namespace, they are variables in the cartpole system
    end
    @equations begin
        phi ~ normalize_angle(cartpole.phi)
        w ~ cartpole.w
        E ~ energy(cartpole.pendulum.body, w) + energy(cartpole.tip, w)
        u_swing ~ 100*(E - Er)*sign(w*cos(phi-3.1415))

        L.input.u[1] ~ 0 - namespaced_outputs[1] # - cartpole.x
        L.input.u[2] ~ 0 - phi # cartpole.phi but normalized
        L.input.u[3] ~ 0 - namespaced_outputs[3] # cartpole.v
        L.input.u[4] ~ 0 - namespaced_outputs[4] # cartpole.w
        switching_condition ~ abs(phi) &lt; 0.4
        control_saturation.input.u ~ ifelse(switching_condition, L.output.u, u_swing)
        connect(control_saturation.output, cartpole.motor.f)
    end
end
@named model = CartWithSwingup()
model = complete(model)
ssys = structural_simplify(multibody(model))
cp = model.cartpole
prob = ODEProblem(ssys, [cp.prismatic.s =&gt; 0.0, cp.revolute.phi =&gt; 0.99pi], (0, 5))
sol = solve(prob, Tsit5(), dt = 1e-2, adaptive=false)
plot(sol, idxs=[cp.prismatic.s, cp.revolute.phi, cp.motor.f.u, model.E], layout=4)
hline!([0, 2pi], sp=2, l=(:black, :dash), primary=false)
plot!(sol, idxs=[model.switching_condition], sp=2)</code></pre><img src="def9420a.svg" alt="Example block output"/><pre><code class="language-julia hljs">Multibody.render(model, sol, filename = &quot;swingup.gif&quot;, x=2, z=2)</code></pre><p><img src="../swingup.gif" alt="inverted cartpole"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../spring_damper_system/">Spring-damper system »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 7 October 2024 18:29">Monday 7 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
