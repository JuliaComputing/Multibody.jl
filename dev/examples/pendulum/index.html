<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started: Pendulum · Multibody.jl</title><meta name="title" content="Getting started: Pendulum · Multibody.jl"/><meta property="og:title" content="Getting started: Pendulum · Multibody.jl"/><meta property="twitter:title" content="Getting started: Pendulum · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting started: Pendulum</a><ul class="internal"><li><a class="tocitem" href="#Modeling-the-pendulum"><span>Modeling the pendulum</span></a></li><li><a class="tocitem" href="#Adding-damping"><span>Adding damping</span></a></li><li><a class="tocitem" href="#A-linear-pendulum?"><span>A linear pendulum?</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="../spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="../three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="../sensors/">Sensors</a></li><li><a class="tocitem" href="../spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="../gearbox/">Gearbox</a></li><li><a class="tocitem" href="../free_motion/">Free motions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting started: Pendulum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started: Pendulum</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;"><a class="docs-heading-anchor" href="#Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;">Pendulum–The &quot;Hello World of multi-body dynamics&quot;</a><a id="Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Pendulum–The-&quot;Hello-World-of-multi-body-dynamics&quot;" title="Permalink"></a></h1><p>This beginners tutorial will model a pendulum pivoted around the origin in the world frame. The world frame is a constant that lives inside the Multibody module, all multibody models are &quot;grounded&quot; in the same world.</p><p><img src="https://doc.modelica.org/Modelica%203.2.3/Resources/Images/Mechanics/MultiBody/Examples/Elementary/Pendulum.png" alt="Pendulum"/></p><p>To start, we load the required packages</p><pre><code class="language-julia hljs">using ModelingToolkit
using Multibody, JuliaSimCompiler
using OrdinaryDiffEq # Contains the ODE solver we will use
using Plots</code></pre><p>We then access the world frame and time variable from the Multibody module</p><pre><code class="language-julia hljs">t = Multibody.t
world = Multibody.world
show(stdout, MIME&quot;text/plain&quot;(), world)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model world with 12 (18) equations
States (9):
  (frame_b₊r_0(t))[1] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊r_0(t))[2] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊r_0(t))[3] [defaults to 0.0]: Position vector directed from the origin of the world frame to the connector frame origin, resolved in world frame
  (frame_b₊f(t))[1] [defaults to 0.0]: Cut force resolved in connector frame
  (frame_b₊f(t))[2] [defaults to 0.0]: Cut force resolved in connector frame
  (frame_b₊f(t))[3] [defaults to 0.0]: Cut force resolved in connector frame
  (frame_b₊tau(t))[1] [defaults to 0.0]: Cut torque resolved in connector frame
  (frame_b₊tau(t))[2] [defaults to 0.0]: Cut torque resolved in connector frame
  (frame_b₊tau(t))[3] [defaults to 0.0]: Cut torque resolved in connector frame
Parameters (4):
  n[1] [defaults to 0]: gravity direction of world
  n[2] [defaults to -1]: gravity direction of world
  n[3] [defaults to 0]: gravity direction of world
  g [defaults to 9.81]: gravitational acceleration of world</code></pre><p>Unless otherwise specified, the world defaults to have a gravitational field pointing in the negative <span>$y$</span> direction and an graivational acceleration of <span>$9.81$</span>.</p><h2 id="Modeling-the-pendulum"><a class="docs-heading-anchor" href="#Modeling-the-pendulum">Modeling the pendulum</a><a id="Modeling-the-pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-the-pendulum" title="Permalink"></a></h2><p>Our simple pendulum will initially consist of a <a href="../../#Multibody.Body-Tuple{}"><code>Body</code></a> and a <a href="../../#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint (the pivot joint). We construct these elements by calling their constructors</p><pre><code class="language-julia hljs">@named joint = Revolute(n = [0, 0, 1], isroot = true)
@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: frame_a contains 6 flow variables, yet 3 regular (non-flow, non-stream, non-input, non-output) variables. This could lead to imbalanced model that are difficult to debug. Consider marking some of the regular variables as input/output variables.
└ @ ModelingToolkit /home/github_actions/depots/deepsea1.0/packages/ModelingToolkit/oIgbi/src/systems/connectors.jl:51
┌ Warning: frame_b contains 6 flow variables, yet 3 regular (non-flow, non-stream, non-input, non-output) variables. This could lead to imbalanced model that are difficult to debug. Consider marking some of the regular variables as input/output variables.
└ @ ModelingToolkit /home/github_actions/depots/deepsea1.0/packages/ModelingToolkit/oIgbi/src/systems/connectors.jl:51
┌ Warning: frame_a contains 6 flow variables, yet 3 regular (non-flow, non-stream, non-input, non-output) variables. This could lead to imbalanced model that are difficult to debug. Consider marking some of the regular variables as input/output variables.
└ @ ModelingToolkit /home/github_actions/depots/deepsea1.0/packages/ModelingToolkit/oIgbi/src/systems/connectors.jl:51</code></pre><p>The <code>n</code> argument to <a href="../../#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> denotes the rotational axis of the joint, this vector must have <code>norm(n) == 1</code>. We also indicate that the revolute joint is the root of the kinematic tree, i.e., the potential state of the joint will serve as the state variables for the system.</p><p>The <a href="../../#Multibody.Body-Tuple{}"><code>Body</code></a> is constructed by providing its mass, <code>m</code>, and the vector <code>r_cm</code> from its first frame, <code>body.frame_a</code>, to the center of mass. Since the world by default has the gravity field pointing along the negative <span>$y$</span> axis, we place the center of mass along the <span>$x$</span>-axis to make the pendulum swing back and forth. The body is not selected as the root of the kinematic tree, since we have a joint in this system, but if we had attached the body directly to, e.g., a spring, we could set the body to be the root and avoid having to introduce an &quot;artificial joint&quot;.</p><p>To connect the components together, we create a vector of connections using the <code>connect</code> function. A joint typically has two frames, <code>frame_a</code> and <code>frame_b</code>. The first frame of the joint is attached to the world frame, and the body is attached to the second joint frame. The order of the connections is not important for ModelingToolkit, but it&#39;s good practice to follow some convention, here, we start at the world and progress outwards in the kinematic tree.</p><pre><code class="language-julia hljs">connections = [
    connect(world.frame_b, joint.frame_a)
    connect(joint.frame_b, body.frame_a)
]</code></pre><p>With all components and connections defined, we can create an <code>ODESystem</code> like so:</p><pre><code class="language-julia hljs">@named model = ODESystem(connections, t, systems=[world, joint, body])</code></pre><p>The <code>ODESystem</code> is the fundamental model type in ModelingToolkit used for multibody-type models.</p><p>Before we can simulate the system, we must perform model compilation using <a href="@ref"><code>structural_simplify</code></a></p><pre><code class="language-julia hljs">ssys = structural_simplify(model, allow_parameter = false)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} joint_{+}phi\left( t \right)}{\mathrm{d}t} =&amp; joint_{+}w\left( t \right) \\
\frac{\mathrm{d} joint_{+}w\left( t \right)}{\mathrm{d}t} =&amp; joint_{+}phiˍtt\left( t \right) \\
0 =&amp;  - joint_{+}tau\left( t \right) - joint_{+}frame_{b_{+}tau(t)_1} joint_{+}n_1 - joint_{+}frame_{b_{+}tau(t)_2} joint_{+}n_2 - joint_{+}frame_{b_{+}tau(t)_3} joint_{+}n_3
\end{align}
 \]</p><p>This results in a simplified model with the minimum required variables and equations to be able to simulate the system efficiently. This step rewrites all <code>connect</code> statements into the appropriate equations, and removes any redundant variables and equations.</p><p>We are now ready to create an <code>ODEProblem</code> and simulate it. We use the <code>Rodas4</code> solver from OrdinaryDiffEq.jl, and pass a dictionary for the initial conditions. We specify only initial condition for some variables, for those variables where no initial condition is specified, the default initial condition defined the model will be used.</p><pre><code class="language-julia hljs">D = Differential(t)
defs = Dict(D(joint.phi) =&gt; 0, D(D(joint.phi)) =&gt; 0)
prob = ODEProblem(ssys, defs, (0, 10))

sol = solve(prob, Rodas4())
plot(sol, idxs = joint.phi, title=&quot;Pendulum&quot;)</code></pre><img src="20b72a72.svg" alt="Example block output"/><p>The solution <code>sol</code> can be plotted directly if the Plots package is loaded. The figure indicates that the pendulum swings back and forth without any damping. To add damping as well, we could add a <code>Damper</code> from the <code>ModelingToolkitStandardLibrary.Mechanical.Rotational</code> module to the revolute joint. We do this below</p><h2 id="Adding-damping"><a class="docs-heading-anchor" href="#Adding-damping">Adding damping</a><a id="Adding-damping-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-damping" title="Permalink"></a></h2><p>To add damping to the pendulum such that the pendulum will eventually come to rest, we add a <a href="../../#Multibody.Damper-Tuple{}"><code>Damper</code></a> to the revolute joint. The damping coefficient is given by <code>d</code>, and the damping force is proportional to the angular velocity of the joint. To add the damper to the revolute joint, we must create the joint with the keyword argument <code>useAxisFlange = true</code>, this adds two internal flanges to the joint to which you can attach components from the <code>ModelingToolkitStandardLibrary.Mechanical.Rotational</code> module. We then connect one of the flanges of the damper to the axis flange of the joint, and the other damper flange to the support flange which is rigidly attached to the world.</p><pre><code class="language-julia hljs">@named damper = Rotational.Damper(d = 0.1)
@named joint = Revolute(n = [0, 0, 1], isroot = true, useAxisFlange = true)

connections = [connect(world.frame_b, joint.frame_a)
               connect(damper.flange_b, joint.axis)
               connect(joint.support, damper.flange_a)
               connect(body.frame_a, joint.frame_b)]

@named model = ODESystem(connections, t, systems = [world, joint, body, damper])
ssys = structural_simplify(model, allow_parameter = false)

prob = ODEProblem(ssys, [damper.phi_rel =&gt; 1, D(joint.phi) =&gt; 0, D(D(joint.phi)) =&gt; 0],
                  (0, 30))

sol = solve(prob, Rodas4())
plot(sol, idxs = joint.phi, title=&quot;Damped pendulum&quot;)</code></pre><img src="44d10439.svg" alt="Example block output"/><p>This time we see that the pendulum loses energy and eventually comes to rest at the stable equilibrium point <span>$\pi / 2$</span>.</p><h2 id="A-linear-pendulum?"><a class="docs-heading-anchor" href="#A-linear-pendulum?">A linear pendulum?</a><a id="A-linear-pendulum?-1"></a><a class="docs-heading-anchor-permalink" href="#A-linear-pendulum?" title="Permalink"></a></h2><p>When we think of a pendulum, we typically think of a rotary pendulum that is rotating around a pivot point like in the examples above.  A mass suspended in a spring can be though of as a linear pendulum (often referred to as a harmonic oscillator rather than a pendulum), and we show here how we can construct a model of such a device. This time around, we make use of a <a href="../../#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint rather than a <a href="../../#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint. A <a href="https://en.wikipedia.org/wiki/Prismatic_joint">prismatic joint</a> has one positional degree of freedom, compared to the single rotational degree of freedom for the revolute joint.</p><p><img src="https://doc.modelica.org/Modelica%203.2.3/Resources/Images/Mechanics/MultiBody/Examples/Elementary/SpringWithMass.png" alt="Spring with mass"/></p><pre><code class="language- hljs">@named damper = Translational.Damper(d=0.5)
@named spring = Translational.Spring(c=1)
@named joint = Prismatic(n = [0, 1, 0], isroot = true, useAxisFlange = true)

connections = [connect(world.frame_b, joint.frame_a)
               connect(damper.flange_b, spring.flange_b, joint.axis)
               connect(joint.support, damper.flange_a, spring.flange_a)
               connect(body.frame_a, joint.frame_b)]

@named model = ODESystem(connections, t, systems = [world, joint, body, damper, spring])
ssys = structural_simplify(IRSystem(model))

prob = ODEProblem(ssys, [damper.s_rel =&gt; 1], (0, 30))

sol = solve(prob, Rodas4())
plot(sol, idxs = joint.s, title=&quot;Mass-spring-damper system&quot;)</code></pre><p>As is hopefully evident from the little code snippet above, this linear pendulum model has a lot in common with the rotary pendulum. In this example, we connected both the spring and a damper to the same axis flange in the joint. This time, the components came from the <code>Translational</code> submodule of ModelingToolkitStandardLibrary rather than the <code>Rotational</code> submodule. Also here do we pass <code>useAxisFlange</code> when we create the joint to make sure that it is equipped with the flanges <code>support</code> and <code>axis</code> needed to connect the translational components.</p><h3 id="Why-do-we-need-a-joint?"><a class="docs-heading-anchor" href="#Why-do-we-need-a-joint?">Why do we need a joint?</a><a id="Why-do-we-need-a-joint?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-we-need-a-joint?" title="Permalink"></a></h3><p>In the example above, we introduced a prismatic joint to model the oscillating motion of the mass-spring system. In reality, we can suspend a mass in a spring without any joint, so why do we need one here? The answer is that we do not, in fact, need the joint, but if we connect the spring directly to the world, we need to make the body (mass) the root object of the kinematic tree instead:</p><pre><code class="language- hljs">@named root_body = Body(; m = 1, isroot = true, r_cm = [0, 1, 0], phi0 = [0, 1, 0])
@named multibody_spring = Multibody.Spring(c=1)

connections = [connect(world.frame_b, multibody_spring.frame_a)
                connect(root_body.frame_a, multibody_spring.frame_b)]

@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body])
ssys = structural_simplify(IRSystem(model))

defs = Dict(collect(multibody_spring.r_rel_0 .=&gt; [0, 1, 0])...,
            collect(root_body.r_0 .=&gt; [0, 0, 0])...,
            collect((D.(root_body.phi)) .=&gt; [0, 0, 0])...,
            collect(D.(D.(root_body.phi)) .=&gt; [0, 0, 0])...)

prob = ODEProblem(ssys, defs, (0, 30))

sol = solve(prob, Rodas4())
plot(sol, idxs = multibody_spring.r_rel_0[2], title=&quot;Mass-spring system without joint&quot;)</code></pre><p>Here, we used a <a href="../../#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> instead of connecting a <code>Translational.Spring</code> to a joint. The <code>Translational.Spring</code>, alongside other components from <code>ModelingToolkitStandardLibrary.Mechanical</code>, is a 1-dimensional object, whereas multibody components are 3-dimensional objects.</p><p>Internally, the <a href="../../#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> contains a <code>Translational.Spring</code>, attached between two flanges, so we could actually add a damper to the system as well:</p><pre><code class="language- hljs">push!(connections, connect(multibody_spring.spring2d.flange_a, damper.flange_a))
push!(connections, connect(multibody_spring.spring2d.flange_b, damper.flange_b))

@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body, damper])
ssys = structural_simplify(IRSystem(model))
prob = ODEProblem(ssys, defs, (0, 30))

sol = solve(prob, Rodas4())
plot(sol, idxs = multibody_spring.r_rel_0[2], title=&quot;Mass-spring-damper without joint&quot;)</code></pre><p>The figure above should look identical to the simulation of the mass-spring-damper further above.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../spring_damper_system/">Spring-damper system »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 27 October 2023 14:12">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
