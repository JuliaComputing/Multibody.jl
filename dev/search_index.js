var documenterSearchIndex = {"docs":
[{"location":"examples/robot/#Industrial-robot","page":"Industrial robot","title":"Industrial robot","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"(Image: animation)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\nusing Test\n\nt = Multibody.t\nD = Differential(t)\n@named robot = Multibody.Robot6DOF(trivial=true)\nrobot = complete(robot)\n\nlength(equations(robot))","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"The robot is a medium sized system with some 2000 equations before simplification.","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"After simplification, the following states are chosen:","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"ssys = structural_simplify(IRSystem(robot))\nstates(ssys)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"prob = ODEProblem(ssys, [\n    robot.mechanics.r1.phi => deg2rad(-60)\n    robot.mechanics.r2.phi => deg2rad(20)\n    robot.mechanics.r3.phi => deg2rad(90)\n    robot.mechanics.r4.phi => deg2rad(0)\n    robot.mechanics.r5.phi => deg2rad(-110)\n    robot.mechanics.r6.phi => deg2rad(0)\n], (0.0, 4.0))\nsol = solve(prob, Rodas5P(autodiff=false));\n@test SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [\n    robot.pathPlanning.controlBus.axisControlBus1.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus2.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus3.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus4.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus5.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus6.angle_ref\n], layout=(4,3), size=(800,800), l=(:black, :dash), legend=:outertop, legendfontsize=6)\nplot!(sol, idxs = [\n    robot.pathPlanning.controlBus.axisControlBus1.angle\n    robot.pathPlanning.controlBus.axisControlBus2.angle\n    robot.pathPlanning.controlBus.axisControlBus3.angle\n    robot.pathPlanning.controlBus.axisControlBus4.angle\n    robot.pathPlanning.controlBus.axisControlBus5.angle\n    robot.pathPlanning.controlBus.axisControlBus6.angle\n], sp=1:6)\n\nplot!(sol, idxs = [\n    robot.axis1.controller.feedback1.output.u\n    robot.axis2.controller.feedback1.output.u\n    robot.axis3.controller.feedback1.output.u\n    robot.axis4.controller.feedback1.output.u\n    robot.axis5.controller.feedback1.output.u\n    robot.axis6.controller.feedback1.output.u\n], sp=7:12, lab=\"Position error\", link=:x)\nplot!(xlabel=[fill(\"\", 1, 9) fill(\"Time [s]\", 1, 3)])","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"We see that after an initial transient, the robot controller converges to tracking the reference trajectory well.","category":"page"},{"location":"examples/robot/#D-animation","page":"Industrial robot","title":"3D animation","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"import CairoMakie\nMultibody.render(robot, sol; z = -5, filename = \"robot.gif\")\nnothing # hide","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"(Image: animation)","category":"page"},{"location":"examples/spherical_pendulum/#Spherical-pendulum","page":"Spherical pendulum","title":"Spherical pendulum","text":"","category":"section"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"This example models a spherical pendulum. The pivot point is modeled using a Spherical joint, the pendulum rod is modeled using a FixedTranslation and the mass is modeled using a Body. In this example, we choose the joint to be the root (joints are often better root objects than bodies).","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    joint = Spherical(enforceState=true, isroot=true, phi = 1)\n    bar = FixedTranslation(r = [0, -1, 0])\n    body = Body(; m = 1, isroot = false)\nend\n\nconnections = [connect(world.frame_b, joint.frame_a)\n            connect(joint.frame_b, bar.frame_a)\n            connect(bar.frame_b, body.frame_a)]\n\n@named model = ODESystem(connections, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [\n                    D.(joint.phi) .=> 0;\n                    D.(D.(joint.phi)) .=> 0;\n], (0, 10))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [body.r_0...])","category":"page"},{"location":"examples/spherical_pendulum/#D-animation","page":"Spherical pendulum","title":"3D animation","text":"","category":"section"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"import CairoMakie\nMultibody.render(model, sol; z = -5, filename = \"spherical.gif\") # Use \"spherical.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/spring_mass_system/#Spring-mass-system","page":"Spring-mass system","title":"Spring-mass system","text":"","category":"section"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"(Image: animation)","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"This example mirrors that of the modelica spring-mass system and demonstrates that we can model a spring-mass system in two different ways.","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"Using a prismatic joint and a 1-dimensional spring from the Translational submodule attached to the joint. The advantage of this approach is that the many elements from the Translational library can be easily used here and that this implementation is usually more efficient compared to when using 3-dimensional springs.\nUsing a 3-dimensional spring from the Multibody library.","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"(Image: Spring-mass system)","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing ModelingToolkitStandardLibrary.Mechanical.TranslationalModelica\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    p1      = Prismatic(n = [0, -1, 0], s0 = 0.1, useAxisFlange = true)\n    spring1 = TranslationalModelica.Spring(c=30, s_rel0 = 0.1)\n    spring2 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    body1   = Body(m = 1, r_cm = [0, 0, 0])\n    bar1    = FixedTranslation(r = [0.3, 0, 0])\n    bar2    = FixedTranslation(r = [0.3, 0, 0])\n    body2   = Body(m = 1, r_cm = [0, 0, 0])\n    p2      = Prismatic(n = [0, -1, 0], s0 = 0.1, useAxisFlange = true)\nend\n\neqs = [\n    connect(body1.frame_a, p1.frame_b)\n    connect(world.frame_b, bar1.frame_a)\n    connect(bar1.frame_b, p1.frame_a)\n    connect(spring1.flange_b, p1.axis)\n    connect(bar1.frame_b, bar2.frame_a)\n    connect(bar2.frame_b, p2.frame_a)\n    connect(p2.frame_b, body2.frame_a)\n    connect(bar2.frame_b, spring2.frame_a)\n    connect(body2.frame_a, spring2.frame_b)\n    connect(spring1.flange_a, p1.support)\n]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys,[\n                    D(p1.s) => 0,\n                    D(D(p1.s)) => 0,\n                    D(p2.s) => 0,\n                    D(D(p2.s)) => 0,\n                  ], (0, 10))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(sol, idxs = [body1.r_0[2], body2.r_0[2]])","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"The plot indicates that the two systems behave identically. ","category":"page"},{"location":"examples/spring_mass_system/#D-animation","page":"Spring-mass system","title":"3D animation","text":"","category":"section"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"import CairoMakie\nMultibody.render(model, sol; z = -5, filename = \"springmass.gif\")\nnothing # hide","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"(Image: animation)","category":"page"},{"location":"examples/three_springs/#Three-springs","page":"Three springs (series forces)","title":"Three springs","text":"","category":"section"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"(Image: animation)","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"This example mirrors that of the modelica three-springs and demonstrates that we can connect mass-less force elements together.","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"(Image: three springs)","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"The example connects three springs together in a single point. The springs are all massless and do normally not have any state variables, but we can insist on one of the springs being stateful, in this case, we must tell the lower spring component to act as root by setting fixedRotationAtFrame_a = fixedRotationAtFrame_b = true.","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    body1 = Body(m = 0.8, I_11 = 0.1, I_22 = 0.1, I_33 = 0.1, r_0 = [0.5, -0.3, 0],\n                 r_cm = [0, -0.2, 0], isroot = false)\n    bar1 = FixedTranslation(r = [0.3, 0, 0])\n    bar2 = FixedTranslation(r = [0, 0, 0.3])\n    spring1 = Multibody.Spring(c = 20, m = 0, s_unstretched = 0.1,\n                               r_rel_0 = [-0.2, -0.2, 0.2])\n    spring2 = Multibody.Spring(c = 40, m = 0, s_unstretched = 0.1,\n                               fixedRotationAtFrame_a = true, fixedRotationAtFrame_b = true)\n    spring3 = Multibody.Spring(c = 20, m = 0, s_unstretched = 0.1)\nend\neqs = [connect(world.frame_b, bar1.frame_a)\n       connect(world.frame_b, bar2.frame_a)\n       connect(bar1.frame_b, spring1.frame_a)\n       connect(bar2.frame_b, spring3.frame_a)\n       connect(spring2.frame_b, body1.frame_a)\n       connect(spring3.frame_b, spring1.frame_b)\n       connect(spring2.frame_a, spring1.frame_b)]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [\n    D.(spring3.lineForce.r_rel_0) .=> 0;\n], (0, 10))\n\nsol = solve(prob, Rodas4(), u0=prob.u0 .+ 1e-1*randn(length(prob.u0)))\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(sol, idxs = [body1.r_0...])","category":"page"},{"location":"examples/three_springs/#D-animation","page":"Three springs (series forces)","title":"3D animation","text":"","category":"section"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"import CairoMakie\nMultibody.render(model, sol; z = -5, filename = \"three_springs.gif\") # Use \"three_springs.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"(Image: animation)","category":"page"},{"location":"examples/free_motion/#Free-motions","page":"Free motions","title":"Free motions","text":"","category":"section"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"This example demonstrates how a free-floating Body can be simulated. The body is attached to the world through a FreeMotion joint, i.e., a joint that imposes no constraints. The joint is required to add the appropriate relative state variables between the world and the body. We choose enforceState = true and isroot = true in the FreeMotion constructor.","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\n@named freeMotion = FreeMotion(enforceState = true, isroot = true)\n@named body = Body(m = 1)\n\neqs = [connect(world.frame_b, freeMotion.frame_a)\n       connect(freeMotion.frame_b, body.frame_a)]\n\n@named model = ODESystem(eqs, t,\n                         systems = [world;\n                                    freeMotion;\n                                    body])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [\n    D.(freeMotion.r_rel_a) .=> randn();\n    D.(D.(freeMotion.r_rel_a)) .=> randn();\n    D.(freeMotion.phi) .=> randn();\n    D.(D.(freeMotion.phi)) .=> randn();\n    D.(body.w_a) .=> randn();\n], (0, 10))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = body.r_0[2], title=\"Free falling body\")\n\n# Plot analytical solution\ntvec = 0:0.1:sol.t[end]\nplot!(tvec, -9.81/2 .* tvec .^ 2, lab=\"Analytical solution\")","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"The figure indicates that the body is falling freely, experiencing a constant acceleration of -9.81 m/s² in the y direction, corresponding to the gravity parameters of the world:","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"show(stdout, MIME\"text/plain\"(), world) # hide\nnothing # hide","category":"page"},{"location":"examples/pendulum/#Pendulum–The-\"Hello-World-of-multi-body-dynamics\"","page":"Getting started: Pendulum","title":"Pendulum–The \"Hello World of multi-body dynamics\"","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This beginners tutorial will model a pendulum pivoted around the origin in the world frame. The world frame is a constant that lives inside the Multibody module, all multibody models are \"grounded\" in the same world, i.e., the world component must be included in all models.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: Pendulum)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To start, we load the required packages","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using ModelingToolkit\nusing Multibody, JuliaSimCompiler\nusing OrdinaryDiffEq # Contains the ODE solver we will use\nusing Plots","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"We then access the world frame and time variable from the Multibody module","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"t = Multibody.t\nworld = Multibody.world\nshow(stdout, MIME\"text/plain\"(), world)\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Unless otherwise specified, the world defaults to have a gravitational field pointing in the negative y direction and a gravitational acceleration of 981.","category":"page"},{"location":"examples/pendulum/#Modeling-the-pendulum","page":"Getting started: Pendulum","title":"Modeling the pendulum","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Our simple pendulum will initially consist of a Body (point mass) and a Revolute joint (the pivot joint). We construct these elements by calling their constructors","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named joint = Revolute(n = [0, 0, 1], isroot = true)\n@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The n argument to Revolute denotes the rotational axis of the joint, this vector must have norm(n) == 1. We also indicate that the revolute joint is the root of the kinematic tree, i.e., the potential state of the joint will serve as the state variables for the system.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The Body is constructed by providing its mass, m, and the vector r_cm from its mounting frame, body.frame_a, to the center of mass. Since the world by default has the gravity field pointing along the negative y axis, we place the center of mass along the x-axis to make the pendulum swing back and forth. The body is not selected as the root of the kinematic tree, since we have a joint in this system, but if we had attached the body directly to, e.g., a spring, we could set the body to be the root and avoid having to introduce an \"artificial joint\", which is otherwise needed in order to have at least one component that has a potential state.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To connect the components together, we create a vector of connections using the connect function. A joint typically has two frames, frame_a and frame_b. In this example, the first frame of the joint is attached to the world frame, and the body is attached to the second frame of the joint, i.e., the joint allows the body to swing back and forth. The order of the connections is not important for ModelingToolkit, but it's good practice to follow some convention, here, we start at the world and progress outwards in the kinematic tree.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"connections = [\n    connect(world.frame_b, joint.frame_a)\n    connect(joint.frame_b, body.frame_a)\n]\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"With all components and connections defined, we can create an ODESystem like so:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named model = ODESystem(connections, t, systems=[world, joint, body])\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The ODESystem is the fundamental model type in ModelingToolkit used for multibody-type models.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Before we can simulate the system, we must perform model compilation using structural_simplify","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"ssys = structural_simplify(model, allow_parameter = false)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This results in a simplified model with the minimum required variables and equations to be able to simulate the system efficiently. This step rewrites all connect statements into the appropriate equations, and removes any redundant variables and equations.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"We are now ready to create an ODEProblem and simulate it. We use the Rodas4 solver from OrdinaryDiffEq.jl, and pass a dictionary for the initial conditions. We specify only initial condition for some variables, for those variables where no initial condition is specified, the default initial condition defined the model will be used.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"D = Differential(t)\ndefs = Dict(D(joint.phi) => 0, D(D(joint.phi)) => 0)\nprob = ODEProblem(ssys, defs, (0, 10))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = joint.phi, title=\"Pendulum\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The solution sol can be plotted directly if the Plots package is loaded. The figure indicates that the pendulum swings back and forth without any damping. To add damping as well, we could add a Damper from the ModelingToolkitStandardLibrary.Mechanical.Rotational module to the revolute joint. We do this below","category":"page"},{"location":"examples/pendulum/#D-Animation","page":"Getting started: Pendulum","title":"3D Animation","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"import CairoMakie # GLMakie is another alternative, suitable for interactive plots\nMultibody.render(model, sol; z = -5, filename = \"pendulum.gif\") # Use \"pendulum.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"By default, the world frame is indicated using the convention x: red, y: green, z: blue. The animation shows how the simple Body represents a point mass at a particular distance r_cm away from its mounting flange frame_a. To model a more physically motivated pendulum rod, we could have used a BodyShape component, which has two mounting flanges instead of one. The BodyShape component is shown in several of the examples available in the example sections of the documentation.","category":"page"},{"location":"examples/pendulum/#Adding-damping","page":"Getting started: Pendulum","title":"Adding damping","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To add damping to the pendulum such that the pendulum will eventually come to rest, we add a Damper to the revolute joint. The damping coefficient is given by d, and the damping force is proportional to the angular velocity of the joint. To add the damper to the revolute joint, we must create the joint with the keyword argument useAxisFlange = true, this adds two internal flanges to the joint to which you can attach components from the ModelingToolkitStandardLibrary.Mechanical.Rotational module (1-dimensional components). We then connect one of the flanges of the damper to the axis flange of the joint, and the other damper flange to the support flange which is rigidly attached to the world.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named damper = Rotational.Damper(d = 0.1)\n@named joint = Revolute(n = [0, 0, 1], isroot = true, useAxisFlange = true)\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(damper.flange_b, joint.axis)\n               connect(joint.support, damper.flange_a)\n               connect(body.frame_a, joint.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, joint, body, damper])\nssys = structural_simplify(model, allow_parameter = false)\n\nprob = ODEProblem(ssys, [damper.phi_rel => 1, D(joint.phi) => 0, D(D(joint.phi)) => 0],\n                  (0, 30))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = joint.phi, title=\"Damped pendulum\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This time we see that the pendulum loses energy and eventually comes to rest at the stable equilibrium point pi  2.","category":"page"},{"location":"examples/pendulum/#A-linear-pendulum?","page":"Getting started: Pendulum","title":"A linear pendulum?","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"When we think of a pendulum, we typically think of a rotary pendulum that is rotating around a pivot point like in the examples above.  A mass suspended in a spring can be though of as a linear pendulum (often referred to as a harmonic oscillator rather than a pendulum), and we show here how we can construct a model of such a device. This time around, we make use of a Prismatic joint rather than a Revolute joint. A prismatic joint has one positional degree of freedom, compared to the single rotational degree of freedom for the revolute joint.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: Spring with mass)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named damper = Translational.Damper(d=0.5)\n@named spring = Translational.Spring(c=1)\n@named joint = Prismatic(n = [0, 1, 0], isroot = true, useAxisFlange = true)\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(damper.flange_b, spring.flange_b, joint.axis)\n               connect(joint.support, damper.flange_a, spring.flange_a)\n               connect(body.frame_a, joint.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, joint, body, damper, spring])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [damper.s_rel => 1, D(D(joint.s)) => 0], (0, 30))\n\nsol = solve(prob, Rodas4())\nPlots.plot(sol, idxs = joint.s, title=\"Mass-spring-damper system\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"As is hopefully evident from the little code snippet above, this linear pendulum model has a lot in common with the rotary pendulum. In this example, we connected both the spring and a damper to the same axis flange in the joint. This time, the components came from the Translational submodule of ModelingToolkitStandardLibrary rather than the Rotational submodule. Also here do we pass useAxisFlange when we create the joint to make sure that it is equipped with the flanges support and axis needed to connect the translational components.","category":"page"},{"location":"examples/pendulum/#Why-do-we-need-a-joint?","page":"Getting started: Pendulum","title":"Why do we need a joint?","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"In the example above, we introduced a prismatic joint to model the oscillating motion of the mass-spring system. In reality, we can suspend a mass in a spring without any joint, so why do we need one here? The answer is that we do not, in fact, need the joint, but if we connect the spring directly to the world, we need to make the body (mass) the root object of the kinematic tree instead:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named root_body = Body(; m = 1, isroot = true, r_cm = [0, 1, 0], phi0 = [0, 1, 0], useQuaternions=false)\n@named multibody_spring = Multibody.Spring(c=1)\n\nconnections = [connect(world.frame_b, multibody_spring.frame_a)\n                connect(root_body.frame_a, multibody_spring.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body])\nssys = structural_simplify(IRSystem(model))\n\ndefs = Dict(collect(multibody_spring.r_rel_0 .=> [0, 1, 0])...,\n            collect(root_body.r_0 .=> [0, 0, 0])...,\n            collect((D.(root_body.phi)) .=> [0, 0, 0])...,\n            collect(D.(D.(root_body.phi)) .=> [0, 0, 0])...,\n            collect(D.(root_body.phid) .=> [0, 0, 0])...,\n)\n\nprob = ODEProblem(ssys, defs, (0, 30))\n\nsol = solve(prob, Rodas4(), u0 = prob.u0 .+ 1e-5 .* randn.())\nplot(sol, idxs = multibody_spring.r_rel_0[2], title=\"Mass-spring system without joint\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Here, we used a Multibody.Spring instead of connecting a Translational.Spring to a joint. The Translational.Spring, alongside other components from ModelingToolkitStandardLibrary.Mechanical, is a 1-dimensional object, whereas multibody components are 3-dimensional objects.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Internally, the Multibody.Spring contains a Translational.Spring, attached between two flanges, so we could actually add a damper to the system as well:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"push!(connections, connect(multibody_spring.spring2d.flange_a, damper.flange_a))\npush!(connections, connect(multibody_spring.spring2d.flange_b, damper.flange_b))\n\n@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body, damper])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, defs, (0, 30))\n\nsol = solve(prob, Rodas4(), u0 = prob.u0 .+ 1e-5 .* randn.())\nplot(sol, idxs = multibody_spring.r_rel_0[2], title=\"Mass-spring-damper without joint\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The figure above should look identical to the simulation of the mass-spring-damper further above.","category":"page"},{"location":"examples/pendulum/#Going-3D","page":"Getting started: Pendulum","title":"Going 3D","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The systems we have modeled so far have all been planar mechanisms. We now extend this to a 3-dimensional system, the Furuta pendulum.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This pendulum, sometimes referred to as a rotary pendulum, has two joints, one in the \"shoulder\", which is typically configured to rotate around the gravitational axis, and one in the \"elbow\", which is typically configured to rotate around the axis of the upper arm. The upper arm is attached to the shoulder joint, and the lower arm is attached to the elbow joint. The tip of the pendulum is attached to the lower arm.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using ModelingToolkit, Multibody, JuliaSimCompiler, OrdinaryDiffEq, Plots\nimport ModelingToolkitStandardLibrary.Mechanical.Rotational.Damper as RDamper\nimport Multibody.Rotations\nW(args...; kwargs...) = Multibody.world\n\n@mtkmodel FurutaPendulum begin\n    @components begin\n        world = W()\n        shoulder_joint = Revolute(n = [0, 1, 0], isroot = true, useAxisFlange = true)\n        elbow_joint    = Revolute(n = [0, 0, 1], isroot = true, useAxisFlange = true, phi0=0.1)\n        upper_arm = BodyShape(; m = 0.1, isroot = false, r = [0, 0, 0.6], radius=0.05)\n        lower_arm = BodyShape(; m = 0.1, isroot = false, r = [0, 0.6, 0], radius=0.05)\n        tip = Body(; m = 0.3, isroot = false)\n\n        damper1 = RDamper(d = 0.07)\n        damper2 = RDamper(d = 0.07)\n    end\n    @equations begin\n        connect(world.frame_b, shoulder_joint.frame_a)\n        connect(shoulder_joint.frame_b, upper_arm.frame_a)\n        connect(upper_arm.frame_b, elbow_joint.frame_a)\n        connect(elbow_joint.frame_b, lower_arm.frame_a)\n        connect(lower_arm.frame_b, tip.frame_a)\n\n        connect(shoulder_joint.axis, damper1.flange_a)\n        connect(shoulder_joint.support, damper1.flange_b)\n\n        connect(elbow_joint.axis, damper2.flange_a)\n        connect(elbow_joint.support, damper2.flange_b)\n\n    end\nend\n\n@named model = FurutaPendulum()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [model.shoulder_joint.phi => 0.0, model.elbow_joint.phi => 0.1], (0, 12))\nsol = solve(prob, Rodas4())\nplot(sol, layout=4)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"import CairoMakie\nMultibody.render(model, sol, z=-5, framerate=60, R = Rotations.RotXYZ(0.2, -0.2, 0), filename = \"furuta.gif\")\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: furuta)","category":"page"},{"location":"examples/pendulum/#Orientations-and-directions","page":"Getting started: Pendulum","title":"Orientations and directions","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Let's break down how to think about directions and orientations when building 3D mechanisms. In the example above, we started with the shoulder joint, this joint rotated around the gravitational axis, n = [0, 1, 0]. When this joint is positioned in joint coordinate shoulder_joint.phi = 0, its frame_a and frame_b will coincide. When the joint rotates, frame_b will rotate around the axis n of frame_a. The frame_a of the joint is attached to the world, so the joint will rotate around the world's y-axis:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"function get_R(frame, t)\n    reshape(sol(t, idxs=vec(ori(frame).R.mat')), 3, 3)\nend\nfunction get_r(frame, t)\n    sol(t, idxs=collect(frame.r_0))\nend\nget_R(model.shoulder_joint.frame_b)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"we see that at time t = 0, we have no rotation of frame_b around the y axis of the world (frames are always resolved in the world frame), but a second into the simulation, we do:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_R(model.shoulder_joint.frame_b, 1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The next body is the upper arm. This body has an extent of 0.6 in the z direction, as measured in its local frame_a","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_r(model.upper_arm.frame_b, 0)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"One second into the simulation, the upper arm has rotated around the y axis of the world","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_r(model.upper_arm.frame_b, 1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"If we look at the variable model.upper_arm.r, we do not see this rotation!","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"arm_r = sol(1, idxs=collect(model.upper_arm.r))","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The reason is that this variable is resolved in the local frame_a and not in the world frame. To transform this variable to the world frame, we may multiply with the rotation matrix of frame_a","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_R(model.upper_arm.frame_a, 1)*arm_r","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Slightly more formally, let R_A^B denote the rotation matrix that rotates a vector expressed in a frame A into one that is expressed in frame B, i.e., r_B = R_B^A r_A. We have then just performed the transformation r_W = R_W^A r_A, where W denotes the world frame, and A denotes body.frame_a.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The next joint, the elbow joint, has the rotational axis n = [0, 0, 1]. This indicates that the joint rotates around the z-axis of its frame_a. Since the upper arm was oriented along the z direction, the joint is rotating around the axis that coincides with the upper arm. ","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The lower arm is finally having an extent in the y-axis. At the final time when the pendulum motion has been full damped, we see that the second frame of this body ends up with an y-coordinate of -0.6:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_r(model.lower_arm.frame_b, 12)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"If we rotate the vector of extent of the lower arm to the world frame, we indeed see that the only coordinate that is nonzero is the y coordinate:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_R(model.lower_arm.frame_a, 12)*sol(12, idxs=collect(model.lower_arm.r))","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The reason that the latter vector differs from get_r(model.lower_arm.frame_b, 12) above is that get_r(model.lower_arm.frame_b, 12) has been translated as well. To both translate and rotate model.lower_arm.r into the world frame, we must use the full transformation matrix T_W_A in SE(3):","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"function get_T(frame, t)\n    R = get_R(frame, t)\n    r = get_r(frame, t)\n    [R r; 0 0 0 1]\nend\n\nr_A = sol(12, idxs=collect(model.lower_arm.r))\nr_A = [r_A; 1] # Homogeneous coordinates\n\nget_T(model.lower_arm.frame_a, 12)*r_A","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"the vector is now coinciding with get_r(model.lower_arm.frame_b, 12).","category":"page"},{"location":"rendering/#D-rendering-and-animations","page":"3D rendering","title":"3D rendering and animations","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"Multibody.jl has an automatic 3D-rendering feature that draws a mechanism in 3D. This can be used to create animations of the mechanism's motion from a solution trajectory, as well as to create interactive applications where the evolution of time can be controlled by the user.","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"The functionality requires the user to load any of the Makie frontend packages, e.g., ","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"using GLMakie","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"or ","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"using CairoMakie","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"After that, the render function is the main entry point to create 3D renderings. This function has the following methods:","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"render(model, solution): this method creates an animation corresponding to the mechanisms evolution in a simulation trajectory.\nrender(model, solution, t::Real): this method opens an interactive window with the mechanism in the configuration corresponding to the time t.","category":"page"},{"location":"rendering/#Rendering-API","page":"3D rendering","title":"Rendering API","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"render\nrender!","category":"page"},{"location":"rendering/#Multibody.render","page":"3D rendering","title":"Multibody.render","text":"scene, time = render(model, sol, t::Real; framerate = 30)\npath        = render(model, sol, timevec = range(sol.t[1], sol.t[end], step = 1 / framerate); framerate = 30)\n\nCreate a 3D animation of a multibody system\n\nArguments:\n\nmodel: The unsimplified multibody model\nsol: The ODESolution produced by simulating the system using solve\nt: If a single number t is provided, the mechanism at this time is rendered and a scene is returned together with the time as an Observable. Modify time[] = new_time to change the rendering.\ntimevec: If a vector of times is provided, an animation is created and the path to the file on disk is returned.\nframerate: Number of frames per second.\n\n\n\n\n\n","category":"function"},{"location":"rendering/#Multibody.render!","page":"3D rendering","title":"Multibody.render!","text":"did_render::Bool = render!(scene, ::typeof(ComponentConstructor), sys, sol, t)\n\nEach component that can be rendered must have a render! method. This method is called by render for each component in the system.\n\nThis method is responsible for drawing the component onto the scene the way it's supposed to look at time t in the solution sol. t is an Observable. It's recommended to follow the pattern\n\nthing = @lift begin\n    acces relevant coordinates from sol at time t\n    create a geometric object that can be rendered\nend\nmesh!(scene, thing; style...)\n\nReturns\n\nA boolean indicating whether or not the component performed any rendering. Typically, all custom methods of this function should return true, while the default fallback method is the only one returning false.\n\n\n\n\n\n","category":"function"},{"location":"examples/sensors/#Using-a-sensor","page":"Sensors","title":"Using a sensor","text":"","category":"section"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Multibody models are composed out of multibody components, typically by connecting Frames together. To add, e.g., a control system to a multibody model, we often make use of sensors that, just like in the real world, translate between a physical quantity in 3D and a signal in the \"signal domain\". The signal domain consists of the various blocks defined in ModelingToolkitStandardLibrary.Blocks, and a sensor is simply a component that has two connectors, one Frame connector for attaching to the multibody model, and one Blocks.RealOutput for connecting to the signal domain.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"The example below adds a force and a torque sensor to the pivot point of a pendulum. Note how the two sensors are connected in series with each other, just like how we would typically connect them in practice if they are not integrated into the same component.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing OrdinaryDiffEq\nusing LinearAlgebra\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\n@named joint = Multibody.Revolute(n = [0, 0, 1], isroot = true)\n@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])\n@named torquesensor = CutTorque()\n@named forcesensor = CutForce()\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(joint.frame_b, body.frame_a, torquesensor.frame_a,\n                       forcesensor.frame_a)]\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(joint.frame_b, torquesensor.frame_a)\n               connect(torquesensor.frame_b, forcesensor.frame_a)\n               connect(forcesensor.frame_b, body.frame_a)]\n\n@named model = ODESystem(connections, t,\n                         systems = [world, joint, body, torquesensor, forcesensor])\nmodele = ModelingToolkit.expand_connections(model)\nssys = structural_simplify(model, allow_parameter = false)\n\n\nD = Differential(t)\ndefs = Dict(collect((D.(joint.phi)) .=> [0, 0, 0])...,\n            collect(D.(D.(joint.phi)) .=> [0, 0, 0])...)\nprob = ODEProblem(ssys, defs, (0, 10))\n\nusing OrdinaryDiffEq\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [collect(forcesensor.force.u); collect(joint.frame_a.f)])","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Note how the force sensor measures a force that appears to equal the cut-force in the joint in magnitude, but the orientation appears to differ. Frame cut forces and toques are resolved in the world frame by default, while the force sensor measures the force in the frame of the sensor. We can choose which frame to resolve the measurements in by using hte keyword argument @named forcesensor = CutForce(; resolveInFrame = :world). If we do this, the traces in the plot above will overlap.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Since the torque sensor measures a torque in a revolute joint, it should measure zero torque in this case, no torque is transmitted through the revolute joint since the rotational axis is perpendicular to the gravitational force:","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"all(x -> abs(x) < 1e-3, reduce(hcat, sol[torquesensor.torque.u]))","category":"page"},{"location":"examples/spring_damper_system/#Spring-damper-system","page":"Spring-damper system","title":"Spring-damper system","text":"","category":"section"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"(Image: animation)","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"Welcome to the spring-damper system example, where we will show you the process of modeling and simulating a basic yet essential mechanical system using the powerful Multibody.jl package in JuliaSim. By understanding the underlying principles of spring-damper systems, you will gain valuable insights into the behavior of various real-world systems, such as suspension systems in vehicles, vibration isolation mechanisms, and biomechanical structures.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"This tutorial mirrors that of the following Modelica tutorial Spring damper system and demonstrates that a body can be freely moving without any connection to a joint. In this case body coordinates are used as state by setting the option isroot=true to the body.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"(Image: Spring-damper system)","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n@named begin\n    body1 = Body(; m = 1, isroot = true, r_cm = [0.0, 0, 0], I_11 = 0.1, I_22 = 0.1,\n                 I_33 = 0.1, r_0 = [0.3, -0.2, 0]) # This is root since there is no joint parallel to the spring leading to this body\n    body2 = Body(; m = 1, isroot = false, r_cm = [0.0, -0.2, 0]) # This is not root since there is a joint parallel to the spring leading to this body\n    bar1 = FixedTranslation(r = [0.3, 0, 0])\n    bar2 = FixedTranslation(r = [0.6, 0, 0])\n    p2 = Prismatic(n = [0, -1, 0], s0 = 0.1, useAxisFlange = true, isroot = true)\n    spring2 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    spring1 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    damper1 = Multibody.Damper(d = 2)\nend\neqs = [connect(world.frame_b, bar1.frame_a)\n       connect(bar1.frame_b, bar2.frame_a)\n       connect(bar2.frame_b, p2.frame_a)\n       connect(p2.frame_b, body2.frame_a)\n       connect(bar2.frame_b, spring2.frame_a)\n       connect(body2.frame_a, spring2.frame_b)\n       connect(damper1.frame_a, bar1.frame_b)\n       connect(spring1.frame_a, bar1.frame_b)\n       connect(damper1.frame_b, body1.frame_a)\n       connect(spring1.frame_b, body1.frame_a)]\n\n@named model = ODESystem(eqs, t,\n                         systems = [\n                             world,\n                             body1,\n                             body2,\n                             bar1,\n                             bar2,\n                             p2,\n                             spring1,\n                             spring2,\n                             damper1,\n                         ])\n\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys,\n                  [D.(body1.phi) .=> 0;\n                   D.(D.(body1.phi)) .=> 0;\n                   D.(body1.phid) .=> 0;\n                   D(p2.s) => 0;\n                   D(D(p2.s)) => 0;\n                   damper1.d => 2], (0, 10))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(\n    plot(sol, idxs = [spring1.s, spring2.s]),\n    plot(sol, idxs = [body1.r_0[2], body2.r_0[2]]),\n    plot(sol, idxs = [spring1.f, spring2.f]),\n)","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"This example has two parallel spring-mass parts, the first body (body1) is attached directly to the spring, with no joint in parallel with the spring. In this situation, we have to set isroot=true for body1 to indicate that we want to use the body variables as state. The second body (body2) is attached to the spring with a joint in parallel with the spring, so we can use the joint variables as state, hence isroot=false for body2.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"In this example we used separate springs and dampers, see also the component SpringDamperParallel which combines the two in one component.","category":"page"},{"location":"examples/spring_damper_system/#D-animation","page":"Spring-damper system","title":"3D animation","text":"","category":"section"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"import CairoMakie\nMultibody.render(model, sol; z = -5, filename = \"springdamper.gif\")\nnothing # hide","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"(Image: animation)","category":"page"},{"location":"examples/gearbox/#Gearbox","page":"Gearbox","title":"Gearbox","text":"","category":"section"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"This example models a gearbox in two different ways:","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"Using the 3D GearConstraint component from the multibody library.\nUsing the 1D IdealGear component from the Rotational submodule, together with a Mounting1D component.","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"The GearConstraint has two rotational axes which do not have to be parallel. If wou want to select rotational axes, use the keyword arguments n_a and n_b to GearConstraint.","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    gearConstraint = GearConstraint(; ratio = 10)\n    cyl1 = Body(; m = 1, r_cm = [0.4, 0, 0])\n    cyl2 = Body(; m = 1, r_cm = [0.4, 0, 0])\n    torque1 = Torque(resolveInFrame = :frame_b)\n    fixed = Fixed() \n    inertia1 = Rotational.Inertia(J = cyl1.I_11)\n    idealGear = Rotational.IdealGear(ratio = 10, use_support = true)\n    inertia2 = Rotational.Inertia(J = cyl2.I_11)\n    torque2 = Rotational.Torque(use_support = true)\n    mounting1D = Mounting1D()\nend\n\neqs = [connect(world.frame_b, gearConstraint.bearing)\n       connect(cyl1.frame_a, gearConstraint.frame_a)\n       connect(gearConstraint.frame_b, cyl2.frame_a)\n       connect(torque1.frame_b, cyl1.frame_a)\n       connect(torque1.frame_a, world.frame_b)\n       # connect(sine.output, torque1.torque)\n       torque1.torque.u .~ [2sin(t), 0, 0]\n       connect(inertia1.flange_b, idealGear.flange_a)\n       connect(idealGear.flange_b, inertia2.flange_a)\n       connect(torque2.flange, inertia1.flange_a)\n       # connect(sine.output, torque2.tau)\n       torque2.tau.u ~ 2sin(t)\n       connect(mounting1D.flange_b, idealGear.support)\n       connect(mounting1D.flange_b, torque2.support)\n       connect(fixed.frame_b, mounting1D.frame_a)]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\ncm = complete(model)\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [\n    D(cm.idealGear.phi_b) => 0\n], (0, 10))\nsol = solve(prob, Rodas4())\nplot(sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Multibody","category":"page"},{"location":"#Multibody","page":"Home","title":"Multibody","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Multibody.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the world of Multibody.jl, a powerful and flexible component of JuliaSim designed to model, analyze, and simulate multibody systems in Julia. As a state-of-the-art tool, Multibody.jl enables users to efficiently study the dynamics of complex mechanical systems in various fields, such as robotics, biomechanics, aerospace, and vehicle dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Built on top of the Julia language and the JuliaSim suite of tools for modeling, simulation, optimization and control, Multibody.jl harnesses the power of Julia's high-performance computing capabilities, making it a go-to choice for both researchers and engineers who require fast simulations and real-time performance. With an intuitive syntax and a comprehensive set of features, this package seamlessly integrates with other Julia and JuliaSim libraries, enabling users to tackle diverse and sophisticated problems in multibody dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this documentation, you will find everything you need to get started with Multibody.jl, from basic component descriptions to detailed examples showcasing the package's capabilities. As you explore this documentation, you'll learn how to create complex models, work with forces and torques, simulate various types of motions, and visualize your results in both 2D and 3D. Whether you are a seasoned researcher or a newcomer to the field, Multibody.jl will empower you to bring your ideas to life and unlock new possibilities in the fascinating world of multibody dynamics.","category":"page"},{"location":"#Notable-difference-from-Modelica","page":"Home","title":"Notable difference from Modelica","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The torque variable in Multibody.jl is typically called tau rather than t to not conflict with the often used independent variable t used to denote time.\nMultibody.jl occasionally requires the user to specify which component should act as the root of the kinematic tree. This only occurs when bodies are connected directly to force components without a joint parallel to the force component.\nIn Multibody.jl, the orientation object of a Frame is accessed using he function ori.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Frames","page":"Home","title":"Frames","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"frames.jl\"]","category":"page"},{"location":"#Multibody.Frame","page":"Home","title":"Multibody.Frame","text":"Frame(; name)\n\nFrame is the fundamental 3D connector in the multibody library. Most components have one or several Frame connectors that can be connected together.\n\nThe Frame connector has internal variables for\n\nr_0: The position vector from the world frame to the frame origin, resolved in the world frame\nf: The cut force resolved in the connector frame\ntau: The cut torque resolved in the connector frame\nDepending on usage, also rotation and rotational velocity variables.\n\n\n\n\n\n","category":"function"},{"location":"#Joints","page":"Home","title":"Joints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A joint restricts the number of degrees of freedom (DOF) of a body. For example, a free floating body has 6 DOF, but if it is attached to a Revolute joint, the joint restricts all but one rotational degree of freedom (a revolute joint acts like a hinge). Similarily, a Prismatic joint restricts all but one translational degree of freedom (a prismatic joint acts like a slider).","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Spherical joints restricts all translational degrees of freedom, but allows all rotational degrees of freedom. It thus transmits no torque.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some joints offer the option to add 1-dimensional components to them by providing the keyword useAxisFlange = true. This allows us to add, e.g., springs, dampers, sensors, and actuators to the joint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"joints.jl\"]","category":"page"},{"location":"#Multibody.FreeMotion-Tuple{}","page":"Home","title":"Multibody.FreeMotion","text":"FreeMotion(; name, enforceState = true, sequence, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, phi = 0, phi_d = 0, phi_dd = 0, w_rel_b = 0, r_rel_a = 0, v_rel_a = 0, a_rel_a = 0)\n\nJoint which does not constrain the motion between frame_a and frame_b. Such a joint is only meaningful if the relative distance and orientation between frame_a and frame_b, and their derivatives, shall be used as state.\n\nNote, that bodies such as Body, BodyShape, have potential state variables describing the distance and orientation, and their derivatives, between the world frame and a body fixed frame. Therefore, if these potential state variables are suited, a FreeMotion joint is not needed.\n\nThe state of the FreeMotion object consits of:\n\nThe relative position vector r_rel_a from the origin of frame_a to the origin of frame_b, resolved in frame_a and the relative velocity v_rel_a of the origin of frame_b with respect to the origin of frame_a, resolved in frame_a (= der(r_rel_a)).\n\nArguments\n\nenforceState: Enforce this joint having state, this is often desired and is the default choice.\nsequence: Rotation sequence\nw_rel_a_fixed: = true, if w_rel_a_start are used as initial values, else as guess values\nz_rel_a_fixed: = true, if z_rel_a_start are used as initial values, else as guess values\n\nInitial condition arguments:\n\nphi\nphi_d\nphi_dd\nw_rel_b\nr_rel_a\nv_rel_a\na_rel_a\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.GearConstraint-Tuple{}","page":"Home","title":"Multibody.GearConstraint","text":"GearConstraint(; name, ratio, checkTotalPower = false, n_a, n_b, r_a, r_b)\n\nThis ideal massless joint provides a gear constraint between frames frame_a and frame_b. The axes of rotation of frame_a and frame_b may be arbitrary.\n\nratio: Gear ratio\nn_a: Axis of rotation of frame_a\nn_b: Axis of rotation of frame_b\nr_a: Vector from frame bearing to frame_a resolved in bearing\nr_b: Vector from frame bearing to frame_b resolved in bearing\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Prismatic-Tuple{}","page":"Home","title":"Multibody.Prismatic","text":"Prismatic(; name, n = [0, 0, 1], useAxisFlange = false, isroot = true)\n\nPrismatic joint with 1 translational degree-of-freedom\n\nn: The axis of motion (unit vector)\nuseAxisFlange: If true, the joint will have two additional frames from Mechanical.Translational, axis and support, between which translational components such as springs and dampers can be connected.\nisroot: If true, the joint will be considered the root of the system.\n\nIf useAxisFlange, flange connectors for ModelicaStandardLibrary.Mechanics.TranslationalModelica are also available:\n\naxis: 1-dim. translational flange that drives the joint\nsupport: 1-dim. translational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)\n\nThe function returns an ODESystem representing the prismatic joint.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Revolute-Tuple{}","page":"Home","title":"Multibody.Revolute","text":"Revolute(; name, phi0 = 0, w0 = 0, n, useAxisFlange = false)\n\nRevolute joint with 1 rotational degree-of-freedom\n\nphi0: Initial angle\nw0: Iniitial angular velocity\nn: The axis of rotation\nuseAxisFlange: If true, the joint will have two additional frames from Mechanical.Rotational, axis and support, between which rotational components such as springs and dampers can be connected.\n\nIf useAxisFlange, flange connectors for ModelicaStandardLibrary.Mechanics.Rotational are also available:\n\naxis: 1-dim. rotational flange that drives the joint\nsupport: 1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheel-Tuple{}","page":"Home","title":"Multibody.RollingWheel","text":"RollingWheel(; name, radius, m, I_axis, I_long, width=0.035, x0, y0, kwargs...)\n\nIdeal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)\n\nA wheel rolling on the x-y plane of the world frame including wheel mass. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. The wheel can not take off but it can incline toward the ground. The frame frame_a is placed in the wheel center point and rotates with the wheel itself.\n\nArguments and parameters:\n\nname: Name of the rolling wheel component\nradius: Radius of the wheel\nm: Mass of the wheel\nI_axis: Moment of inertia of the wheel along its axis\nI_long: Moment of inertia of the wheel perpendicular to its axis\nwidth: Width of the wheel (default: 0.035)\nx0: Initial x-position of the wheel axis\ny0: Initial y-position of the wheel axis\nkwargs...: Additional keyword arguments passed to the RollingWheelJoint function\n\nVariables:\n\nx: x-position of the wheel axis\ny: y-position of the wheel axis\nangles: Angles to rotate world-frame into frame_a around z-, y-, x-axis\nder_angles: Derivatives of angles\n\nNamed components:\n\nframe_a: Frame for the wheel component\nrollingWheel: Rolling wheel joint representing the wheel's contact with the road surface\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheelJoint-Tuple{}","page":"Home","title":"Multibody.RollingWheelJoint","text":"RollingWheelJoint(; name, radius, angles, x0, y0, z0)\n\nJoint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0). See RollingWheel for a realistic wheel model with inertia.\n\nA joint for a wheel rolling on the x-y plane of the world frame. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. This is simply gained by two non-holonomic constraint equations on velocity level defined for both longitudinal and lateral direction of the wheel. There is also a holonomic constraint equation on position level granting a permanent contact of the wheel to the ground, i.e. the wheel can not take off.\n\nThe origin of the frame frame_a is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. The y-axis of frame_a is identical with the wheel spin axis, i.e. the wheel rotates about y-axis of frame_a. A wheel body collecting the mass and inertia should be connected to this frame.\n\nArguments and parameters:\n\nname: Name of the rolling wheel joint component radius: Radius of the wheel angles: Angles to rotate world-frame into frame_a around z-, y-, x-axis\n\nVariables:\n\nx: x-position of the wheel axis\ny: y-position of the wheel axis\nz: z-position of the wheel axis\nangles: Angles to rotate world-frame into frame_a around z-, y-, x-axis\nder_angles: Derivatives of angles\nr_road_0: Position vector from world frame to contact point on road, resolved in world frame\nf_wheel_0: Force vector on wheel, resolved in world frame\nf_n: Contact force acting on wheel in normal direction\nf_lat: Contact force acting on wheel in lateral direction\nf_long: Contact force acting on wheel in longitudinal direction\nerr: Absolute value of (r_road_0 - frame_a.r_0) - radius (must be zero; used for checking)\ne_axis_0: Unit vector along wheel axis, resolved in world frame\ndelta_0: Distance vector from wheel center to contact point\ne_n_0: Unit vector in normal direction of road at contact point, resolved in world frame\ne_lat_0: Unit vector in lateral direction of road at contact point, resolved in world frame\ne_long_0: Unit vector in longitudinal direction of road at contact point, resolved in world frame\ns: Road surface parameter 1\nw: Road surface parameter 2\ne_s_0: Road heading at (s,w), resolved in world frame (unit vector)\nv_0: Velocity of wheel center, resolved in world frame\nw_0: Angular velocity of wheel, resolved in world frame\nvContact_0: Velocity of contact point, resolved in world frame\n\nConnector frames\n\nframe_a: Frame for the wheel joint\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Spherical-Tuple{}","page":"Home","title":"Multibody.Spherical","text":"Spherical(; name, enforceState = false, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, sequence_angleStates, phi = 0, phi_d = 0, phi_dd = 0)\n\nJoint with 3 constraints that define that the origin of frame_a and the origin of frame_b coincide. By default this joint defines only the 3 constraints without any potential state variables. If parameter enforceState is set to true, three states are introduced. The orientation of frame_b is computed by rotating frame_a along the axes defined in parameter vector sequence_angleStates (default = [1,2,3], i.e., the Cardan angle sequence) around the angles used as state. If angles are used as state there is the slight disadvantage that a singular configuration is present leading to a division by zero.\n\nisroot: Indicate that frame_a is the root, otherwise frame_b is the root. Only relevant if enforceState = true.\nsequence_angleStates: Rotation sequence\n\n\n\n\n\n","category":"method"},{"location":"#Components","page":"Home","title":"Components","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The perhaps most fundamental component is a Body, this component has a single flange, frame_a, which is used to connect the body to other components. This component has a mass, a vector r_cm from frame_a to the center of mass, and a moment of inertia tensor I in the center of mass. The body can be thought of as a point mass with a moment of inertia tensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A mass with a shape can be modeled using a BodyShape. The primary difference between a Body and a BodyShape is that the latter has an additional flange, frame_b, which is used to connect the body to other components. The translation between flange_a and flange_b is determined by the vector r. The BodyShape is suitable to model, e.g., cylinders, rods, and boxes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rod without a mass (just a translation), is modeled using FixedTranslation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"components.jl\"]","category":"page"},{"location":"#Multibody.world","page":"Home","title":"Multibody.world","text":"The world component is the root of all multibody models. It is a fixed frame with a parallel gravitational field and a gravity vector specified by the unit direction world.n (defaults to [0, -1, 0]) and magnitude world.g (defaults to 9.81).\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.AccSensor-Tuple{}","page":"Home","title":"Multibody.AccSensor","text":"AccSensor(;name)\n\nIdeal sensor to measure the absolute flange angular acceleration\n\nConnectors:\n\nflange: Flange Flange of shaft from which sensor information shall be measured\na: RealOutput Absolute angular acceleration of flange\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.AxisControlBus-Tuple{}","page":"Home","title":"Multibody.AxisControlBus","text":"@connector AxisControlBus(; name)\n\nmotion_ref(t) = 0: = true, if reference motion is not in rest\nangle_ref(t) = 0: Reference angle of axis flange\nangle(t) = 0: Angle of axis flange\nspeed_ref(t) = 0: Reference speed of axis flange\nspeed(t) = 0: Speed of axis flange\nacceleration_ref(t) = 0: Reference acceleration of axis flange\nacceleration(t) = 0: Acceleration of axis flange\ncurrent_ref(t) = 0: Reference current of motor\ncurrent(t) = 0: Current of motor\nmotorAngle(t) = 0: Angle of motor flange\nmotorSpeed(t) = 0: Speed of motor flange\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.AxisType2-Tuple{}","page":"Home","title":"Multibody.AxisType2","text":"AxisType2(; name)\n\nAxis model of the r3 joints 4,5,6\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Body-Tuple{}","page":"Home","title":"Multibody.Body","text":"Body(; name, m = 1, r_cm, I = collect(0.001 * LinearAlgebra.I(3)), isroot = false, phi0 = zeros(3), phid0 = zeros(3), r_0=zeros(3))\n\nRepresenting a body with 3 translational and 3 rotational degrees-of-freedom.\n\nm: Mass\nr_cm: Vector from frame_a to center of mass, resolved in frame_a\nI: Inertia matrix of the body\nisroot: Indicate whether this component is the root of the system, useful when there are no joints in the model.\nphi0: Initial orientation, only applicable if isroot = true\nphid0: Initial angular velocity\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.BodyShape-Tuple{}","page":"Home","title":"Multibody.BodyShape","text":"BodyShape(; name, m = 1, r, kwargs...)\n\nThe BodyShape component is similar to a Body, but it has two frames and a vector r that describes the translation between them, while the body has a single frame only.\n\nr: Vector from frame_a to frame_b resolved in frame_a\nAll kwargs are passed to the internal Body component.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.FixedRotation-Tuple{}","page":"Home","title":"Multibody.FixedRotation","text":"FixedRotation(; name, r, n, sequence, isroot = false, angle, n_x, n_y)\n\nFixed translation followed by a fixed rotation of frame_b with respect to frame_a\n\nr: Translation vector\nn: Axis of rotation, resolved in frame_a\nsequence: DESCRIPTION\nangle: Angle of rotation around n, given in radians\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.FixedTranslation-Tuple{}","page":"Home","title":"Multibody.FixedTranslation","text":"FixedTranslation(; name, r)\n\nFixed translation of frame_b with respect to frame_a with position vector r resolved in frame_a.\n\nCan be though of as a massless rod. For a massive rod, see BodyShape or BodyCylinder.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.gravity_acceleration-Tuple{Any}","page":"Home","title":"Multibody.gravity_acceleration","text":"Compute the gravity acceleration, resolved in world frame\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.ori","page":"Home","title":"Multibody.ori","text":"ori(frame, varw = false)\n\nGet the orientation of sys as a RotationMatrix object.\n\nFor frames, the orientation is stored in the metadata field of the system as sys.metadata[:orientation].\n\nIf varw = true, the angular velocity variables w of the frame is also included in the RotationMatrix object, otherwise w is derived as the time derivative of R. varw = true is primarily used when selecting a component as root.\n\n\n\n\n\n","category":"function"},{"location":"#Forces","page":"Home","title":"Forces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"forces.jl\"]","category":"page"},{"location":"#Multibody.BasicTorque-Tuple{}","page":"Home","title":"Multibody.BasicTorque","text":"BasicTorque(; name, resolveInFrame = :world)\n\nLow-level torque component used to build Torque\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Damper-Tuple{}","page":"Home","title":"Multibody.Damper","text":"Damper(; d, name, kwargs)\n\nLinear damper acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = d D(s)\n\nwhere d is the (viscous) damping parameter, s is the distance between the origin of frame_a and the origin of frame_b and D(s) is the time derivative of s.\n\nArguments:\n\nd: Damping coefficient\n\nSee also SpringDamperParallel\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Force-Tuple{}","page":"Home","title":"Multibody.Force","text":"Force(; name, resolveInFrame = :frame_b)\n\nForce acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b (default)\n\nConnectors:\n\nframe_a\nframe_b\nforce: Of type Blocks.RealInput(3). x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame.\n\nKeyword arguments:\n\nresolveInFrame: The frame in which the cut force and cut torque are resolved. Default is :frame_b, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Spring-Tuple{}","page":"Home","title":"Multibody.Spring","text":"Spring(; c, name, m = 0, lengthFraction = 0.5, s_unstretched = 0, kwargs)\n\nLinear spring acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = c s\n\nwhere c is the spring stiffness parameter, s is the distance between the origin of frame_a and the origin of frame_b.\n\nOptionally, the mass of the spring is taken into account by a point mass located on the line between frame_a and frame_b (default: middle of the line). If the spring mass is zero, the additional equations to handle the mass are removed.\n\nArguments:\n\nc: Spring stiffness\nm: Mass of the spring (can be zero)\nlengthFraction: Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)\ns_unstretched: Length of the spring when it is unstretched\nkwargs: are passed to LineForceWithMass\n\nSee also SpringDamperParallel\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.SpringDamperParallel-Tuple{}","page":"Home","title":"Multibody.SpringDamperParallel","text":"SpringDamperParallel(; name, c, d, s_unstretched)\n\nLinear spring and linear damper in parallel acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = c (s - s_unstretched) + d cdot D(s)\n\nwhere c, s_unstretched and d are parameters, s is the distance between the origin of frame_a and the origin of frame_b and D(s) is the time derivative of s.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Torque-Tuple{}","page":"Home","title":"Multibody.Torque","text":"Torque(; name, resolveInFrame = :frame_b)\n\nTorque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b (default)\n\nConnectors:\n\nframe_a\nframe_b\ntorque: Of type Blocks.RealInput(3). x-, y-, z-coordinates of torque resolved in frame defined by resolveInFrame.\n\nKeyword arguments:\n\nresolveInFrame: The frame in which the cut force and cut torque are resolved. Default is :frame_b, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Sensors","page":"Home","title":"Sensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A sensor is an object that translates quantities in the mechanical domain into causal signals which can interact with causal components from ModelingToolkitStandardLibrary.Blocks, such as control systems etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"sensors.jl\"]","category":"page"},{"location":"#Multibody.CutForce-Tuple{}","page":"Home","title":"Multibody.CutForce","text":"BasicCutForce(; name, resolveInFrame)\n\nBasic sensor to measure cut force vector. Contains a connector of type Blocks.RealOutput with name force.\n\nresolveInFrame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.CutTorque-Tuple{}","page":"Home","title":"Multibody.CutTorque","text":"CutTorque(; name, resolveInFrame)\n\nBasic sensor to measure cut torque vector. Contains a connector of type Blocks.RealOutput with name torque.\n\nresolveInFrame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PartialCutForceBaseSensor-Tuple{}","page":"Home","title":"Multibody.PartialCutForceBaseSensor","text":"PartialCutForceBaseSensor(; name, resolveInFrame = :frame_a)\n\nresolveInFrame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Orientation-utilities","page":"Home","title":"Orientation utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"orientation.jl\"]","category":"page"},{"location":"#Multibody.RotationMatrix","page":"Home","title":"Multibody.RotationMatrix","text":"RotationMatrix\n\nA struct representing a 3D orientation as a rotation matrix.\n\nIf ODESystem is called on a RotationMatrix object o, symbolic variables for o.R and o.w are created and the value of o.R is used as the default value for the symbolic R.\n\nFields:\n\nR::R3: The rotation 3×3 matrix ∈ SO(3)\nw: The angular velocity vector\n\n\n\n\n\n","category":"type"},{"location":"#Multibody.NumRotationMatrix-Tuple{}","page":"Home","title":"Multibody.NumRotationMatrix","text":"NumRotationMatrix(; R = collect(1.0 * I(3)), w = zeros(3), name, varw = false)\n\nCreate a new RotationMatrix struct with symbolic elements. R,w determine default values.\n\nThe primary difference between NumRotationMatrix and RotationMatrix is that the NumRotationMatrix constructor is used in the constructor of a Frame in order to introduce the frame variables, whereas RorationMatrix (the struct) only wraps existing variables.\n\nvarw: If true, w is a variable, otherwise it is derived from the derivative of R as w = get_w(R).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.absoluteRotation-Tuple{Any, Any}","page":"Home","title":"Multibody.absoluteRotation","text":"R2 = absoluteRotation(R1, R_rel)\n\nR1: Orientation object to rotate frame 0 into frame 1\nR_rel: Orientation object to rotate frame 1 into frame 2\nR2: Orientation object to rotate frame 0 into frame 2\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.axisRotation-Tuple{Any, Any}","page":"Home","title":"Multibody.axisRotation","text":"axisRotation(sequence, angle; name = :R)\n\nGenerate a rotation matrix for a rotation around the specified axis.\n\nsequence: The axis to rotate around (1: x-axis, 2: y-axis, 3: z-axis)\nangle: The angle of rotation (in radians)\n\nReturns a RotationMatrix object.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.get_w-Tuple{AbstractMatrix}","page":"Home","title":"Multibody.get_w","text":"get_w(R)\n\nCompute the angular velocity w from the rotation matrix R and its derivative DR = D.(R).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.resolve1-Tuple{RotationMatrix, Any}","page":"Home","title":"Multibody.resolve1","text":"h1 = resolve1(R21, h2)\n\nR12 is a 3x3 matrix that transforms a vector from frame 1 to frame 2. h2 is a vector resolved in frame 2. h1 is the same vector in frame 1.\n\nTypical usage:\n\nresolve1(ori(frame_a), r_ab)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.resolve2-Tuple{RotationMatrix, Any}","page":"Home","title":"Multibody.resolve2","text":"h2 = resolve2(R21, h1)\n\nR21 is a 3x3 matrix that transforms a vector from frame 1 to frame 2. h1 is a vector resolved in frame 1. h2 is the same vector in frame 2.\n\nTypical usage:\n\nresolve2(ori(frame_a), a_0 - g_0)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.rotx","page":"Home","title":"Multibody.rotx","text":"rotx(t, deg = false)\n\nGenerate a rotation matrix for a rotation around the x-axis.\n\nt: The angle of rotation (in radians, unless deg is set to true)\ndeg: (Optional) If true, the angle is in degrees\n\nReturns a 3x3 rotation matrix.\n\n\n\n\n\n","category":"function"},{"location":"#Multibody.roty","page":"Home","title":"Multibody.roty","text":"roty(t, deg = false)\n\nGenerate a rotation matrix for a rotation around the y-axis.\n\nt: The angle of rotation (in radians, unless deg is set to true)\ndeg: (Optional) If true, the angle is in degrees\n\nReturns a 3x3 rotation matrix.\n\n\n\n\n\n","category":"function"},{"location":"#Multibody.rotz","page":"Home","title":"Multibody.rotz","text":"rotz(t, deg = false)\n\nGenerate a rotation matrix for a rotation around the z-axis.\n\nt: The angle of rotation (in radians, unless deg is set to true)\ndeg: (Optional) If true, the angle is in degrees\n\nReturns a 3x3 rotation matrix.\n\n\n\n\n\n","category":"function"},{"location":"#Interfaces","page":"Home","title":"Interfaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"interfaces.jl\"]","category":"page"}]
}
