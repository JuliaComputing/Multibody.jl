var documenterSearchIndex = {"docs":
[{"location":"examples/ropes_and_cables/#Ropes,-cables,-chains-and-strings","page":"Ropes, cables and chains","title":"Ropes, cables, chains and strings","text":"","category":"section"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"Ropes, cables and strings may be modeled using the Rope component. This component models a rope as a series of links connected by spherical joints, where each link is either","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"Stiff, and modeled as a BodyShape\nElastic, and modeled as a Spring, a Damper and Prismatic in parallel. ","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"The total mass of the rope is controlled by the parameter m, and this is distributed evenly across the links with m/n units of mass on each link. ","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"If the rope is elastic, the total spring coefficient of all links is governed by c, and each link as a coefficient of c*n, the same holds for the damping d.","category":"page"},{"location":"examples/ropes_and_cables/#Stiff-rope","page":"Ropes, cables and chains","title":"Stiff rope","text":"","category":"section"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"We start by simulating a stiff rope that is attached to the world in one end and to a mass in the other. The rope is made stiff (inelastic) by setting c = 0.","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\nusing Test\nt = Multibody.t\n\nworld = Multibody.world\nnumber_of_links = 6\n@named rope = Rope(l = 1, m = 6, n=number_of_links, c=0, d=0, air_resistance=0, d_joint=1, radius=0.03, color=[0.5, 0.4, 0.4, 1], dir=[0.05, 1, 0])\n@named body = Body(; m = 1, radius=0.2)\n\nconnections = [connect(world.frame_b, rope.frame_a)\n               connect(rope.frame_b, body.frame_a)]\n\n@named stiff_rope = ODESystem(connections, t, systems = [world, body, rope])\n\nssys = structural_simplify(IRSystem(stiff_rope))\nprob = ODEProblem(ssys, [], (0, 5))\nsol = solve(prob, Rodas4(autodiff=false))\n@test SciMLBase.successful_retcode(sol)\n\nimport GLMakie\nMultibody.render(stiff_rope, sol, filename = \"stiff_rope.gif\") # May take long time for n>=10","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"(Image: stiff_rope animation)","category":"page"},{"location":"examples/ropes_and_cables/#Elastic-rope","page":"Ropes, cables and chains","title":"Elastic rope","text":"","category":"section"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"Next up we model an elastic rope, we do this by setting c > 0. We also introduce some damping","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"world = Multibody.world\nnumber_of_links = 6\n@named rope = Rope(l = 1, m = 5, n=number_of_links, c=800.0, d=0.01, d_joint=0.1, air_resistance=0.2, dir=[0.2, 1, 0])\n@named body = Body(; m = 300, radius=0.2)\n\nconnections = [connect(world.frame_b, rope.frame_a)\n               connect(rope.frame_b, body.frame_a)]\n\n@named flexible_rope = ODESystem(connections, t, systems = [world, body, rope])\n\nssys = structural_simplify(IRSystem(flexible_rope))\nprob = ODEProblem(ssys, [], (0, 8))\nsol = solve(prob, Rodas4(autodiff=false));\n@test SciMLBase.successful_retcode(sol)\n\nMultibody.render(flexible_rope, sol, y = -3, x = -6, z = -6, lookat=[0, -3, 0], filename = \"flexible_rope.gif\") # May take long time for n>=10","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"(Image: flexible_rope animation)","category":"page"},{"location":"examples/ropes_and_cables/#A-chain-suspended-in-two-points","page":"Ropes, cables and chains","title":"A chain suspended in two points","text":"","category":"section"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"When a Rope component is used to model a chain that is suspended between two fixed points, a kinematic loop is formed. To break this loop, we introduce a spring in one end. ","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"number_of_links = 8\n\nchain_length = 2\nx_dist = 1.5 # Distance between the two mounting points\n\nsystems = @named begin\n    chain = Rope(l = chain_length, m = 5, n=number_of_links, c=0, d_joint=0.2, dir=[1, 0, 0], color=[0.5, 0.5, 0.5, 1], radius=0.05)\n    spring = Spring(c = 2000)\n    fixed = FixedTranslation(; r=[x_dist, 0, 0], radius=0.02, color=[0.1,0.1,0.1,1]) # Second mounting point\nend\n\nconnections = [connect(world.frame_b, fixed.frame_a, chain.frame_a)\n               connect(chain.frame_b, spring.frame_a)\n               connect(spring.frame_b, fixed.frame_b)]\n\n@named mounted_chain = ODESystem(connections, t, systems = [systems; world])\n\nssys = structural_simplify(IRSystem(mounted_chain))\nprob = ODEProblem(ssys, [\n    collect(chain.link_8.body.w_a) .=> [0,0,0]; \n    collect(chain.link_8.frame_b.r_0) .=> [x_dist,0,0]; \n], (0, 4))\nsol = solve(prob, Rodas4(autodiff=false))\n@test SciMLBase.successful_retcode(sol)\n\nMultibody.render(mounted_chain, sol, x=3, filename = \"mounted_chain.gif\") # May take long time for n>=10","category":"page"},{"location":"examples/ropes_and_cables/","page":"Ropes, cables and chains","title":"Ropes, cables and chains","text":"(Image: mounted_chain animation)","category":"page"},{"location":"examples/robot/#Industrial-robot","page":"Industrial robot","title":"Industrial robot","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"(Image: animation)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\nusing Test\n\nt = Multibody.t\nD = Differential(t)\n@named robot = Multibody.Robot6DOF()\nrobot = complete(robot)\n\nlength(equations(robot))","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"The robot is a medium sized system with some 2000 equations before simplification.","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"After simplification, the following states are chosen:","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"ssys = structural_simplify(IRSystem(robot))\nunknowns(ssys)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"prob = ODEProblem(ssys, Dict([\n    robot.mechanics.r1.phi => deg2rad(-60)\n    robot.mechanics.r2.phi => deg2rad(20)\n    robot.mechanics.r3.phi => deg2rad(90)\n    robot.mechanics.r4.phi => deg2rad(0)\n    robot.mechanics.r5.phi => deg2rad(-110)\n    robot.mechanics.r6.phi => deg2rad(0)\n\n    robot.axis1.motor.Jmotor.phi => deg2rad(-60) *  -105 # Multiply by gear ratio\n    robot.axis2.motor.Jmotor.phi => deg2rad(20) *  210\n    robot.axis3.motor.Jmotor.phi => deg2rad(90) *  60\n]), (0.0, 2.0))\nsol = solve(prob, Rodas5P(autodiff=false));\n@test SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [\n    robot.pathPlanning.controlBus.axisControlBus1.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus2.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus3.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus4.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus5.angle_ref\n    robot.pathPlanning.controlBus.axisControlBus6.angle_ref\n], layout=(4,3), size=(800,800), l=(:black, :dash), legend=:outertop, legendfontsize=6)\nplot!(sol, idxs = [\n    robot.pathPlanning.controlBus.axisControlBus1.angle\n    robot.pathPlanning.controlBus.axisControlBus2.angle\n    robot.pathPlanning.controlBus.axisControlBus3.angle\n    robot.pathPlanning.controlBus.axisControlBus4.angle\n    robot.pathPlanning.controlBus.axisControlBus5.angle\n    robot.pathPlanning.controlBus.axisControlBus6.angle\n], sp=1:6)\n\nplot!(sol, idxs = [\n    robot.axis1.controller.feedback1.output.u\n    robot.axis2.controller.feedback1.output.u\n    robot.axis3.controller.feedback1.output.u\n    robot.axis4.controller.feedback1.output.u\n    robot.axis5.controller.feedback1.output.u\n    robot.axis6.controller.feedback1.output.u\n], sp=7:12, lab=\"Position error\", link=:x)\nplot!(xlabel=[fill(\"\", 1, 9) fill(\"Time [s]\", 1, 3)])","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"We see that after an initial transient, the robot controller converges to tracking the reference trajectory well. However, since the first three axes of the robot are modeled as slightly flexible, and we are ultimately interested in the tracking performance after the gear box and any flexibilities it may suffer from, we plot also this tracking error","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"plot(sol, idxs = [\n    robot.axis1.controller.feedback1.output.u / ( -105)\n    robot.axis2.controller.feedback1.output.u / (210)\n    robot.axis3.controller.feedback1.output.u / (60)\n], layout=(1,3), lab=\"Position error, motor side\", link=:x)\nplot!(sol, idxs = [\n            robot.pathPlanning.controlBus.axisControlBus1.angle_ref - robot.mechanics.r1.phi #\n            robot.pathPlanning.controlBus.axisControlBus2.angle_ref - robot.mechanics.r2.phi #\n            robot.pathPlanning.controlBus.axisControlBus3.angle_ref - robot.mechanics.r3.phi #\n], lab=\"Position error, arm side\")","category":"page"},{"location":"examples/robot/#Trajectory-planning","page":"Industrial robot","title":"Trajectory planning","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"In the example, the robot is tracking a reference trajectory generated using the function point_to_point and interfaced from the component KinematicPTP. We can inspect the generated trajectory by plotting the positions, velocities and accelerations (we show one joint only to keep the plot size limited):","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"plot(sol, idxs = [\n            robot.pathPlanning.controlBus.axisControlBus1.angle_ref\n            robot.pathPlanning.controlBus.axisControlBus1.speed_ref\n            robot.pathPlanning.controlBus.axisControlBus1.acceleration_ref\n], layout=(3,1), lab=[\"\\$q\\$\" \"\\$\\\\dot q\\$\" \"\\$\\\\ddot q\\$\"], xlabel=[\"\" \"\" \"Time [s]\"])","category":"page"},{"location":"examples/robot/#3D-animation","page":"Industrial robot","title":"3D animation","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"import GLMakie\nMultibody.render(robot, sol; y=2, lookat=[0,1,0], filename = \"robot.gif\")\nnothing # hide","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"(Image: animation)","category":"page"},{"location":"examples/robot/#Kinematics","page":"Industrial robot","title":"Kinematics","text":"","category":"section"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"The coordinates of any point on the mechanism may be obtained in the world coordinate frame by either","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"output = collect(robot.mechanics.b6.frame_b.r_0)\nfkine = JuliaSimCompiler.build_explicit_observed_function(ssys, output)\nfkine(prob.u0, prob.p, 0)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"Query the solution object with the desired output, e.g.,","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"sol(0, idxs=output)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"query the problem with the output, in which case the initial condition is used to compute the output","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"prob[output]","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"or by building an explicit function (state, parameters, time) -> output","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"fkine = JuliaSimCompiler.build_explicit_observed_function(ssys, output)\nfkine(prob.u0, prob.p, 0)","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"note: Note\nThe function fkine above takes the full state of the robot model, as opposed to only the joint angles.","category":"page"},{"location":"examples/robot/","page":"Industrial robot","title":"Industrial robot","text":"# ### Jacobian # Temporarily deactivated\n# We can compute the Jacobian ``J`` of the forward-kinematics function using the package ForwardDiff (this Jacobian is often referred to as the _analytical Jacobian_, which in the 6DOF case is different from the _geometrical Jacobian_ that is used in the relation ``v = J\\dot{q}``). The Jacobian of the end-effector positional coordinates will be a 3×36 matrix, since we have 36-dimensional state of the robot after simplification. Since the end-effector coordinates do not depend on all the state variables, we may ask which variables it depends on by finding non-zero columns of ``J``\n# ```@example robot\n# using ModelingToolkit.ForwardDiff\n# J = ForwardDiff.jacobian(x->fkine(x, prob.p, 0), prob.u0)\n# nonzero_inds = findall(any(!iszero, J, dims=1)[:])\n# unknowns(ssys)[nonzero_inds]\n# ```\n# We see that the end-effector position depends on all mechanical angles except for the last one, which is expected since the end-effector origin is on the axis of rotation of joint 6. ","category":"page"},{"location":"examples/space/#Bodies-in-space","page":"Bodies in space","title":"Bodies in space","text":"","category":"section"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"The default gravity model in Multibody.jl computes the gravitational acceleration according to","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"a = g n","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"where g and n are properties of the world. The default values for these parameters are g = 9.81 and n = [0, -1, 0].","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"This example demonstrates how to use the point gravity model, in which the gravitational acceleration is always pointing towards the origin, with a magnitude determined by mu and r","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"-dfracmur^T r dfracrr","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"where mu is the gravity field constant (defaults to 3.986004418e14 for Earth) and r is the distance of a body from the origin.","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"In this example, we set mu = 1, point_gravity = true and let two masses orbit an invisible attractor at the origin.","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nW(;kwargs...) = Multibody.world\n\n@mtkmodel PointGrav begin\n    @components begin\n        world = W()\n        body1 = Body(\n            m=1,\n            I_11=0.1,\n            I_22=0.1,\n            I_33=0.1,\n            r_0=[0,0.6,0],\n            isroot=true,\n            # quat=true, # Activate to use quaternions as state instead of Euler angles\n            v_0=[1,0,0])\n        body2 = Body(\n            m=1,\n            I_11=0.1,\n            I_22=0.1,\n            I_33=0.1,\n            r_0=[0.6,0.6,0],\n            isroot=true,\n            # quat=true, # Activate to use quaternions as state instead of Euler angles\n            v_0=[0.6,0,0])\n    end\nend\n@named model = PointGrav()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\ndefs = [\n    model.world.mu => 1\n    model.world.point_gravity => true # The gravity model is selected here\n    collect(model.body1.w_a) .=> 0\n    collect(model.body2.w_a) .=> 0\n    \n]\nprob = ODEProblem(ssys, defs, (0, 5))\nsol = solve(prob, Rodas4())\nplot(sol)","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"import GLMakie\nMultibody.render(model, sol, filename = \"space.gif\")\nnothing # hide","category":"page"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"(Image: space)","category":"page"},{"location":"examples/space/#Turning-gravity-off","page":"Bodies in space","title":"Turning gravity off","text":"","category":"section"},{"location":"examples/space/","page":"Bodies in space","title":"Bodies in space","text":"To simulate without gravity, or with a gravity corresponding to that of another celestial body, set the value of g or mu appropriately for the chosen gravity model.","category":"page"},{"location":"examples/spherical_pendulum/#Spherical-pendulum","page":"Spherical pendulum","title":"Spherical pendulum","text":"","category":"section"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"This example models a spherical pendulum. The pivot point is modeled using a Spherical joint, this lets the pendulum rotate in three directions. The pendulum rod is modeled using a FixedTranslation, a component without inertial properties, and the mass of the tip is modeled using a Body. To model a rod with inertial properties, see, e.g., BodyShape or BodyCylinder, In this example, we choose the joint to be the root (joints are often better root objects than bodies).","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    joint = Spherical(state=true, isroot=true, phi = 1, phid = 3, radius=0.1, color=[1,1,0,1])\n    bar = FixedTranslation(r = [0, -1, 0])\n    body = Body(; m = 1, isroot = false, r_cm=[0.1, 0, 0])\nend\n\nconnections = [connect(world.frame_b, joint.frame_a)\n            connect(joint.frame_b, bar.frame_a)\n            connect(bar.frame_b, body.frame_a)]\n\n@named model = ODESystem(connections, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [], (0, 5))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [body.r_0...])","category":"page"},{"location":"examples/spherical_pendulum/#3D-animation","page":"Spherical pendulum","title":"3D animation","text":"","category":"section"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"import GLMakie\nMultibody.render(model, sol; filename = \"spherical.gif\") # Use \"spherical.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/spherical_pendulum/","page":"Spherical pendulum","title":"Spherical pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/spring_mass_system/#Spring-mass-system","page":"Spring-mass system","title":"Spring-mass system","text":"","category":"section"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"(Image: animation)","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"This example mirrors that of the modelica spring-mass system and demonstrates that we can model a spring-mass system in two different ways.","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"Using a prismatic joint and a 1-dimensional spring from the Translational submodule attached to the joint. The advantage of this approach is that the many elements from the Translational library can be easily used here and that this implementation is usually more efficient compared to when using 3-dimensional springs.\nUsing a 3-dimensional spring from the Multibody library.","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing ModelingToolkitStandardLibrary.Mechanical.TranslationalModelica\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    p1      = Prismatic(n = [0, -1, 0], s0 = 0.1, axisflange = true)\n    spring1 = TranslationalModelica.Spring(c=30, s_rel0 = 0.1)\n    spring2 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    body1   = Body(m = 1, r_cm = [0, 0, 0], radius=0.1, color=[1,0.5,0,1])\n    bar1    = FixedTranslation(r = [0.3, 0, 0])\n    bar2    = FixedTranslation(r = [0.3, 0, 0])\n    body2   = Body(m = 1, r_cm = [0, 0, 0], radius=0.1)\n    p2      = Prismatic(n = [0, -1, 0], s0 = 0.1, axisflange = true)\nend\n\neqs = [\n    connect(body1.frame_a, p1.frame_b)\n    connect(world.frame_b, bar1.frame_a)\n    connect(bar1.frame_b, p1.frame_a)\n    connect(spring1.flange_b, p1.axis)\n    connect(bar1.frame_b, bar2.frame_a)\n    connect(bar2.frame_b, p2.frame_a)\n    connect(p2.frame_b, body2.frame_a)\n    connect(bar2.frame_b, spring2.frame_a)\n    connect(body2.frame_a, spring2.frame_b)\n    connect(spring1.flange_a, p1.support)\n]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys,[], (0, 5))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(sol, idxs = [body1.r_0[2], body2.r_0[2]])","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"The plot indicates that the two systems behave identically. ","category":"page"},{"location":"examples/spring_mass_system/#3D-animation","page":"Spring-mass system","title":"3D animation","text":"","category":"section"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"import GLMakie\nMultibody.render(model, sol; x=5, z = 5, filename = \"springmass.gif\")\nnothing # hide","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"(Image: animation)","category":"page"},{"location":"examples/spring_mass_system/","page":"Spring-mass system","title":"Spring-mass system","text":"You may notice that only one of the springs is rendered, the multibody spring is a 3D mechanical component with a rendering defined, while the spring from the 1D rotational library has no notion of 3D extent.","category":"page"},{"location":"examples/swing/#Swing","page":"Swing","title":"Swing","text":"","category":"section"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"In this example, we will model a swing consisting of a rigid seat suspended in 4 ropes, mounted symmetrically in a ceiling. Each rope is modeled as a stiff rod with a small point mass at the center of gravity, terminated by a parallel spring-damper to model slight flexibility in the ropes. The ceiling mounting points are modeled as spherical joints, i.e., they do not transmit any torque in any direction. The rim of the seat is modeled as 4 rigid bodies configured in a square, as well as one point mass representing the load, located slightly below the rim assembly.","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"(Image: animation)","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"We start by defining a single rope component and attach it to a body in order to verify that it's working.","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nW(args...; kwargs...) = Multibody.world\n\n@mtkmodel SwingRope begin\n    @components begin\n        frame_a = Frame()\n        frame_b = Frame()\n        joint1 = Spherical(isroot=true, state=true, d=0.001, color=[0.7, 0.7, 0.7, 0.7])\n        rope = BodyShape(r=[0.0,-1,0], m=0.05, radius=0.01)\n        spring = Spring(c = inv(0.04/60), m=0.01, radius=0.06)\n        damper = Damper(d = 50.0, radius=0.05, length_fraction=0.1)\n    end\n    @equations begin\n        connect(frame_a, joint1.frame_a)\n        connect(joint1.frame_b, rope.frame_a)\n\n        connect(rope.frame_b, spring.frame_a, damper.frame_a)\n        connect(spring.frame_b, damper.frame_b, frame_b)\n    end\nend\n\n@mtkmodel SimpleSwing begin\n    @structural_parameters begin\n        h = 2\n        w = 0.4\n    end\n    @components begin\n        world = W()\n        upper_trans1 = FixedTranslation(r=[-w/2, 0, 0])\n        rope1 = SwingRope(rope.r=[-w/2, h, -w/2])\n        body  = Body(m=6, isroot=true, I_11=0.1, I_22=0.1, I_33=0.1)\n        damper = Damper(d=10.0)\n    end\n    @equations begin\n        connect(world.frame_b, upper_trans1.frame_a)\n        connect(rope1.frame_a, upper_trans1.frame_b)\n        # connect(world.frame_b, rope1.frame_a)\n        connect(rope1.frame_b, body.frame_a)\n        \n        connect(world.frame_b, damper.frame_a)\n        connect(body.frame_a, damper.frame_b)\n    end\nend\n@named model = SimpleSwing()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [\n    collect(model.body.v_0) .=> 0;\n    collect(model.body.w_a) .=> 0;\n], (0, 4))\nsol = solve(prob, ImplicitEuler(autodiff=false), reltol=5e-3)\n@assert SciMLBase.successful_retcode(sol)","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"import GLMakie\nMultibody.render(model, sol; z = -5, filename = \"simple_swing.gif\") # Use \"simple_swing.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"(Image: animation)","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"This makes for a rather interesting-looking springy pendulum!","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"Next, we create the full swing assembly","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"@mtkmodel Swing begin\n    @structural_parameters begin\n        h = 2\n        w = 0.4\n    end\n    @components begin\n        world = W()\n        upper_trans1 = FixedTranslation(r=[-w/2, 0, 0])\n        upper_trans2 = FixedTranslation(r=[ w/2, 0, 0])\n        rope1 = SwingRope(rope.r=[-w/2, -h, -w/2])\n        rope2 = SwingRope(rope.r=[-w/2, -h,  w/2])\n        rope3 = SwingRope(rope.r=[ w/2, -h, -w/2])\n        rope4 = SwingRope(rope.r=[ w/2, -h,  w/2])\n\n        body_back  = BodyShape(m=0.1, r = [w, 0, 0])\n        body_front = BodyShape(m=0.1, r = [w, 0, 0])\n        body_left  = BodyShape(m=0.1, r = [0, 0, w])\n        body_right = BodyShape(m=0.1, r = [0, 0, -w])\n\n        body  = Body(m=6, isroot=true, r_cm = [w/2, -w/2, w/2], cylinder_radius=0.01)\n\n        damper = Damper(d=0.5)\n    end\n    @equations begin\n        # Rope assembly\n        connect(world.frame_b, upper_trans1.frame_a, upper_trans2.frame_a)\n        connect(rope1.frame_a, rope2.frame_a, upper_trans1.frame_b)\n        connect(rope3.frame_a, rope4.frame_a, upper_trans2.frame_b)\n\n        # Body assembly\n        connect(body_back.frame_a, body_left.frame_a, rope1.frame_b)\n        connect(body_left.frame_b, body_front.frame_a, rope2.frame_b)\n        connect(body_front.frame_b, body_right.frame_a, rope4.frame_b)\n        connect(body_right.frame_b, rope3.frame_b) # Don't close the rigid kinematic loop\n        connect(body_back.frame_a, body.frame_a)\n\n        # World damping (damps swing motion)\n        connect(world.frame_b, damper.frame_a)\n        connect(body.frame_a, damper.frame_b)\n    end\nend\n\n@named model = Swing()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n\nd = 10\ndj = 0.01\nprob = ODEProblem(ssys, [\n    collect(model.body.r_0) .=> [0, -2, 0.0];\n    collect(model.body_right.body.r_0) .=> [0, -2, 0.5];\n    collect(model.body_left.body.r_0) .=> [0, -2, -0.5];\n    collect(model.body.v_0) .=> [0, 0, 5];\n    model.damper.d => 1;\n    model.rope1.damper.d => d;\n    model.rope2.damper.d => d;\n    model.rope3.damper.d => d;\n    model.rope4.damper.d => d;\n\n    model.rope1.joint1.d => dj;\n    model.rope2.joint1.d => dj;\n    model.rope3.joint1.d => dj;\n    model.rope4.joint1.d => dj;\n], (0.0, 6))\n\n\n@time sol = solve(prob, ImplicitEuler(autodiff=false), reltol=1e-2)\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(sol, idxs = [collect(model.body.r_0);])","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"import GLMakie\nMultibody.render(model, sol; y = -1, z = -3, lookat = [0, -1, 0], filename = \"swing.gif\") # Use \"swing.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"(Image: animation)","category":"page"},{"location":"examples/swing/","page":"Swing","title":"Swing","text":"There is an initial transient in the beginning where the springs in the ropes are vibrating substantially, but after about a second this transient is damped out (thanks in part to the, in this case desired, numerical damping contributed by the implicit Euler solver).","category":"page"},{"location":"examples/three_springs/#Three-springs","page":"Three springs (series forces)","title":"Three springs","text":"","category":"section"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"(Image: animation)","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"This example mirrors that of the modelica three-springs and demonstrates that we can connect mass-less force elements together.","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"The example connects three springs together in a single point. The springs are all massless and do normally not have any state variables, but we can insist on one of the springs being stateful, in this case, we must tell the lower spring component to act as root by setting fixed_rotation_at_frame_a = fixed_rotation_at_frame_b = true.","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    body1 = Body(m = 0.8, I_11 = 0.1, I_22 = 0.1, I_33 = 0.1, r_0 = [0.5, -0.3, 0],\n                 r_cm = [0, -0.2, 0], isroot=true, quat=true)\n    bar1 = FixedTranslation(r = [0.3, 0, 0])\n    bar2 = FixedTranslation(r = [0, 0, 0.3])\n    spring1 = Multibody.Spring(c = 20, m = 0, s_unstretched = 0.1, fixed_rotation_at_frame_b=true,\n                               r_rel_0 = [-0.2, -0.2, 0.2], radius=0.05, num_windings=10)\n    spring2 = Multibody.Spring(c = 40, m = 0, s_unstretched = 0.1, color=[0,0,0.3,1])\n    spring3 = Multibody.Spring(c = 20, m = 0, s_unstretched = 0.1, radius=0.05, num_windings=10)\nend\neqs = [connect(world.frame_b, bar1.frame_a)\n       connect(world.frame_b, bar2.frame_a)\n       connect(bar1.frame_b, spring1.frame_a)\n       connect(bar2.frame_b, spring3.frame_a)\n       connect(spring2.frame_b, body1.frame_a)\n       connect(spring3.frame_b, spring1.frame_b)\n       connect(spring2.frame_a, spring1.frame_b)]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [], (0, 10))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(sol, idxs = [body1.r_0...])","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"# States selected by Dymola\n# Statically selected continuous time states\n# body1.frame_a.r_0[1]\n# body1.frame_a.r_0[2]\n# body1.frame_a.r_0[3]\n# body1.v_0[1]\n# body1.v_0[2]\n# body1.v_0[3]\n# body1.w_a[1]\n# body1.w_a[2]\n# body1.w_a[3]\n\n# Dynamically selected continuous time states\n# There is one set of dynamic state selection.\n# There are 3 states to be selected from:\n# body1.Q[]","category":"page"},{"location":"examples/three_springs/#3D-animation","page":"Three springs (series forces)","title":"3D animation","text":"","category":"section"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"import GLMakie\nMultibody.render(model, sol; filename = \"three_springs.gif\") # Use \"three_springs.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/three_springs/","page":"Three springs (series forces)","title":"Three springs (series forces)","text":"(Image: animation)","category":"page"},{"location":"rotations/#Working-with-orientation-and-rotation","page":"Rotations and orientation","title":"Working with orientation and rotation","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Orientations and rotations in 3D can be represented in multiple different ways. Components which (may) have a 3D angular state, such as Body, Spherical and FreeMotion, offer the user to select the orientation representation, either Euler angles or quaternions.","category":"page"},{"location":"rotations/#Euler-angles","page":"Rotations and orientation","title":"Euler angles","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Euler angles represent orientation using rotations around three axes, and thus uses three numbers to represent the orientation. The benefit of this representation is that it is minimal (only three numbers used), but the drawback is that any 3-number orientation representation suffers from a kinematic singularity. This representation is beneficial when you know that the singularity will not come into play in your simulation.","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Most components that may use Euler angles also allow you to select the sequence of axis around which to perform the rotations, e.g., sequence = [1,2,3] performs rotations around x first, then y and z.","category":"page"},{"location":"rotations/#Quaternions","page":"Rotations and orientation","title":"Quaternions","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"A quaternion represents an orientation using 4 numbers. This is a non-minimal representation, but in return it is also singularity free. Multibody.jl uses non-unit quaternions[quat] to represent orientation when quat = true is provided to components that support this option. The convention used for quaternions is s v_1 v_2 v_3, sometimes also referred to as w i j k, i.e., the real/scalar part comes first, followed by the three imaginary numbers. When quaternions are used, state variables Q̂ denote non-unit quaternions, while normalized unit quaternions are available as observable variables Q. The use of non-unit quaternions allows Multibody to integrate rotations without using dynamic state selection or introducing algebraic equations. ","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"[quat]: \"Integrating Rotations using Non-Unit Quaternions\", Caleb Rucker, https://par.nsf.gov/servlets/purl/10097724","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Multibody.jl depends on Rotations.jl which in turn uses Quaternions.jl for quaternion computations. If you manually create quaternions using these packages, you may convert them to a vector to provide, e.g., initial conditions, using Rotations.params(Q) (see Conversion between orientation formats below).","category":"page"},{"location":"rotations/#Examples-using-quaternions","page":"Rotations and orientation","title":"Examples using quaternions","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Free motions (second example on the page)\nThree springs\nBodies in space (may use, see comment)","category":"page"},{"location":"rotations/#Rotation-matrices","page":"Rotations and orientation","title":"Rotation matrices","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"Rotation matrices represent orientation using a 3times 3 matrix in SO(3). These are used in the equations of multibody components and connectors, but should for the most part be invisible to the user. In particular, they should never appear as state variables after simplification. ","category":"page"},{"location":"rotations/#Conversion-between-orientation-formats","page":"Rotations and orientation","title":"Conversion between orientation formats","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"You may convert between different representations of orientation using the appropriate constructors from Rotations.jl, for example:","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"using Multibody.Rotations\nusing Multibody.Rotations: params\nusing Multibody.Rotations.Quaternions\nusing LinearAlgebra\n\nR = RotMatrix{3}(I(3))","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"# Convert R to a quaternion\nQ = QuatRotation(R)","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"# Convert Q to a 4-vector\nQvec = params(Q)","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"# Convert R to Euler angles in the sequence XYZ\nE = RotXYZ(R)","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"# Convert E to a 3-vector\nEvec = params(E)","category":"page"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"rotation_axis(R), rotation_angle(R) # Get an axis-angle representation","category":"page"},{"location":"rotations/#Conventions-for-modeling","page":"Rotations and orientation","title":"Conventions for modeling","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"See Orientations and directions","category":"page"},{"location":"rotations/#Orientation-API","page":"Rotations and orientation","title":"Orientation API","text":"","category":"section"},{"location":"rotations/","page":"Rotations and orientation","title":"Rotations and orientation","text":"See Orientation utilities","category":"page"},{"location":"examples/quad/#Quadrotor-with-cable-suspended-load","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"","category":"section"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"(Image: quadrotor animation)","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"This example builds a simple model of a quadrotor that carries a load suspended by a cable. The quadrotor has four arms, each with a thruster at the end. The quadrotor is controlled by three PID controllers: one for altitude, one for roll, and one for pitch (for simplicity, no position controller is included here).","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"The main body of the aircraft is modeled using a Body, and the arms are modeled using BodyCylinder components. The total inertia of the body and arms are automatically computed using the geometry and density properties of the bodies involved. The thrusters are modeled using a custom component called Thruster that applies a force in the y-direction. The thruster model is kinematical only, and does not model the rotation dynamics of the motors or any aerodynamics. The quadrotor is connected to the world frame using a FreeMotion joint, which allows the quadrotor to move freely in space.","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"using Multibody\nusing ModelingToolkit\nusing ModelingToolkitStandardLibrary.Blocks\nusing LinearAlgebra\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\nusing Test\nt = Multibody.t\nD = Differential(t)\n\nworld = Multibody.world\n\nnum_arms = 4 # Number of arms of the rotor craft.\nangle_between_arms = 2*pi/num_arms # Angle between the arms, assuming they are evenly spaced.\narm_length = 0.2 # Length of each arm.\narm_outer_diameter = 0.03\narm_inner_diameter = 0.02\narm_density = 800 # Density of the arm [kg/m³].\nbody_mass = 0.2 # Mass of the body.\nload_mass = 0.1 # Mass of the load.\ncable_length = 1 # Length of the cable.\ncable_mass = 5   # Mass of the cable.\ncable_diameter = 0.01 # Diameter of the cable.\nnumber_of_links = 5 # Number of links in the cable.\n\n# Controller parameters\nkalt = 1\nTialt = 3\nTdalt = 3\n\nkroll = 0.02\nTiroll = 100\nTdroll = 1\n\nkpitch = 0.02\nTipitch = 100\nTdpitch = 1\n\n@mtkmodel Thruster begin\n    @components begin\n        frame_b = Frame()\n        thrust3d = WorldForce(resolve_frame = :frame_b, scale=0.1, radius=0.02) # The thrust force is resolved in the local frame of the thruster.\n        thrust = RealInput()\n    end\n    @variables begin\n        u(t), [state_priority=1000]\n    end\n    @equations begin\n        thrust3d.force.u[1] ~ 0\n        thrust3d.force.u[2] ~ thrust.u\n        thrust3d.force.u[3] ~ 0\n        thrust.u ~ u\n        connect(frame_b, thrust3d.frame_b)\n    end\nend\n\nfunction RotorCraft(; closed_loop = true, addload=true)\n    arms = [\n        BodyCylinder(\n            r = [arm_length*cos(angle_between_arms*(i-1)), 0, arm_length*sin(angle_between_arms*(i-1))],\n            diameter = arm_outer_diameter,\n            inner_diameter = arm_inner_diameter,\n            density = arm_density,\n            name=Symbol(\"arm$i\"),\n        ) for i = 1:num_arms\n    ]\n\n    @variables begin\n        y_alt(t)\n        y_roll(t)\n        y_pitch(t)\n    end\n\n    thrusters = [Thruster(name = Symbol(\"thruster$i\")) for i = 1:num_arms]\n    @named body = Body(m = body_mass, state_priority = 0, I_11=0.01, I_22=0.01, I_33=0.01, air_resistance=1)\n    @named freemotion = FreeMotion(state=true, isroot=true, quat=false) # We use Euler angles to describe the orientation of the rotorcraft.\n\n    connections = [\n        connect(world.frame_b, freemotion.frame_a)\n        connect(freemotion.frame_b, body.frame_a)\n        y_alt ~ body.r_0[2]\n        y_roll ~ freemotion.phi[3]\n        y_pitch ~ freemotion.phi[1]\n        [connect(body.frame_a, arms[i].frame_a) for i = 1:num_arms]\n        [connect(arms[i].frame_b, thrusters[i].frame_b) for i = 1:num_arms]\n    ]\n    systems = [world; arms; body; thrusters; freemotion]\n    if addload\n        @named load = Body(m = load_mass, air_resistance=0.1)\n        @named cable = Rope(\n            l = cable_length,\n            m = cable_mass,\n            n = number_of_links,\n            c = 0,\n            d = 0,\n            air_resistance = 0.1,\n            d_joint = 0.1,\n            radius = cable_diameter/2,\n            color = [0.5, 0.4, 0.4, 1],\n            dir = [0.0, -1, 0]\n        )\n        push!(systems, load)\n        push!(systems, cable)\n        \n        push!(connections, connect(body.frame_a, cable.frame_a))\n        push!(connections, connect(cable.frame_b, load.frame_a))\n    end\n    if closed_loop # add controllers\n\n        # Mixing matrices for the control signals\n        @parameters Galt[1:4] = ones(4) # The altitude controller affects all thrusters equally\n        @parameters Groll[1:4] = [-1,0,1,0]\n        @parameters Gpitch[1:4] = [0,1,0,-1]\n\n        @named Calt = PID(; k=kalt, Ti=Tialt, Td=Tdalt)\n        @named Croll = PID(; k=kroll, Ti=Tiroll, Td=Tdroll)\n        @named Cpitch = PID(; k=kpitch, Ti=Tipitch, Td=Tdpitch)\n\n        uc = Galt*Calt.ctr_output.u + Groll*Croll.ctr_output.u + Gpitch*Cpitch.ctr_output.u\n        uc = collect(uc)\n        append!(connections, [thrusters[i].u ~ uc[i] for i = 1:num_arms])\n\n        append!(connections, [\n            Calt.err_input.u ~ -y_alt\n            Croll.err_input.u ~ -y_roll\n            Cpitch.err_input.u ~ -y_pitch\n        ])\n        append!(systems, [Calt; Croll; Cpitch])\n\n        #=\n        # append!(connections, [thrusters[i].thrust.u ~ feedback_gain.output.u[i] for i = 1:num_arms])\n        # append!(connections, [feedback_gain.input.u[i] ~ arms[i].frame_b.r_0[2] for i = 1:num_arms ]) # Connect positions to controller\n        # append!(connections, [feedback_gain.input.u[i+num_arms] ~ D(arms[i].frame_b.r_0[2]) for i = 1:num_arms]) # Connect velocities to controller\n        # append!(connections, [feedback_gain.input.u[i+2num_arms] ~ Ie[i] for i = 1:num_arms]) #\n        # append!(connections, [feedback_gain.input.u[i] ~ freemotion.phi[[1,3][i]] for i = 1:2 ]) # Connect positions to controller\n        # append!(connections, [feedback_gain.input.u[i+2] ~ freemotion.phid[[1,3][i]] for i = 1:2]) # Connect velocities to controller\n        # push!(systems, feedback_gain)\n        =#\n    end\n    @named model = ODESystem(connections, t; systems)\n    complete(model)\nend\nmodel = RotorCraft(closed_loop=true, addload=true)\nssys = structural_simplify(IRSystem(model))\n\nop = [\n    model.body.v_0[1] => 0;\n    collect(model.cable.joint_2.phi) .=> 0.03;\n    model.world.g => 2;\n    # model.body.frame_a.render => true\n    # model.body.frame_a.radius => 0.01\n    # model.body.frame_a.length => 0.1\n]\n\nprob = ODEProblem(ssys, op, (0, 20))\nsol = solve(prob, FBDF(autodiff=false), reltol=1e-8, abstol=1e-8)\n@test SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs=[model.arm1.frame_b.r_0[2], model.arm2.frame_b.r_0[2], model.arm3.frame_b.r_0[2], model.arm4.frame_b.r_0[2]], layout=4, framestyle=:zerolines)","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"import GLMakie\nrender(model, sol, 0:0.1:sol.t[end], x=-3, z=-3, y=-1, lookat=[0,-1,0], show_axis=false, filename=\"quadrotor.gif\", framerate=25)\nnothing # hide","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"(Image: quadrotor animation)","category":"page"},{"location":"examples/quad/","page":"Quadrotor with cable-suspended load","title":"Quadrotor with cable-suspended load","text":"The green arrows in the animation indicate the force applied by the thrusters.","category":"page"},{"location":"examples/free_motion/#Free-motions","page":"Free motions","title":"Free motions","text":"","category":"section"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"This example demonstrates how a free-floating Body can be simulated. The body is attached to the world through a FreeMotion joint, i.e., a joint that imposes no constraints. The joint is required to add the appropriate relative state variables between the world and the body. We choose state = true and isroot = true in the FreeMotion constructor.","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\n@named freeMotion = FreeMotion(state = true, isroot = true)\n@named body = Body(m = 1)\n\neqs = [connect(world.frame_b, freeMotion.frame_a)\n       connect(freeMotion.frame_b, body.frame_a)]\n\n@named model = ODESystem(eqs, t,\n                         systems = [world;\n                                    freeMotion;\n                                    body])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [], (0, 10))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = body.r_0[2], title=\"Free falling body\")\n\n# Plot analytical solution\ntvec = 0:0.1:sol.t[end]\nplot!(tvec, -9.81/2 .* tvec .^ 2, lab=\"Analytical solution\")","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"The figure indicates that the body is falling freely, experiencing a constant acceleration of -9.81 m/s² in the y direction, corresponding to the gravity parameters of the world:","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"show(stdout, MIME\"text/plain\"(), world) # hide\nnothing # hide","category":"page"},{"location":"examples/free_motion/#Body-suspended-in-springs","page":"Free motions","title":"Body suspended in springs","text":"","category":"section"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"If we instead model a body suspended in springs without the presence of any joint, we need to give the body state variables. We do this by saying isroot = true when we create the body, we also use quaternions to represent angular state using quat = true.","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"using Multibody.Rotations: QuatRotation, RotXYZ, params\n@named begin\n    body = BodyShape(m = 1, I_11 = 1, I_22 = 1, I_33 = 1, r = [0.4, 0, 0],\n                     r_0 = [0.2, -0.5, 0.1], isroot = true, quat=true)\n    bar2 = FixedTranslation(r = [0.8, 0, 0])\n    spring1 = Multibody.Spring(c = 20, s_unstretched = 0)\n    spring2 = Multibody.Spring(c = 20, s_unstretched = 0)\nend\n\neqs = [connect(bar2.frame_a, world.frame_b)\n       connect(spring1.frame_b, body.frame_a)\n       connect(bar2.frame_b, spring2.frame_a)\n       connect(spring1.frame_a, world.frame_b)\n       connect(body.frame_b, spring2.frame_b)]\n\n@named model = ODESystem(eqs, t,\n                         systems = [\n                             world,\n                             body,\n                             bar2,\n                             spring1,\n                             spring2,\n                         ])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [\n    collect(body.body.v_0 .=> 0);\n    collect(body.body.w_a .=> 0);\n    # collect(body.body.phi .=> deg2rad.([10,10,10])); # If using Euler/Cardan angles\n    collect(body.body.Q̂) .=> params(QuatRotation(RotXYZ(deg2rad.((10,10,10))...)));\n], (0, 4))\n\nsol = solve(prob, Rodas5P())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [body.r_0...])\n# plot(sol, idxs = [body.body.Q...])\n","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"import GLMakie\nMultibody.render(model, sol, filename = \"free_body.gif\")\nnothing # hide","category":"page"},{"location":"examples/free_motion/","page":"Free motions","title":"Free motions","text":"(Image: free_body)","category":"page"},{"location":"examples/pendulum/#Pendulum–The-\"Hello-World-of-multi-body-dynamics\"","page":"Getting started: Pendulum","title":"Pendulum–The \"Hello World of multi-body dynamics\"","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This beginners tutorial will start by modeling a pendulum pivoted around the origin in the world frame. The world frame is a constant that lives inside the Multibody module, all multibody models are \"grounded\" in the same world, i.e., the world component must be included in all models.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To start, we load the required packages","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using ModelingToolkit\nusing Multibody, JuliaSimCompiler\nusing OrdinaryDiffEq # Contains the ODE solver we will use\nusing Plots","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"We then access the world frame and time variable from the Multibody module","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"t = Multibody.t\nworld = Multibody.world\nshow(stdout, MIME\"text/plain\"(), world) # hide\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Unless otherwise specified, the world defaults to having a gravitational field pointing in the negative y direction and a gravitational acceleration of 981 (See Bodies in space for more options).","category":"page"},{"location":"examples/pendulum/#Modeling-the-pendulum","page":"Getting started: Pendulum","title":"Modeling the pendulum","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Our simple pendulum will initially consist of a Body (point mass) and a Revolute joint (the pivot joint). We construct these elements by calling their constructors","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named joint = Revolute(n = [0, 0, 1], isroot = true)\n@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The n argument to Revolute denotes the rotational axis of the joint, this vector must have norm(n) == 1. We also indicate that the revolute joint is the root of the kinematic tree, i.e., the potential state of the joint will serve as the state variables for the system.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The Body is constructed by providing its mass, m, and the vector r_cm from its mounting frame, body.frame_a, to the center of mass. Since the world by default has the gravity field pointing along the negative y axis, we place the center of mass along the x-axis to make the pendulum swing back and forth. The body is not selected as the root of the kinematic tree, since we have a joint in this system, but if we had attached the body directly to, e.g., a spring, we could set the body to be the root and avoid having to introduce an \"artificial joint\", which is otherwise needed in order to have at least one component that has a potential state.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To connect the components together, we create a vector of connections using the connect function. A joint typically has two frames, frame_a and frame_b. In this example, the first frame of the joint is attached to the world frame, and the body is attached to the second frame of the joint, i.e., the joint allows the body to swing back and forth. The order of the connections is not important for ModelingToolkit, but it's good practice to follow some convention, here, we start at the world and progress outwards in the kinematic tree.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"connections = [\n    connect(world.frame_b, joint.frame_a)\n    connect(joint.frame_b, body.frame_a)\n]\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"With all components and connections defined, we can create an ODESystem like so:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named model = ODESystem(connections, t, systems=[world, joint, body])\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The ODESystem is the fundamental model type in ModelingToolkit used for multibody-type models.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Before we can simulate the system, we must perform model compilation using structural_simplify","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"ssys = structural_simplify(IRSystem(model))","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This results in a simplified model with the minimum required variables and equations to be able to simulate the system efficiently. This step rewrites all connect statements into the appropriate equations, and removes any redundant variables and equations. To simulate the pendulum, we require two state variables, one for angle and one for angular velocity, we can see above that these state variables have indeed been chosen.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"We are now ready to create an ODEProblem and simulate it. We use the Rodas4 solver from OrdinaryDiffEq.jl, and pass a dictionary for the initial conditions. We specify only initial condition for some variables, for those variables where no initial condition is specified, the default initial condition defined the model will be used.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"D = Differential(t)\ndefs = Dict() # We may specify the initial condition here\nprob = ODEProblem(ssys, defs, (0, 3.35))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = joint.phi, title=\"Pendulum\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The solution sol can be plotted directly if the Plots package is loaded. The figure indicates that the pendulum swings back and forth without any damping. To add damping as well, we could add a Damper from the ModelingToolkitStandardLibrary.Mechanical.Rotational module to the revolute joint. We do this below","category":"page"},{"location":"examples/pendulum/#3D-Animation","page":"Getting started: Pendulum","title":"3D Animation","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"import GLMakie # GLMakie is another alternative, suitable for interactive plots\nMultibody.render(model, sol; filename = \"pendulum.gif\") # Use \"pendulum.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: animation)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"By default, the world frame is indicated using the convention x: red, y: green, z: blue. The animation shows how the simple Body represents a point mass with inertial properties at a particular distance r_cm away from its mounting flange frame_a. The cylinder that is shown connecting the pivot point to the body is for visualization purposes only, it does not have any inertial properties. To model a more physically motivated pendulum rod, we could have used a BodyShape component, which has two mounting flanges instead of one. The BodyShape component is shown in several of the examples available in the example sections of the documentation.","category":"page"},{"location":"examples/pendulum/#Adding-damping","page":"Getting started: Pendulum","title":"Adding damping","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"To add damping to the pendulum such that the pendulum will eventually come to rest, we add a Damper to the revolute joint. The damping coefficient is given by d, and the damping force is proportional to the angular velocity of the joint. To add the damper to the revolute joint, we must create the joint with the keyword argument axisflange = true, this adds two internal flanges to the joint to which you can attach components from the ModelingToolkitStandardLibrary.Mechanical.Rotational module (1-dimensional components). We then connect one of the flanges of the damper to the axis flange of the joint, and the other damper flange to the support flange which is rigidly attached to the world.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named damper = Rotational.Damper(d = 0.3)\n@named joint = Revolute(n = [0, 0, 1], isroot = true, axisflange = true)\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(damper.flange_b, joint.axis)\n               connect(joint.support, damper.flange_a)\n               connect(body.frame_a, joint.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, joint, body, damper])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [damper.phi_rel => 1], (0, 10))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = joint.phi, title=\"Damped pendulum\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This time we see that the pendulum loses energy and eventually comes to rest at the stable equilibrium point pi  2.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Multibody.render(model, sol; filename = \"pendulum_damped.gif\")\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: animation damped)","category":"page"},{"location":"examples/pendulum/#A-linear-pendulum?","page":"Getting started: Pendulum","title":"A linear pendulum?","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"When we think of a pendulum, we typically think of a rotary pendulum that is rotating around a pivot point like in the examples above.  A mass suspended in a spring can be though of as a linear pendulum (often referred to as a harmonic oscillator rather than a pendulum), and we show here how we can construct a model of such a device. This time around, we make use of a Prismatic joint rather than a Revolute joint. A prismatic joint has one positional degree of freedom, compared to the single rotational degree of freedom for the revolute joint.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named body_0 = Body(; m = 1, isroot = false, r_cm = [0, 0, 0])\n@named damper = Translational.Damper(d=1)\n@named spring = Translational.Spring(c=10)\n@named joint = Prismatic(n = [0, 1, 0], axisflange = true)\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(damper.flange_b, spring.flange_b, joint.axis)\n               connect(joint.support, damper.flange_a, spring.flange_a)\n               connect(body_0.frame_a, joint.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, joint, body_0, damper, spring])\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [], (0, 10))\n\nsol = solve(prob, Rodas4())\nPlots.plot(sol, idxs = joint.s, title=\"Mass-spring-damper system\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"As is hopefully evident from the little code snippet above, this linear pendulum model has a lot in common with the rotary pendulum. In this example, we connected both the spring and a damper to the same axis flange in the joint. This time, the components came from the Translational submodule of ModelingToolkitStandardLibrary rather than the Rotational submodule. Also here do we pass axisflange when we create the joint to make sure that it is equipped with the flanges support and axis needed to connect the translational components.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Multibody.render(model, sol; filename = \"linear_pend.gif\", framerate=24)\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: linear pendulum)","category":"page"},{"location":"examples/pendulum/#Why-do-we-need-a-joint?","page":"Getting started: Pendulum","title":"Why do we need a joint?","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"In the example above, we introduced a prismatic joint to model the oscillating motion of the mass-spring system. In reality, we can suspend a mass in a spring without any joint, so why do we need one here? The answer is that we do not, in fact, need the joint, but if we connect the spring directly to the world, we need to make the body (mass) the root object of the kinematic tree instead:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"@named root_body = Body(; m = 1, isroot = true, r_cm = [0, 1, 0], phi0 = [0, 1, 0])\n@named multibody_spring = Multibody.Spring(c=10)\n\nconnections = [connect(world.frame_b, multibody_spring.frame_a)\n                connect(root_body.frame_a, multibody_spring.frame_b)]\n\n@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body])\nssys = structural_simplify(IRSystem(model))\n\ndefs = Dict(collect(root_body.r_0) .=> [0, 1e-3, 0]) # The spring has a singularity at zero length, so we start some distance away\n\nprob = ODEProblem(ssys, defs, (0, 10))\n\nsol = solve(prob, Rodas4())\nplot(sol, idxs = multibody_spring.r_rel_0[2], title=\"Mass-spring system without joint\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Here, we used a Multibody.Spring instead of connecting a Translational.Spring to a joint. The Translational.Spring, alongside other components from ModelingToolkitStandardLibrary.Mechanical, is a 1-dimensional object, whereas multibody components are 3-dimensional objects.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Internally, the Multibody.Spring contains a Translational.Spring, attached between two flanges, so we could actually add a damper to the system as well:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"push!(connections, connect(multibody_spring.spring2d.flange_a, damper.flange_a))\npush!(connections, connect(multibody_spring.spring2d.flange_b, damper.flange_b))\n\n@named model = ODESystem(connections, t, systems = [world, multibody_spring, root_body, damper])\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, defs, (0, 10))\n\nsol = solve(prob, Rodas4(), u0 = prob.u0 .+ 1e-5 .* randn.())\nplot(sol, idxs = multibody_spring.r_rel_0[2], title=\"Mass-spring-damper without joint\")","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The figure above should look identical to the simulation of the mass-spring-damper further above.","category":"page"},{"location":"examples/pendulum/#Going-3D","page":"Getting started: Pendulum","title":"Going 3D","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The systems we have modeled so far have all been planar mechanisms. We now extend this to a 3-dimensional system, the Furuta pendulum.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This pendulum, sometimes referred to as a rotary pendulum, has two joints, one in the \"shoulder\", which is typically configured to rotate around the gravitational axis, and one in the \"elbow\", which is typically configured to rotate around the axis of the upper arm. The upper arm is attached to the shoulder joint, and the lower arm is attached to the elbow joint. The tip of the pendulum is attached to the lower arm.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using ModelingToolkit, Multibody, JuliaSimCompiler, OrdinaryDiffEq, Plots\nimport ModelingToolkitStandardLibrary.Mechanical.Rotational.Damper as RDamper\nimport Multibody.Rotations\nW(args...; kwargs...) = Multibody.world\n\n@mtkmodel FurutaPendulum begin\n    @components begin\n        world = W()\n        shoulder_joint = Revolute(n = [0, 1, 0], axisflange = true)\n        elbow_joint    = Revolute(n = [0, 0, 1], axisflange = true, phi0=0.1)\n        upper_arm = BodyShape(; m = 0.1, r = [0, 0, 0.6], radius=0.04)\n        lower_arm = BodyShape(; m = 0.1, r = [0, 0.6, 0], radius=0.04)\n        tip = Body(; m = 0.3)\n\n        damper1 = RDamper(d = 0.07)\n        damper2 = RDamper(d = 0.07)\n    end\n    @equations begin\n        connect(world.frame_b, shoulder_joint.frame_a)\n        connect(shoulder_joint.frame_b, upper_arm.frame_a)\n        connect(upper_arm.frame_b, elbow_joint.frame_a)\n        connect(elbow_joint.frame_b, lower_arm.frame_a)\n        connect(lower_arm.frame_b, tip.frame_a)\n\n        connect(shoulder_joint.axis, damper1.flange_a)\n        connect(shoulder_joint.support, damper1.flange_b)\n\n        connect(elbow_joint.axis, damper2.flange_a)\n        connect(elbow_joint.support, damper2.flange_b)\n\n    end\nend\n\n@named model = FurutaPendulum()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [model.shoulder_joint.phi => 0.0, model.elbow_joint.phi => 0.1], (0, 10))\nsol = solve(prob, Rodas4())\nplot(sol, layout=4)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"In the animation below, we visualize the path that the origin of the pendulum tip traces by providing the tip frame in a vector of frames passed to traces","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"import GLMakie\nMultibody.render(model, sol, filename = \"furuta.gif\", traces=[model.tip.frame_a])\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"(Image: furuta)","category":"page"},{"location":"examples/pendulum/#Orientations-and-directions","page":"Getting started: Pendulum","title":"Orientations and directions","text":"","category":"section"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Let's break down how to think about directions and orientations when building 3D mechanisms. In the example above, we started with the shoulder joint, this joint rotated around the gravitational axis, n = [0, 1, 0]. When this joint is positioned in joint coordinate shoulder_joint.phi = 0, its frame_a and frame_b will coincide. When the joint rotates, frame_b will rotate around the axis n of frame_a. The frame_a of the joint is attached to the world, so the joint will rotate around the world's y-axis:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_rot(sol, model.shoulder_joint.frame_b, 0)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"we see that at time t = 0, we have no rotation of frame_b around the y axis of the world (frames are always resolved in the world frame), but a second into the simulation, we have:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"R1 = get_rot(sol, model.shoulder_joint.frame_b, 1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Here, the frame_b has rotated around the y axis of the world (if you are not familiar with rotation matrices, we can ask for the rotation axis and angle)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using Multibody.Rotations\nrotation_axis(R1), rotation_angle(R1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"This rotation axis and angle should correspond to the joint coordinate (the orientation described by an axis and an angle is invariant to a multiplication of both by -1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"sol(1, idxs=model.shoulder_joint.phi)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"note: Convention\nThe convention used in get_rot is to return the rotation matrix R_World^Local that rotates a coordinate from the local frame to the world frame, r_World = R_World^Local r_Local.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Here, we made use of the function get_rot, we will now make use of also get_trans and get_frame.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The next body is the upper arm. This body has an extent of 0.6 in the z direction, as measured in its local frame_a","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_trans(sol, model.upper_arm.frame_b, 0)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"One second into the simulation, the upper arm has rotated around the y axis of the world","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"rb1 = get_trans(sol, model.upper_arm.frame_b, 1)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"If we look at the variable model.upper_arm.r, we do not see this rotation!","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"arm_r = sol(1, idxs=collect(model.upper_arm.r))","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The reason is that this variable is resolved in the local frame_a and not in the world frame. To transform this variable to the world frame, we may multiply with the rotation matrix of frame_a which is always resolved in the world frame:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_rot(sol, model.upper_arm.frame_a, 1)*arm_r","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"We now get the same result has when we asked for the translation vector of frame_b above.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"using Test # hide\nget_rot(sol, model.upper_arm.frame_a, 1)*arm_r ≈ rb1 # hide\nnothing # hide","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"Slightly more formally, let R_A^B denote the rotation matrix that rotates a vector expressed in a frame A into one that is expressed in frame B, i.e., r_B = R_B^A r_A. We have then just performed the transformation r_W = R_W^A r_A, where W denotes the world frame, and A denotes body.frame_a.","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The next joint, the elbow joint, has the rotational axis n = [0, 0, 1]. This indicates that the joint rotates around the z-axis of its frame_a. Since the upper arm was oriented along the z direction, the joint is rotating around the axis that coincides with the upper arm. ","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The lower arm is finally having an extent along the y-axis. At the final time when the pendulum motion has been fully damped, we see that the second frame of this body ends up with an y-coordinate of -0.6:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_trans(sol, model.lower_arm.frame_b, 12)","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"If we rotate the vector of extent of the lower arm to the world frame, we indeed see that the only coordinate that is nonzero is the y coordinate:","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"get_rot(sol, model.lower_arm.frame_a, 12)*sol(12, idxs=collect(model.lower_arm.r))","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"The reason that the latter vector differs from get_trans(sol, model.lower_arm.frame_b, 12) above is that get_trans(sol, model.lower_arm.frame_b, 12) has been translated as well. To both translate and rotate model.lower_arm.r into the world frame, we must use the full transformation matrix T_W^A in SE(3):","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"r_A = sol(12, idxs=collect(model.lower_arm.r))\nr_A = [r_A; 1] # Homogeneous coordinates\n\nget_frame(sol, model.lower_arm.frame_a, 12)*r_A","category":"page"},{"location":"examples/pendulum/","page":"Getting started: Pendulum","title":"Getting started: Pendulum","text":"the vector is now coinciding with get_trans(sol, model.lower_arm.frame_b, 12).","category":"page"},{"location":"examples/wheel/#Wheels","page":"Wheels","title":"Wheels","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"When modeling wheels, there are several different assumptions that can be made, such as","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"Is the wheel able to leave the ground or not?\nCan the wheel slip or does it roll perfectly?","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"The wheel-related components available are","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"RollingWheel: a wheel that can roll on the ground. It cannot slip and it cannot leave the ground.\nRollingWheelJoint: a lower-level component used in RollingWheel to model the kinematics of the wheel, without inertial or mass properties.\nRollingWheelSet: a set of two wheels connected by an axis. One of the wheels cannot slip, while the other one slips as required to allow the wheel set to turn (no differential is modeled). No wheel can leave the ground.\nRollingWheelSetJoint: A lower-level component used in RollingWheelSet to model the kinematics of the wheel set, without inertial or mass properties.\nRollingConstraintVerticalWheel: A low-level constraint that is used to enforce a perfectly rolling wheel that is always vertical, i.e., it can only roll forward and not fall down.\nPlanarMechanics.SimpleWheel: A 2D wheel component with a simple, linear lateral slip model.\nPlanarMechanics.SlipBasedWheelJoint: A more advanced 2D wheel component with slip-dependent friction characteristics.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"All wheel components are limited to rolling on the xz plane, i.e., the gravity direction must be the default [0, -1, 0].","category":"page"},{"location":"examples/wheel/#Rolling-wheel","page":"Wheels","title":"Rolling wheel","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"using Multibody\nusing ModelingToolkit\nimport ModelingToolkitStandardLibrary.Mechanical.Rotational\nimport ModelingToolkitStandardLibrary.Blocks\nusing Plots\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing JuliaSimCompiler\nusing Test\n\nt = Multibody.t\nD = Differential(t)\nW(args...; kwargs...) = Multibody.world\n\n@mtkmodel WheelInWorld begin\n    @components begin\n        world = W()\n        wheel = RollingWheel(\n            radius = 0.3,\n            m = 2,\n            I_axis = 0.06,\n            I_long = 0.12,\n            x0 = 0.2,\n            z0 = 0.2,\n            der_angles = [0, 5, 1],\n        )\n    end\nend\n\n@named worldwheel = WheelInWorld()\nworldwheel = complete(worldwheel)\n\ndefs = Dict([\n    worldwheel.wheel.body.r_0[1] => 0.2;\n    worldwheel.wheel.body.r_0[2] => 0.3;\n    worldwheel.wheel.body.r_0[3] => 0.2;\n])\n\nssys = structural_simplify(IRSystem(worldwheel))\nprob = ODEProblem(ssys, defs, (0, 4))\nsol = solve(prob, Tsit5())\n@test SciMLBase.successful_retcode(sol)","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"import GLMakie\nMultibody.render(worldwheel, sol; filename = \"worldwheel.gif\")\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: wheel animation)","category":"page"},{"location":"examples/wheel/#Add-slip","page":"Wheels","title":"Add slip","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"The example below is similar to that above, but models a wheel with slip properties instead of ideal rolling.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"@mtkmodel SlipWheelInWorld begin\n    @components begin\n        world = W()\n        wheel = SlippingWheel(\n            radius = 0.3,\n            m = 2,\n            I_axis = 0.06,\n            I_long = 0.12,\n            x0 = 0.2,\n            z0 = 0.2,\n            der_angles = [0, 25, 0.1],\n\n            mu_A = 0.95,             # Friction coefficient at adhesion\n            mu_S = 0.5,             # Friction coefficient at sliding\n            sAdhesion = 0.04,       # Adhesion slippage\n            sSlide = 0.12,          # Sliding slippage\n            vAdhesion_min = 0.05,   # Minimum adhesion velocity\n            vSlide_min = 0.15,      # Minimum sliding velocity\n        )\n    end\nend\n\n@named worldwheel = SlipWheelInWorld()\nworldwheel = complete(worldwheel)\n\ndefs = Dict([\n    worldwheel.wheel.body.r_0[1] => 0.2;\n    worldwheel.wheel.body.r_0[2] => 0.3;\n    worldwheel.wheel.body.r_0[3] => 0.2;\n    worldwheel.wheel.frame_a.render => true;\n    worldwheel.wheel.frame_a.length => 0.4;\n    worldwheel.wheel.frame_a.radius => 0.01;\n])\n\nssys = structural_simplify(IRSystem(worldwheel))\nprob = ODEProblem(ssys, defs, (0, 3))\nsol = solve(prob, Tsit5())\n@test SciMLBase.successful_retcode(sol)","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"Multibody.render(worldwheel, sol; filename = \"slipping_worldwheel.gif\", x=4, z=2, time_scale=3)\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: slipping wheel animation)","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"Notice how the wheel starts out with zero linear velocity but large rotational velocity, causing it to initially slip before picking up speed and gaining traction.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"In this animation, we render also the connector frame of the wheel to make it easier to see that the wheel is spinning.","category":"page"},{"location":"examples/wheel/#Wheel-set","page":"Wheels","title":"Wheel set","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"A RollingWheelSet is comprised out of two wheels mounted on a common axis through their axis of rotation. ","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"@mtkmodel DrivingWheelSet begin\n    @components begin\n        sine1 = Blocks.Sine(frequency=1, amplitude=2)\n        sine2 = Blocks.Sine(frequency=1, amplitude=2, phase=pi/2)\n        torque1 = Rotational.Torque()\n        torque2 = Rotational.Torque()\n        wheels = RollingWheelSet(radius=0.1, m_wheel=0.5, I_axis=0.01, I_long=0.02, track=0.5, state_priority=100)\n        bar = FixedTranslation(r = [0.2, 0, 0])\n        body = Body(m=0.01, state_priority=1)\n        world = W()\n    end\n    @equations begin\n        connect(sine1.output, torque1.tau)\n        connect(sine2.output, torque2.tau)\n        connect(torque1.flange, wheels.axis1)\n        connect(torque2.flange, wheels.axis2)\n        connect(wheels.frame_middle, bar.frame_a)\n        connect(bar.frame_b, body.frame_a)\n    end\nend\n\n@named model = DrivingWheelSet()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n# display(unknowns(ssys))\nprob = ODEProblem(ssys, [\n    model.wheels.wheelSetJoint.prismatic1.s => 0.1\n    model.wheels.wheelSetJoint.prismatic2.s => 0.1\n], (0, 3))\nsol = solve(prob, Tsit5())\n@test SciMLBase.successful_retcode(sol)","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"import GLMakie\nMultibody.render(model, sol; filename = \"wheelset.gif\")\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: wheelset animation)","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"The RollingWheelSet includes constraints that prevent the wheels from leaving the ground and the connector frame_middle from rotating around the wheel axis. This means that if two wheel sets are connected to the same body, the system will be over constrained. To solve this, pass iscut = true to one of the wheel sets, like below:","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"wheel_mass = 15\nI_axis=0.01\nI_long=0.02\nwheel_d = 2\nwheel_radius = 0.25\ntire_black = [0.1, 0.1, 0.1, 1]\n\n@mtkmodel Car begin\n    @structural_parameters begin\n        l=4\n        m=108\n    end\n    @parameters begin\n        I=10\n        g=0\n    end\n    @components begin\n        world = W()\n\n        sine1 = Blocks.Sine(frequency=1, amplitude=150)\n        sine2 = Blocks.Sine(frequency=1, amplitude=150, phase=pi/6)\n        torque1 = Rotational.Torque()\n        torque2 = Rotational.Torque()\n        front_wheels = RollingWheelSet(radius=wheel_radius, m_wheel=wheel_mass, I_axis, I_long, track=wheel_d)\n        rear_wheels = RollingWheelSet(radius=wheel_radius, m_wheel=wheel_mass, I_axis, I_long, track=wheel_d, iscut=true)\n\n        steering_joint = Revolute(n = [0,1,0], axisflange=true, state_priority=100)\n        prefer_straight_ahead = Rotational.SpringDamper(d=10, c=10)\n\n        body = BodyShape(; m, r = [l, 0, 0], I_22 = I, radius=0.3)\n    end\n    @equations begin\n        connect(sine1.output, torque1.tau)\n        connect(sine2.output, torque2.tau)\n        connect(torque1.flange, front_wheels.axis1)\n        connect(torque2.flange, front_wheels.axis2)\n        connect(front_wheels.frame_middle, steering_joint.frame_a)\n\n        connect(steering_joint.frame_b, body.frame_a)        \n        connect(rear_wheels.frame_middle, body.frame_b)\n\n        connect(prefer_straight_ahead.flange_a, steering_joint.axis)\n        connect(prefer_straight_ahead.flange_b, steering_joint.support)\n    end\nend\n@named model = Car()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [], (0, 6))\nsol = solve(prob, Tsit5())\n\nrender(model, sol, framerate=30, filename=\"car.gif\", x=6, z=6, y=5)\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: car animation)","category":"page"},{"location":"examples/wheel/#Simple-planar-wheel","page":"Wheels","title":"Simple planar wheel","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"This example demonstrates how we can model a simple single-track vehicle with planar (2D or 3DOF) components. ","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"We will use the component PlanarMechanics.SimpleWheel, together with a PlanarMechanics.Revolute joint to connect the front wheel to the PlanarMechanics.BodyShape representing the vehicle body. The revolute joint is used for steering.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"import Multibody.PlanarMechanics as Pl\n\n@mtkmodel TestWheel begin\n    @components begin\n        body = Pl.BodyShape(r = [1.0, 0.0], m=1, I=0.1, gy=0)\n        revolute = Pl.Revolute()\n        wheel1 = Pl.SimpleWheel(color=tire_black)\n        wheel2 = Pl.SimpleWheel(color=tire_black, μ=.5)\n        thrust_input1 = Blocks.Constant(k=1)\n        thrust_input2 = Blocks.Constant(k=0)\n    end\n    @equations begin\n        connect(body.frame_a, revolute.frame_a)\n        connect(revolute.frame_b, wheel1.frame_a)\n        connect(thrust_input1.output, wheel1.thrust)\n        connect(thrust_input2.output, wheel2.thrust)\n        revolute.phi ~ deg2rad(50)*sin(2pi*0.2*t)\n\n        connect(wheel2.frame_a, body.frame_b)\n    end\nend\n@named model = TestWheel()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\ndefs = Dict(unknowns(ssys) .=> 0)\nprob = ODEProblem(ssys, defs, (0.0, 10.0))\nsol = solve(prob, Rodas5P())\n@test SciMLBase.successful_retcode(sol)\nrender(model, sol, show_axis=true, x=1, y=-1.8, z=5, lookat=[1,-1.8,0], traces=[model.wheel1.frame_a, model.wheel2.frame_a], filename=\"drifting.gif\")","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: drifting animation)","category":"page"},{"location":"examples/wheel/#Slip-based-planar-wheel","page":"Wheels","title":"Slip-based planar wheel","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"This example demonstrates use of the PlanarMechanics.SlipBasedWheelJoint component, which is a more advanced 2D wheel component with slip-dependent friction characteristics. The wheel is being driven by a constant torque, and is connected through a PlanarMechanics.Prismatic joint to a PlanarMechanics.Revolute joint. This forces the wheel to move in a circular arc around the revolute pivot point, and spiral outwards due to slip. A `PlanarMechanics.Body attached to the end of the prismatic joint is used to add inertial properties.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"using Multibody\nusing ModelingToolkit\nimport ModelingToolkitStandardLibrary.Mechanical.Rotational\nimport ModelingToolkitStandardLibrary.Blocks\nimport Multibody.PlanarMechanics as Pl\nusing Plots\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing JuliaSimCompiler\nusing Test\n\nt = Multibody.t\nD = Differential(t)\ntire_black = [0.1, 0.1, 0.1, 1]\n\n@mtkmodel TestSlipBasedWheel begin\n    @components begin\n        slipBasedWheelJoint = Pl.SlipBasedWheelJoint(\n            radius = 0.3,\n            r = [1,0],              # Driving direction at angle phi = 0\n            mu_A = 0.8,             # Friction coefficient at adhesion\n            mu_S = 0.4,             # Friction coefficient at sliding\n            N = 100,                # Base normal load\n            sAdhesion = 0.04,       # Adhesion slippage\n            sSlide = 0.12,          # Sliding slippage\n            vAdhesion_min = 0.05,   # Minimum adhesion velocity\n            vSlide_min = 0.15,      # Minimum sliding velocity\n            color = tire_black,\n        )\n        prismatic = Pl.Prismatic(r = [0,1], s = 1, v = 0)\n        revolute = Pl.Revolute(phi = 0, w = 0)\n        fixed = Pl.Fixed()\n        engineTorque = Rotational.ConstantTorque(tau_constant = 2)\n        body = Pl.Body(m = 10, I = 1, gy=0, phi=0, w=0)\n        inertia = Rotational.Inertia(J = 1, phi = 0, w = 0)\n        constant = Blocks.Constant(k = 0)\n    end\n    @equations begin\n        connect(fixed.frame_b, revolute.frame_a)\n        connect(revolute.frame_b, prismatic.frame_a)\n        connect(prismatic.frame_b, body.frame_a)\n        connect(prismatic.frame_b, slipBasedWheelJoint.frame_a)\n        connect(slipBasedWheelJoint.flange_a, inertia.flange_b)\n        connect(constant.output, slipBasedWheelJoint.dynamicLoad)\n        connect(engineTorque.flange, inertia.flange_a)\n    end\nend\n\n@named model = TestSlipBasedWheel()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\ndisplay(unknowns(ssys))\ndefs = ModelingToolkit.defaults(model)\nprob = ODEProblem(ssys, [\n    model.inertia.w => 1e-10, # This is important, at zero velocity, the friction is ill-defined\n    model.revolute.frame_b.phi => 0,\n    model.body.w => 0,\n    D(model.revolute.frame_b.phi) => 0,\n    D(model.prismatic.r0[2]) => 0,\n], (0.0, 15.0))\nsol = solve(prob, Rodas5Pr())\nrender(model, sol, show_axis=false, x=0, y=0, z=4, traces=[model.slipBasedWheelJoint.frame_a], filename=\"slipwheel.gif\")\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: slipwheel animation)","category":"page"},{"location":"examples/wheel/#Planar-two-track-model","page":"Wheels","title":"Planar two-track model","text":"","category":"section"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"A more elaborate example with 4 wheels.","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"@mtkmodel TwoTrackWithDifferentialGear begin\n    @components begin\n        body = Pl.Body(m = 100, I = 1, gy = 0)\n        body1 = Pl.Body(m = 300, I = 0.1, r = [1, 1], v = [0, 0], phi = 0, w = 0, gy = 0,)\n        body2 = Pl.Body(m = 100, I = 1, gy = 0,)\n        wheelJoint1 = Pl.SlipBasedWheelJoint(\n            radius = 0.25,\n            r = [0, 1],\n            mu_A = 1,\n            mu_S = 0.7,\n            N = 1000,\n            sAdhesion = 0.04,\n            sSlide = 0.12,\n            vAdhesion_min = 0.05,\n            vSlide_min = 0.15,\n            phi_roll = 0)\n        wheelJoint2 = Pl.SlipBasedWheelJoint(\n            radius = 0.25,\n            r = [0, 1],\n            mu_A = 1,\n            mu_S = 0.7,\n            N = 1500,\n            sAdhesion = 0.04,\n            sSlide = 0.12,\n            vAdhesion_min = 0.05,\n            vSlide_min = 0.15,\n            phi_roll = 0)\n        wheelJoint3 = Pl.SlipBasedWheelJoint(\n            radius = 0.25,\n            r = [0, 1],\n            mu_A = 1,\n            mu_S = 0.7,\n            N = 1500,\n            sAdhesion = 0.04,\n            sSlide = 0.12,\n            vAdhesion_min = 0.05,\n            vSlide_min = 0.15,\n            phi_roll = 0)\n        wheelJoint4 = Pl.SlipBasedWheelJoint(\n            radius = 0.25,\n            r = [0, 1],\n            mu_A = 1,\n            mu_S = 0.7,\n            N = 1000,\n            sAdhesion = 0.04,\n            sSlide = 0.12,\n            vAdhesion_min = 0.05,\n            vSlide_min = 0.15,\n            phi_roll = 0)\n        differentialGear = Pl.DifferentialGear()\n        pulse = Blocks.Square(frequency = 1/2, offset = 0, start_time = 1, amplitude = -2)\n        torque = Rotational.Torque()\n        constantTorque1 = Rotational.ConstantTorque(tau_constant = 25)\n        inertia = Rotational.Inertia(J = 1, phi = 0, w = 0)\n        inertia1 = Rotational.Inertia(J = 1, phi = 0, w = 0)\n        inertia2 = Rotational.Inertia(J = 1, phi = 0, w = 0)\n        inertia3 = Rotational.Inertia(J = 1, phi = 0, w = 0)\n        fixedTranslation1 = Pl.FixedTranslation(r = [0, 2])\n        fixedTranslation2 = Pl.FixedTranslation(r = [0.75, 0])\n        fixedTranslation3 = Pl.FixedTranslation(r = [-0.75, 0])\n        fixedTranslation4 = Pl.FixedTranslation(r = [0.75, 0])\n        fixedTranslation5 = Pl.FixedTranslation(r = [-0.75, 0])\n        leftTrail = Pl.FixedTranslation(r = [0, -0.05])\n        rightTrail = Pl.FixedTranslation(r = [0, -0.05])\n        revolute = Pl.Revolute(axisflange=true)\n        revolute2 = Pl.Revolute(axisflange=true, phi = -0.43633231299858, w = 0)\n        dynamic_load = Blocks.Constant(k=0)\n    end\n\n\n    @equations begin\n        connect(wheelJoint2.flange_a, inertia1.flange_b)\n        connect(inertia.flange_b, wheelJoint1.flange_a)\n        connect(fixedTranslation2.frame_b, fixedTranslation1.frame_a)\n        connect(fixedTranslation2.frame_a, wheelJoint2.frame_a)\n        connect(fixedTranslation3.frame_b, fixedTranslation1.frame_a)\n        connect(wheelJoint3.frame_a, fixedTranslation3.frame_a)\n        connect(inertia2.flange_b, wheelJoint3.flange_a)\n        connect(body1.frame_a, fixedTranslation1.frame_a)\n        connect(fixedTranslation1.frame_b, fixedTranslation4.frame_b)\n        connect(fixedTranslation1.frame_b, fixedTranslation5.frame_b)\n        connect(inertia3.flange_b, wheelJoint4.flange_a)\n        connect(pulse.output, torque.tau)\n        connect(differentialGear.flange_right, wheelJoint3.flange_a)\n        connect(differentialGear.flange_left, wheelJoint2.flange_a)\n        connect(constantTorque1.flange, differentialGear.flange_b)\n        connect(body.frame_a, leftTrail.frame_b)\n        connect(leftTrail.frame_b, wheelJoint1.frame_a)\n        connect(body2.frame_a, rightTrail.frame_b)\n        connect(wheelJoint4.frame_a, rightTrail.frame_b)\n        connect(leftTrail.frame_a, revolute2.frame_a)\n        connect(revolute2.frame_b, fixedTranslation4.frame_a)\n        connect(torque.flange, revolute.flange_a, revolute2.flange_a)\n        connect(revolute.frame_a, rightTrail.frame_a)\n        connect(revolute.frame_b, fixedTranslation5.frame_a)\n        connect(dynamic_load.output, wheelJoint1.dynamicLoad, wheelJoint2.dynamicLoad, wheelJoint3.dynamicLoad, wheelJoint4.dynamicLoad)\n    end\nend\n\n@named model = TwoTrackWithDifferentialGear()\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\ndefs = merge(\n    Dict(unknowns(ssys) .=> 0),\n    ModelingToolkit.defaults(model),\n    Dict(model.body.w => 0),\n)\nprob = ODEProblem(ssys, defs, (0.0, 5.0))\nsol = solve(prob, Rodas5P(autodiff=false))\n@test SciMLBase.successful_retcode(sol)\nMultibody.render(model, sol, show_axis=false, x=0, y=0, z=5, filename=\"twotrack.gif\")\nnothing # hide","category":"page"},{"location":"examples/wheel/","page":"Wheels","title":"Wheels","text":"(Image: twotrack animation) ```","category":"page"},{"location":"rendering/#3D-rendering-and-animations","page":"3D rendering","title":"3D rendering and animations","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"Multibody.jl has an automatic 3D-rendering feature that draws a mechanism in 3D. This can be used to create animations of the mechanism's motion from a solution trajectory, as well as to create interactive applications where the evolution of time can be controlled by the user.","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"The functionality requires the user to install and load one of the Makie backend packages, e.g., ","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"using GLMakie # Preferred","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"or ","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"using CairoMakie","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"note: Backend choice\nGLMakie and WGLMakie produce much nicer-looking animations and are also significantly faster than CairoMakie. CairoMakie may be used to produce the graphics in some web environments if constraints imposed by the web environment do not allow any of the GL alternatives. CairoMakie struggles with the Z-order of drawn objects, sometimes making bodies that should have been visible hidden behind bodies that are further back in the scene.","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"After that, the render function is the main entry point to create 3D renderings. This function has the following methods:","category":"page"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"render(model, prob::ODEProblem): this method creates an interactive figure corresponding to the mechanisms configuration at the specified initial condition.\nrender(model, solution): this method creates an animation corresponding to the mechanisms evolution in a simulation trajectory.\nscene, time = render(model, solution, t::Real): this method opens an interactive window with the mechanism in the configuration corresponding to the time t. Display scene to display the interactive window, and change the time by either dragging the slider in the window, or write to the observable time[] = new_time.","category":"page"},{"location":"rendering/#Colors","page":"3D rendering","title":"Colors","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"Many components allows the user to select with which color it is rendered. This choice is made by providing a 4-element array with color values in the order (RGBA), where each value is between 0 and 1. The last value is the alpha channel which determines the opacity, i.e., 1 is opaque and 0 is invisible.","category":"page"},{"location":"rendering/#Rendering-the-world-frame","page":"3D rendering","title":"Rendering the world frame","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"The display of the world frame can be turned off by setting world.render => false in the variable map.","category":"page"},{"location":"rendering/#Tracing-the-path-of-a-frame-in-3D-visualizations","page":"3D rendering","title":"Tracing the path of a frame in 3D visualizations","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"The path that a frame traces out during simulation can be visualized by passing a vector of frames to the render function using the traces keyword, e.g., render(..., traces=[frame1, frame2]). See the Furuta-pendulum demonstration Going 3D for an example of this.","category":"page"},{"location":"rendering/#Camera-controls","page":"3D rendering","title":"Camera controls","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"The camera controls are inherited from Makie, see their documentation for more information. Of particular interest may be the keyboard shortcuts x, y, z, by holding one of these keys and dragging the mouse, the camera will rotate around the corresponding axis. Use keyword argument show_axis = true to function render or pass parameter world.render => true to ODEProblem to display plot axes and/or world axes in the plot.","category":"page"},{"location":"rendering/#Rendering-API","page":"3D rendering","title":"Rendering API","text":"","category":"section"},{"location":"rendering/","page":"3D rendering","title":"3D rendering","text":"render\nrender!","category":"page"},{"location":"rendering/#Multibody.render","page":"3D rendering","title":"Multibody.render","text":"scene, time = render(model, sol, t::Real; framerate = 30, traces = [])\npath        = render(model, sol, timevec = range(sol.t[1], sol.t[end], step = 1 / framerate); framerate = 30, timescale=1, display=false, loop=1)\n\nCreate a 3D animation of a multibody system\n\nArguments:\n\nmodel: The unsimplified multibody model, i.e., this is the model before any call to structural_simplify.\nsol: The ODESolution produced by simulating the system using solve\nt: If a single number t is provided, the mechanism at this time is rendered and a scene is returned together with the time as an Observable. Modify time[] = new_time to change the rendering.\ntimevec: If a vector of times is provided, an animation is created and the path to the file on disk is returned.\nframerate: Number of frames per second.\ntimescale: Scaling of the time vector. This argument can be made to speed up animations (timescale < 1) or slow them down (timescale > 1). A value of timescale = 2 will be 2x slower than real time.\nloop: The animation will be looped this many times. Please note: looping the animation using this argument is only recommended when display = true for camera manipulation purposes. When the camera is not manipulated, looping the animation by other means is recommended to avoid an increase in the file size.\nfilename controls the name and the file type of the resulting animation\ntraces: An optional array of frames to show the trace of.\nshow_axis = false: Whether or not to show the plot axes, including background grid.\n\nCamera control\n\nThe following keyword arguments are available to control the camera pose:\n\nx = 2\ny = 0.5\nz = 2\nlookat = [0,0,0]: a three-vector of coordinates indicating the point at which the camera looks.\nup = [0,1,0]: A vector indicating the direction that is up.\ndisplay: if true, the figure will be displayed during the recording process and time will advance in real-time. This allows the user to manipulate the camera options using the mouse during the recording.\n\nSee also loop_render\n\n\n\n\n\n","category":"function"},{"location":"rendering/#Multibody.render!","page":"3D rendering","title":"Multibody.render!","text":"did_render::Bool = render!(scene, ::typeof(ComponentConstructor), sys, sol, t)\n\nEach component that can be rendered must have a render! method. This method is called by render for each component in the system.\n\nThis method is responsible for drawing the component onto the scene the way it's supposed to look at time t in the solution sol. t is an Observable. It's recommended to follow the pattern\n\nthing = @lift begin\n    acces relevant coordinates from sol at time t\n    create a geometric object that can be rendered\nend\nmesh!(scene, thing; style...)\n\nReturns\n\nA boolean indicating whether or not the component performed any rendering. Typically, all custom methods of this function should return true, while the default fallback method is the only one returning false.\n\n\n\n\n\n","category":"function"},{"location":"examples/kinematic_loops/#Modeling-kinematic-loops","page":"Kinematic loops","title":"Modeling kinematic loops","text":"","category":"section"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Kinematic loops can be difficult to simulate since they introduce an over-constrained system. This tutorial demonstrates how to handle a few common cases of kinematic loops.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Common for every kinematic loop is that the modeler must handle the redundant equations introduced by closing the loop. There are three main ways of doing this, listed in their general order of preference:","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Use a joint assembly, a component that combines several joints and solves the nonlinear equations analytically.\nUse a joint constraint rather than a joint (sometimes called and implicit joint).\nUse a regular joint with the option iscut = true to indicate that the joint is a cut joint.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Joint assemblies offer the possibility to analytically solve one or several nonlinear algebraic equations, such that the solver does not have to solve them with iterative methods. This generally provides a much faster simulation. Joint assemblies are components that consists of several joints with rigid bodies in between, such as SphericalSpherical and UniversalSpherical.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Joint constraints work more or less like regular joints, but do not have state variables. In a kinematic loop, one joint may be changed to a joint constraint in order to simplify the nonlinear algebraic equations.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"If no joint assembly or constraint that simplify the loop is available, one joint in each loop must be marked as iscut = true. This indicates that the loop is closed using a smaller number of residual equations rather than the full number of orientation constraints implied by equality between rotation matrices.","category":"page"},{"location":"examples/kinematic_loops/#A-planar-kinematic-loop","page":"Kinematic loops","title":"A planar kinematic loop","text":"","category":"section"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"A planar loop is one where the loop is confined to a plane, i.e., all joints in the loop have parallel rotation axes. To simulate a mechanism with such a loop, we break the kinematic loop by replacing one of the revolute joints with a RevolutePlanarLoopConstraint. The reason is that, e.g., the cut forces in direction of the axes of the revolute joints cannot be uniquely computed. The model below contains four bars connected by revolute joints, forming a planar loop. In order to make the animation interesting, we attach dampers to two of the joints such that the mechanism will oscillate for a while before coming to rest.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Perhaps surprisingly, we use 5 joints in total for this mechanism. If we had used four joints only and connected the first frame of the first joint to the world, the mechanism would not be free to rotate around the world frame. We thus have two joints connected to the world frame below. Exactly one revolute joint is changed into a RevolutePlanarLoopConstraint to break the planar loop.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"using Multibody\nusing ModelingToolkit\nimport ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing Plots\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing JuliaSimCompiler\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nl = 1.5\nsystems = @named begin\n    j1 = Revolute(axisflange=true) # We use an axis flange to attach a damper\n    j2 = Revolute(axisflange=true)\n    j3 = Revolute()\n    j4 = RevolutePlanarLoopConstraint()\n    j5 = Revolute()\n    b1 = BodyShape(m=1, r = [l, 0, 0], radius=0.03)\n    b2 = BodyShape(m=1, r = [0.0, l, 0], radius=0.03)\n    b3 = BodyShape(m=1, r = [-l, 0, 0], radius=0.03)\n    b4 = BodyShape(m=1, r = [0.0, -l, 0], radius=0.03)\n    damper1 = Rotational.Damper(d=0.1)\n    damper2 = Rotational.Damper(d=0.1)\nend\n\nconnections = [\n    connect(world.frame_b, j1.frame_a)\n    \n    connect(j1.frame_b, b1.frame_a)\n    connect(b1.frame_b, j2.frame_a)\n    connect(j2.frame_b, b2.frame_a)\n    connect(b2.frame_b, j3.frame_a)\n    connect(j3.frame_b, b3.frame_a)\n    connect(b3.frame_b, j4.frame_a)\n    \n    connect(j4.frame_b, b4.frame_a)\n    \n    connect(b4.frame_b, j5.frame_a)\n    connect(j5.frame_b, world.frame_b) \n    # We need 5 joints since j1.frame_a is rigidly attached to the world, and b4 closing the loop would thus not be able to rotate around j1.\n\n    connect(j1.axis, damper1.flange_a)\n    connect(j1.support, damper1.flange_b)\n\n    connect(j2.axis, damper2.flange_a)\n    connect(j2.support, damper2.flange_b)\n    \n]\n@named fourbar = ODESystem(connections, t, systems = [world; systems])\nfourbar = complete(fourbar)\nssys = structural_simplify(IRSystem(fourbar))\nprob = ODEProblem(ssys, [fourbar.j1.phi => 0.1], (0.0, 10.0))\nsol = solve(prob, FBDF(autodiff=true))\n\nplot(\n    plot(sol, idxs = [j1.phi, j2.phi, j3.phi]),\n    plot(sol, idxs = [j1.w, j2.w, j3.w]),\n)","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"using Test\n@test SciMLBase.successful_retcode(sol)","category":"page"},{"location":"examples/kinematic_loops/#3D-animation","page":"Kinematic loops","title":"3D animation","text":"","category":"section"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"import GLMakie\nMultibody.render(fourbar, sol, 0:0.05:10; x=4, y=-1, z=4, lookat=[0, -1, 0], filename = \"fourbar.gif\") # Use \"fourbar.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"(Image: animation)","category":"page"},{"location":"examples/kinematic_loops/#Using-cut-joints","page":"Kinematic loops","title":"Using cut joints","text":"","category":"section"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"The mechanism below is another instance of a 4-bar linkage, this time with 6 revolute joints, 1 prismatic joint and 4 bodies.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"We show two different ways of modeling this mechanism, first using a cut joint, and later using a much more efficient joint assembly.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"In order to simulate this mechanism using a cut joint, the user must","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"Use the iscut=true keyword argument to one of the Revolute joints to indicate that the joint is a cut joint. A cut joint behaves similarly to a regular joint, but it introduces fewer constraints in order to avoid the otherwise over-constrained system resulting from closing the kinematic loop. While almost any joint can be chosen as the cut joint, it might be worthwhile experimenting with this choice in order to get an efficient representation. In this example, cutting j5 produces an 8-dimensional state realization, while all other joints result in a 17-dimensional state.\nIncrease the state_priority of the joint j1 above the default joint priority 3. This encourages the model compiler to choose the joint coordinate of j1 as state variable. The joint coordinate of j1 is the only coordinate that uniquely determines the configuration of the mechanism. The choice of any other joint coordinate would lead to a singular representation in at least one configuration of the mechanism. The joint j1 is the revolute joint located in the origin, see the animation below where this joint is made larger than the others.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"To drive the mechanism, we set the initial velocity of the joint j1 to some non-zero value.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"systems = @named begin\n    j1 = Revolute(n = [1, 0, 0], w0 = 5.235987755982989, state_priority=10.0, radius=0.1f0) # Increase state priority to ensure that this joint coordinate is chosen as state variable\n    j2 = Prismatic(n = [1, 0, 0], s0 = -0.2)\n    b1 = BodyShape(r = [0, 0.5, 0.1], radius=0.03)\n    b2 = BodyShape(r = [0, 0.2, 0], radius=0.03)\n    b3 = BodyShape(r = [-1, 0.3, 0.1], radius=0.03)\n    rev = Revolute(n = [0, 1, 0])\n    rev1 = Revolute()\n    j3 = Revolute(n = [1, 0, 0])\n    j4 = Revolute(n = [0, 1, 0])\n    j5 = Revolute(n = [0, 0, 1], iscut=true)\n    b0 = FixedTranslation(r = [1.2, 0, 0], radius=0)\nend\n\nconnections = [connect(j2.frame_b, b2.frame_a)\n               connect(j1.frame_b, b1.frame_a)\n               connect(rev.frame_a, b2.frame_b)\n               connect(rev.frame_b, rev1.frame_a)\n               connect(rev1.frame_b, b3.frame_a)\n               connect(world.frame_b, j1.frame_a)\n               connect(b1.frame_b, j3.frame_a)\n               connect(j3.frame_b, j4.frame_a)\n               connect(j4.frame_b, j5.frame_a)\n               connect(j5.frame_b, b3.frame_b)\n               connect(b0.frame_a, world.frame_b)\n               connect(b0.frame_b, j2.frame_a)\n               ]\n@named fourbar2 = ODESystem(connections, t, systems = [world; systems])\nfourbar2 = complete(fourbar2)\nssys = structural_simplify(IRSystem(fourbar2))\n\nprob = ODEProblem(ssys, [], (0.0, 1.4399)) # The end time is chosen to make the animation below appear to loop forever\n\nsol = solve(prob, FBDF(autodiff=true));\n@test SciMLBase.successful_retcode(sol)\nplot(sol, idxs=[j2.s]) # Plot the joint coordinate of the prismatic joint (green in the animation below)","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"import GLMakie\nMultibody.render(fourbar2, sol; x=-2, y = 2, z = 3, filename = \"fourbar2.gif\") # Use \"fourbar2.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"(Image: animation)","category":"page"},{"location":"examples/kinematic_loops/#Using-a-joint-assembly","page":"Kinematic loops","title":"Using a joint assembly","text":"","category":"section"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"This example models a mechanism similar to the previous one, but replaces several joints and bodies with the aggregate UniversalSpherical joint. This joint is a combination of a universal joint and a spherical joint, with a bar in-between. A benefit of using this joint assembly in a kinematic loop is that some nonlinear equations are solved analytically, and the solver will thus see fewer nonlinear equations. This can lead to a faster simulation.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"systems = @named begin\n    j1 = Revolute(n = [1, 0, 0], w0 = 5.235987755983, state_priority=12.0, radius=0.1f0) # Increase state priority to ensure that this joint coordinate is chosen as state variable\n    j2 = Prismatic(n = [1, 0, 0], s0 = -0.2)\n    b1 = BodyShape(r = [0, 0.5, 0.1], radius=0.03)\n    b2 = BodyShape(r = [0, 0.2, 0], radius=0.03)\n    b3 = FixedTranslation(r = [1.2, 0, 0], radius=0)\n    joint_us = UniversalSpherical(n1_a = [0, 1, 0], rRod_ia = [-1, 0.3, 0.1])\nend\n\nconnections = [connect(j2.frame_b, b2.frame_a)\n               connect(j1.frame_b, b1.frame_a)\n               connect(j1.frame_a, world.frame_b)\n               connect(b1.frame_b, joint_us.frame_b)\n               connect(joint_us.frame_a, b2.frame_b)\n               connect(b3.frame_a, world.frame_b)\n               connect(b3.frame_b, j2.frame_a)\n]\n\n@named fourbar_analytic = ODESystem(connections, t, systems = [world; systems])\nfourbar_analytic = complete(fourbar_analytic)\nssys_analytic = structural_simplify(IRSystem(fourbar_analytic))\nprob = ODEProblem(ssys_analytic, [], (0.0, 1.4399)) \nsol2 = solve(prob, FBDF(autodiff=true)) # about 4x faster than the simulation above\nplot!(sol2, idxs=[j2.s]) # Plot the same coordinate as above","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"In practice, the two simulations are not exactly identical since we haven't modeled any mass attached to the rod in the joint assembly. We could add such mass to the rod by attaching to the joint_us.frame_ia connector.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"import GLMakie\nMultibody.render(fourbar_analytic, sol2; x=-2, y = 2, z = 3, filename = \"fourbar_analytic.gif\")\nnothing # hide","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"(Image: animation)","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"While the version with a cut joint were solving for ","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"length(unknowns(ssys))","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"variables, the version with the joint assembly solved for only","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"length(unknowns(ssys_analytic))","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"variables.","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"We can also inspect the mass matrices of the two systems to see how many nonlinear algebraic equations the solver has to deal with","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"using LinearAlgebra\ndiag(ssys.mass_matrix), diag(ssys_analytic.mass_matrix)","category":"page"},{"location":"examples/kinematic_loops/","page":"Kinematic loops","title":"Kinematic loops","text":"A 1 on the diagonal indicates a differential equation, while a 0 indicates an algebraic equation. The cut-joint version has 6 nonlinear algebraic equations, while the joint assembly version has only 1. Both of them have 2 differential equations (position and velocity), corresponding to the 1 degree of freedom in the mechanism. Nonlinear algebraic equations are more expensive to solve than differential equations.","category":"page"},{"location":"urdf/#URDF-import","page":"URDF import","title":"URDF import","text":"","category":"section"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"Multibody.jl supports import of URDF files by means of the function urdf2multibody. The functionality requires the user to install and load the packages LightXML.jl, Graphs.jl, MetaGraphsNext.jl and JuliaFormatter.jl, e.g.,","category":"page"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"using Pkg\nPkg.add([\n    \"LightXML\",\n    \"Graphs\",\n    \"MetaGraphsNext\",\n    \"JuliaFormatter\"\n])\nusing Multibody, LightXML, Graphs, MetaGraphsNext, JuliaFormatter","category":"page"},{"location":"urdf/#Usage","page":"URDF import","title":"Usage","text":"","category":"section"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"The following example demonstrates how to import a URDF file, the translated model is saved in file multibody_urdf.jl. extras = true makes the file self contained by including package imports, simulation and plotting.","category":"page"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"filename = joinpath(dirname(pathof(Multibody)), \"..\", \"test/doublependulum.urdf\")\nout = \"multibody_urdf.jl\"\nurdf2multibody(filename; extras=true, out)\n\ninclude(out) # Include model, perform simulation and plotting","category":"page"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"Multibody.urdf2multibody","category":"page"},{"location":"urdf/#Multibody.urdf2multibody","page":"URDF import","title":"Multibody.urdf2multibody","text":"urdf2multibody(filename::AbstractString; extras=false, out=nothing, worldconnection = :rigid)\n\nTranslate a URDF file into a Multibody model. Only available if LightXML.jl, Graphs.jl, MetaGraphs.jl and JuliaFormatter.jl are manually installed and loaded by the user.\n\nExample usage:\n\nusing Multibody, ModelingToolkit, JuliaSimCompiler, LightXML, Graphs, MetaGraphsNext, JuliaFormatter\nurdf2multibody(joinpath(dirname(pathof(Multibody)), \"..\", \"test/doublependulum.urdf\"), extras=true, out=\"/tmp/urdf_import.jl\")\n\nKeyword arguments\n\nextras=false: If true, the generated code will include package imports, a simulation of the model and a rendering of the model.\nout=nothing: If provided, the generated code will be written to this file, otherwise the string will only be returned.\nworldconnection=:rigid: If :rigid, the world frame will be connected to the root link with a rigid connection. If a joint constructor is provided, this component will be instantiated and the root link is connected to the world through this, e.g., worldconnection = FreeMotion, ()->Prismatic(n=[0, 1, 0]) etc.\n\nrender_fixed = false: Whether or not to render \"fixed\" joints. These joints aren't actually joints (no degrees of freedom), they are translated to FixedTranslation or FixedRotation components.\n\n\n\n\n\n","category":"function"},{"location":"urdf/#Limitations","page":"URDF import","title":"Limitations","text":"","category":"section"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"The URDF import currently has the following limitations:","category":"page"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"Sensors are not imported\nTransmissions are not imported\nfriction is not translated, but damping is translated to a 1D Damping component attached using an axisflange.","category":"page"},{"location":"urdf/#Structure-of-the-translated-model","page":"URDF import","title":"Structure of the translated model","text":"","category":"section"},{"location":"urdf/","page":"URDF import","title":"URDF import","text":"URDF does not store the transformation implied by links in the link itself, instead, the links store visual and inertial geometry information, while the translation between frames is implied by the origin of the following joint(s). Therefore, we do generally not make use of the r argument to bodies, and let this be arbitrarily set. The transformation between two joints is instead encoded as a r and R arguments to each joint, where joints are wrapped in URDFRevolute and URDFPrismatic components respectively. Internally, these wrapper components are comprised of a transformation, FixedTranslation or FixedRotation, followed by the actual joint. The interface to these special joints are identical to their non-wrapped counterparts, i.e., they have the frame_a and frame_b connectors as expected. Due to this approach, we always connect to the frame_a connector of links/bodies and let frame_b be unused.","category":"page"},{"location":"examples/sensors/#Using-a-sensor","page":"Sensors","title":"Using a sensor","text":"","category":"section"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Multibody models are composed out of multibody components, typically by connecting Frames together. To add, e.g., a control system to a multibody model, we often make use of sensors that, just like in the real world, translate between a physical quantity in 3D and a signal in the \"signal domain\". The signal domain consists of the various blocks defined in ModelingToolkitStandardLibrary.Blocks, and a sensor is simply a component that has two connectors, one Frame connector for attaching to the multibody model, and one Blocks.RealOutput for connecting to the signal domain.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"The example below adds a force and a torque sensor to the pivot point of a pendulum. Note how the two sensors are connected in series with each other, just like how we would typically connect them in practice if they are not integrated into the same component.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"using Multibody\nusing ModelingToolkit\nusing JuliaSimCompiler\nusing Plots\nusing OrdinaryDiffEq\nusing LinearAlgebra\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\n@named joint = Multibody.Revolute(n = [0, 0, 1], isroot = true)\n@named body = Body(; m = 1, isroot = false, r_cm = [0.5, 0, 0])\n@named torquesensor = CutTorque()\n@named forcesensor = CutForce()\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(joint.frame_b, body.frame_a, torquesensor.frame_a,\n                       forcesensor.frame_a)]\n\nconnections = [connect(world.frame_b, joint.frame_a)\n               connect(joint.frame_b, torquesensor.frame_a)\n               connect(torquesensor.frame_b, forcesensor.frame_a)\n               connect(forcesensor.frame_b, body.frame_a)]\n\n@named model = ODESystem(connections, t,\n                         systems = [world, joint, body, torquesensor, forcesensor])\nssys = structural_simplify(IRSystem(model))\n\n\nD = Differential(t)\nprob = ODEProblem(ssys, [], (0, 3))\n\nusing OrdinaryDiffEq\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nplot(sol, idxs = [collect(forcesensor.force.u); collect(joint.frame_a.f)])","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Note how the force sensor measures a force that appears to equal the cut-force in the joint in magnitude, but the orientation appears to differ. Frame cut forces and toques are resolved in the world frame by default, while the force sensor measures the force in the frame of the sensor. We can choose which frame to resolve the measurements in by using hte keyword argument @named forcesensor = CutForce(; resolve_frame = :world). If we do this, the traces in the plot above will overlap.","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"Since the torque sensor measures a torque in a revolute joint, it should measure zero torque in this case, no torque is transmitted through the revolute joint since the rotational axis is perpendicular to the gravitational force:","category":"page"},{"location":"examples/sensors/","page":"Sensors","title":"Sensors","text":"all(x -> abs(x) < 1e-3, reduce(hcat, sol[torquesensor.torque.u]))","category":"page"},{"location":"examples/spring_damper_system/#Spring-damper-system","page":"Spring-damper system","title":"Spring-damper system","text":"","category":"section"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"(Image: animation)","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"Welcome to the spring-damper system example, where we will show you the process of modeling and simulating a basic yet essential mechanical system using the powerful Multibody.jl package in JuliaSim. By understanding the underlying principles of spring-damper systems, you will gain valuable insights into the behavior of various real-world systems, such as suspension systems in vehicles, vibration isolation mechanisms, and biomechanical structures.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"This tutorial mirrors that of the following Modelica tutorial Spring damper system and demonstrates that a body can be freely moving without any connection to a joint. In this case body coordinates are used as state by setting the option isroot=true to the body.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"This example has two parallel spring-mass parts, the first body (body1) is attached directly to the spring, with no joint in parallel with the spring. In this situation, we have to set isroot=true for body1 to indicate that we want to use the body variables as state. The second body (body2) is attached to the spring with a joint in parallel with the spring, so we can use the joint variables as state, hence isroot=false for body2.","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n@named begin\n    body1 = Body(; m = 1, isroot = true, r_cm = [0.0, 0, 0], I_11 = 0.1, I_22 = 0.1,\n                 I_33 = 0.1, r_0 = [0.3, -0.2, 0]) # This is root since there is no joint parallel to the spring leading to this body\n    body2 = Body(; m = 1, isroot = false, r_cm = [0.0, -0.2, 0]) # This is not root since there is a joint parallel to the spring leading to this body\n    bar1 = FixedTranslation(r = [0.3, 0, 0])\n    bar2 = FixedTranslation(r = [0.6, 0, 0])\n    p2 = Prismatic(n = [0, -1, 0], s0 = 0.1, axisflange = true)\n    spring2 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    spring1 = Multibody.Spring(c = 30, s_unstretched = 0.1)\n    damper1 = Multibody.Damper(d = 2)\nend\neqs = [connect(world.frame_b, bar1.frame_a)\n       connect(bar1.frame_b, bar2.frame_a)\n       connect(bar2.frame_b, p2.frame_a)\n       connect(p2.frame_b, body2.frame_a)\n       connect(bar2.frame_b, spring2.frame_a)\n       connect(body2.frame_a, spring2.frame_b)\n       connect(damper1.frame_a, bar1.frame_b)\n       connect(spring1.frame_a, bar1.frame_b)\n       connect(damper1.frame_b, body1.frame_a)\n       connect(spring1.frame_b, body1.frame_a)]\n\n@named model = ODESystem(eqs, t,\n                         systems = [\n                             world,\n                             body1,\n                             body2,\n                             bar1,\n                             bar2,\n                             p2,\n                             spring1,\n                             spring2,\n                             damper1,\n                         ])\n\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [\n    damper1.d => 2;\n    collect(body1.v_0) .=> 0;\n    collect(body1.w_a) .=> 0;\n], (0, 5))\n\nsol = solve(prob, Rodas4())\n@assert SciMLBase.successful_retcode(sol)\n\nPlots.plot(\n    Plots.plot(sol, idxs = [spring1.s, spring2.s]),\n    Plots.plot(sol, idxs = [body1.r_0[2], body2.r_0[2]]),\n    Plots.plot(sol, idxs = [spring1.f, spring2.f]),\n)","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"In this example we used separate springs and dampers, see also the component SpringDamperParallel which combines the two in one component.","category":"page"},{"location":"examples/spring_damper_system/#3D-animation","page":"Spring-damper system","title":"3D animation","text":"","category":"section"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"Multibody.jl supports automatic 3D rendering of mechanisms, we use this feature to illustrate the result of the simulation below:","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"import GLMakie\nMultibody.render(model, sol; filename = \"springdamper.gif\")\nnothing # hide","category":"page"},{"location":"examples/spring_damper_system/","page":"Spring-damper system","title":"Spring-damper system","text":"(Image: animation)","category":"page"},{"location":"examples/gearbox/#Gearbox","page":"Gearbox","title":"Gearbox","text":"","category":"section"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"This example models a gearbox in two different ways:","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"Using the 3D GearConstraint component from the Multibody library.\nUsing the 1D IdealGear component from the Rotational submodule, together with a Mounting1D component.","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"The GearConstraint has two rotational axes which do not have to be parallel. If wou want to select rotational axes, use the keyword arguments n_a and n_b to GearConstraint.","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    gearConstraint = GearConstraint(; ratio = 10)\n    cyl1 = Body(; m = 1, r_cm = [0.4, 0, 0])\n    cyl2 = Body(; m = 1, r_cm = [0.4, 0, 0])\n    torque1 = Torque(resolve_frame = :frame_b)\n    fixed = Fixed() \n    inertia1 = Rotational.Inertia(J = cyl1.I_11)\n    idealGear = Rotational.IdealGear(ratio = 10, use_support = true)\n    inertia2 = Rotational.Inertia(J = cyl2.I_11)\n    torque2 = Rotational.Torque(use_support = true)\n    mounting1D = Mounting1D()\nend\n\neqs = [connect(world.frame_b, gearConstraint.bearing)\n       connect(cyl1.frame_a, gearConstraint.frame_a)\n       connect(gearConstraint.frame_b, cyl2.frame_a)\n       connect(torque1.frame_b, cyl1.frame_a)\n       connect(torque1.frame_a, world.frame_b)\n       # connect(sine.output, torque1.torque)\n       torque1.torque.u .~ [2sin(t), 0, 0]\n       connect(inertia1.flange_b, idealGear.flange_a)\n       connect(idealGear.flange_b, inertia2.flange_a)\n       connect(torque2.flange, inertia1.flange_a)\n       # connect(sine.output, torque2.tau)\n       torque2.tau.u ~ 2sin(t)\n       connect(mounting1D.flange_b, idealGear.support)\n       connect(mounting1D.flange_b, torque2.support)\n       connect(fixed.frame_b, mounting1D.frame_a)]\n\n@named model = ODESystem(eqs, t, systems = [world; systems])\ncm = complete(model)\nssys = structural_simplify(IRSystem(model))\nprob = ODEProblem(ssys, [\n    D(cm.idealGear.phi_b) => 0\n    cm.idealGear.phi_b => 0\n], (0, 10))\nsol = solve(prob, Rodas4())\nplot(sol, idxs=[\n    inertia1.phi\n    inertia2.phi\n    gearConstraint.actuatedRevolute_a.phi\n    gearConstraint.phi_b\n    inertia1.phi / inertia2.phi # One can plot arbitrary expressions of variables! In this case, we plot the ratio between the two angles.\n], layout=3, sp=[1 2 1 2 3], framestyle=:zerolines)","category":"page"},{"location":"examples/gearbox/","page":"Gearbox","title":"Gearbox","text":"The plot indicates that the ratio between the angles of inertia 1 and 2 is 10, as expected, and that the same ratio holds between the two sides of the 3D gear constraint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Multibody","category":"page"},{"location":"#Multibody","page":"Home","title":"Multibody","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Multibody.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModelingToolkit\nusing Multibody, JuliaSimCompiler\nusing OrdinaryDiffEq # Contains the ODE solver we will use\nusing Plots\nt = Multibody.t\nW(args...; kwargs...) = Multibody.world\n\n\nJULIASIM_PURPLE = [87,87,219,255.0f0]./255 # RGBA\nlength_scale = 0.5 # This controls the frequency of the oscillations, smaller scale -> faster oscillations\nradius_small = length_scale*0.2\nradius_large = length_scale*0.3\n\n@mtkmodel Logo begin\n    @components begin\n        world = World(render=false)\n        revl  = Revolute(; radius = radius_large, color=JULIASIM_PURPLE, axisflange=true)\n        revl2 = Revolute(; radius = radius_large, color=JULIASIM_PURPLE, axisflange=true)\n        revr  = Revolute(; radius = radius_small, color=JULIASIM_PURPLE, axisflange=true)\n        bodyl = Body(m=1, radius = radius_small, color=JULIASIM_PURPLE)\n        bodyr = Body(m=1, radius = radius_large, color=JULIASIM_PURPLE)\n        bar_top = FixedTranslation(r=length_scale*[1, 0.05, 0], radius=length_scale*0.025, color=JULIASIM_PURPLE)\n        barl   = FixedTranslation(r=length_scale*[1, -1, 0], radius=length_scale*0.025, color=JULIASIM_PURPLE)\n        barr   = FixedTranslation(r=1.1*length_scale*[-1, -1, 0], radius=length_scale*0.025, color=JULIASIM_PURPLE)\n\n        damperl  = Rotational.Damper(d=0.1)\n        damperl2 = Rotational.Damper(d=0.01)\n        damperr  = Rotational.Damper(d=0.01)\n    end\n    @equations begin\n        connect(revl.frame_a, world.frame_b)\n\n        connect(revl.frame_b, barl.frame_a)\n        connect(barl.frame_b, bodyl.frame_a)\n\n        connect(world.frame_b, revl2.frame_a)\n        connect(revl2.frame_b, bar_top.frame_a)\n        connect(bar_top.frame_b, revr.frame_a)\n        connect(revr.frame_b, barr.frame_a)\n        connect(barr.frame_b, bodyr.frame_a)\n\n        connect(revl.axis, damperl.flange_a)\n        connect(revl2.axis, damperl2.flange_a)\n        connect(revr.axis, damperr.flange_a)\n\n        connect(revl.support, damperl.flange_b)\n        connect(revl2.support, damperl2.flange_b)\n        connect(revr.support, damperr.flange_b)\n    end\nend\n\n@named logo = Logo()\nlogo = complete(logo)\nssys = structural_simplify(IRSystem(logo))\nprob = ODEProblem(ssys, [], (0.0, 3.51))\nsol = solve(prob, Rodas5P())\nPlots.plot(sol)\n\nimport GLMakie\nframerate = 30\ntimevec = [zeros(30); range(sol.t[1], sol.t[end], step=1/framerate)] |> reverse\nrender(logo, sol, timevec; z=-2.5, x=0, y=-0.5, lookat=[0.2,-0.5, 0], filename=\"JuliaSim_logo.gif\", framerate)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: animated logo)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the world of Multibody.jl, a powerful and flexible component of JuliaSim designed to model, analyze, and simulate multibody systems in Julia. As a state-of-the-art tool, Multibody.jl enables users to efficiently study the dynamics of complex mechanical systems in various fields, such as robotics, biomechanics, aerospace, and vehicle dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Built on top of the Julia language and the JuliaSim suite of tools for modeling, simulation, optimization and control, Multibody.jl harnesses the power of Julia's high-performance computing capabilities, making it a go-to choice for both researchers and engineers who require fast simulations and real-time performance. With an intuitive syntax and a comprehensive set of features, this package seamlessly integrates with other Julia and JuliaSim libraries, enabling users to tackle diverse and sophisticated problems in multibody dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this documentation, you will find everything you need to get started with Multibody.jl, from basic component descriptions to detailed examples showcasing the package's capabilities. As you explore this documentation, you'll learn how to create complex models, work with forces and torques, simulate various types of motions, and visualize your results in both 2D and 3D. Whether you are a seasoned researcher or a newcomer to the field, Multibody.jl will empower you to bring your ideas to life and unlock new possibilities in the fascinating world of multibody dynamics.","category":"page"},{"location":"#Example-overview","page":"Home","title":"Example overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following animations give a quick overview of simple mechanisms that can be modeled using Multibody.jl. The examples are ordered from simple at the top, to more advanced at the bottom. Please browse the examples for even more examples!","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>GIF Grid</title>\n    <style>\n        .grid-container {\n            display: grid;\n            grid-template-columns: repeat(3, 1fr);\n            grid-template-rows: repeat(4, auto);\n            gap: 10px;\n            padding: 20px;\n        }\n        .grid-item {\n            width: 100%;\n            height: auto;\n        }\n        .grid-item img {\n            width: 100%;\n            height: auto;\n            display: block;\n        }\n    </style>\n</head>\n<body>\n\n<div class=\"grid-container\">\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/pendulum/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/furuta.gif\" alt=\"Furuta\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/spring_damper_system/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/springdamper.gif\" alt=\"springdamper\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/wheel/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/wheelset.gif\" alt=\"wheels\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/three_springs/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/three_springs.gif\" alt=\"three_springs\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/space/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/space.gif\" alt=\"space\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/free_motion/#Body-suspended-in-springs\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/free_body.gif\" alt=\"free_body\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/ropes_and_cables/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/flexible_rope.gif\" alt=\"flexible_rope\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/ropes_and_cables/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/mounted_chain.gif\" alt=\"mounted_chain\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/quad/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/quadrotor.gif\" alt=\"quadrotor\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/kinematic_loops/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/fourbar2.gif\" alt=\"fourbar2\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/kinematic_loops/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/fourbar.gif\" alt=\"fourbar\">\n    </a>\n    <a class=\"grid-item\" href=\"https://help.juliahub.com/multibody/dev/examples/robot/\">\n        <img src=\"https://help.juliahub.com/multibody/dev/examples/robot.gif\" alt=\"robot\">\n    </a>\n</div>\n\n</body>\n</html>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this library, first follow the installation instructions for JuliaSimCompiler. In particular, you need to add the JuliaHub Registry. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the registry is added and JuliaSimCompiler is installed, you may install this package using","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Multibody\")","category":"page"},{"location":"#Notable-differences-from-Modelica","page":"Home","title":"Notable differences from Modelica","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The torque variable in Multibody.jl is typically called tau rather than t to not conflict with the often used independent variable t used to denote time.\nMultibody.jl occasionally requires the user to specify which component should act as the root of the kinematic tree. This only occurs when bodies are connected directly to force components without a joint parallel to the force component.\nIn Multibody.jl, the orientation object of a Frame is accessed using the function ori.\nQuaternions in Multibody.jl follow the order s i j k, i.e., scalar/real part first.","category":"page"},{"location":"#2D-and-3D-modeling","page":"Home","title":"2D and 3D modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multibody.jl offers components for modeling in both 2D and 3D. 2D modeling, often referred to as planar mechanics, is a subset of 3D modeling where the motion is constrained to a plane, the x,y plane. Planar mechanics is sometimes referred to as 3 degrees of freedom (DOF) modeling, referring to the 2 translational DOF and one rotational DOF that the plane offers. Most components in Multibody.jl are aimed at 3D modeling (sometimes referred to as 6 DOF modeling), but components for 2D modeling exist in the submodule Multibody.PlanarMechanics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The components from ModelingToolkitStandardLibrary.Mechanical are 1D, i.e., a single degree of freedom only. These components can be used in both 2D and 3D modeling together with Multibody components that have support for attaching 1D components, such as joints supporting the axisflange keyword.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Frames","page":"Home","title":"Frames","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody, Multibody.PlanarMechanics]\nPages   = [\"frames.jl\", \"PlanarMechanics/utils.jl\"]","category":"page"},{"location":"#Multibody.Frame","page":"Home","title":"Multibody.Frame","text":"Frame(; name)\n\nFrame is the fundamental 3D connector in the multibody library. Most components have one or several Frame connectors that can be connected together.\n\nThe Frame connector has internal variables for\n\nr_0: The position vector from the world frame to the frame origin, resolved in the world frame\nf: The cut force resolved in the connector frame\ntau: The cut torque resolved in the connector frame\nDepending on usage, also rotation and rotational velocity variables.\n\n\n\n\n\n","category":"function"},{"location":"#Multibody.PlanarMechanics.PartialTwoFrames","page":"Home","title":"Multibody.PlanarMechanics.PartialTwoFrames","text":"PartialTwoFrames(;name)\n\nPartial model with two frames\n\nConnectors:\n\n- `frame_a` [Frame](@ref) Coordinate system fixed to the component with one cut-force and cut-torque\n- `frame_b` [Frame](@ref) Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.ZeroPosition","page":"Home","title":"Multibody.PlanarMechanics.ZeroPosition","text":"ZeroPosition(;name)\n\nSet zero position vector and orientation object of frame_resolve\n\nConnectors:\n\n- `frame_resolve` [FrameResolve](@ref) Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.Frame","page":"Home","title":"Multibody.PlanarMechanics.Frame","text":"Frame(;name)\n\nCoordinate system (2-dim.) fixed to the component with one cut-force and cut-torque\n\nVariables:\n\nx: [m] x position\ny: [m] y position\nphi: [rad] rotation angle (counterclockwise)\nfx: [N] force in the x direction\nfy: [N] force in the y direction\ntau: [N.m] torque (clockwise)\n\nParameters:\n\nrender: [Bool] Render the joint in animations\nlength: [m] Length of each axis in animations\nradius: [m] Radius of each axis in animations\n\n\n\n\n\n","category":"function"},{"location":"#Joints","page":"Home","title":"Joints","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A joint restricts the number of degrees of freedom (DOF) of a body. For example, a free floating body has 6 DOF, but if it is attached to a Revolute joint, the joint restricts all but one rotational degree of freedom (a revolute joint acts like a hinge). Similarily, a Prismatic joint restricts all but one translational degree of freedom (a prismatic joint acts like a slider).","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Spherical joints restricts all translational degrees of freedom, but allows all rotational degrees of freedom. It thus transmits no torque. A Planar joint moves in a plane, i.e., it restricts one translational DOF and two rotational DOF. A Universal joint has two rotational DOF.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some joints offer the option to add 1-dimensional components to them by providing the keyword axisflange = true. This allows us to add, e.g., springs, dampers, sensors, and actuators to the joint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody, Multibody.PlanarMechanics]\nPages   = [\"joints.jl\", \"fancy_joints.jl\", \"PlanarMechanics/joints.jl\"]","category":"page"},{"location":"#Multibody.Planar","page":"Home","title":"Multibody.Planar","text":"Planar(; n = [0,0,1], n_x = [1,0,0], cylinderlength = 0.1, cylinderdiameter = 0.05, cylindercolor = [1, 0, 1, 1], boxwidth = 0.3*cylinderdiameter, boxheight = boxwidth, boxcolor = [0, 0, 1, 1])\n\nJoint where frame_b can move in a plane and can rotate around an axis orthogonal to the plane. The plane is defined by vector n which is perpendicular to the plane and by vector n_x, which points in the direction of the x-axis of the plane. frame_a and frame_b coincide when s_x=prismatic_x.s=0, s_y=prismatic_y.s=0 and phi=revolute.phi=0.\n\nStructural parameters\n\nn: Axis orthogonal to unconstrained plane, resolved in frame_a (= same as in frame_b)\nn_x: Vector in direction of x-axis of plane, resolved in frame_a (n_x shall be orthogonal to n)\n\nConnectors\n\nframe_a: Frame for the joint\nframe_b: Frame for the joint\n\nVariables\n\ns_x: Relative distance along first prismatic joint starting at frame_a\ns_y: Relative distance along second prismatic joint starting at first prismatic joint\nphi: Relative rotation angle from frame_a to frame_b\nv_x: Relative velocity along first prismatic joint\nv_y: Relative velocity along second prismatic joint\nw: Relative angular velocity around revolute joint\na_x: Relative acceleration along first prismatic joint\na_y: Relative acceleration along second prismatic joint\nwd: Relative angular acceleration around revolute joint\n\nRendering parameters\n\ncylinderlength: Length of the revolute cylinder\ncylinderdiameter: Diameter of the revolute cylinder\ncylindercolor: (structural) Color of the revolute cylinder\nboxwidth: Width of the prismatic joint boxes\nboxheight: Height of the prismatic joint boxes\nboxcolor: (structural) Color of the prismatic joint boxes\nradius: (structural) Radius of the revolute cylinder\nrender: Enable rendering of the joint in animations\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.FreeMotion-Tuple{}","page":"Home","title":"Multibody.FreeMotion","text":"FreeMotion(; name, state = true, sequence, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, phi = 0, phid = 0, phidd = 0, w_rel_b = 0, r_rel_a = 0, v_rel_a = 0, a_rel_a = 0)\n\nJoint which does not constrain the motion between frame_a and frame_b. Such a joint is only meaningful if the relative distance and orientation between frame_a and frame_b, and their derivatives, shall be used as state.\n\nNote, that bodies such as Body, BodyShape, have potential state variables describing the distance and orientation, and their derivatives, between the world frame and a body fixed frame. Therefore, if these potential state variables are suited, a FreeMotion joint is not needed.\n\nThe state of the FreeMotion object consits of:\n\nThe relative position vector r_rel_a from the origin of frame_a to the origin of frame_b, resolved in frame_a and the relative velocity v_rel_a of the origin of frame_b with respect to the origin of frame_a, resolved in frame_a (= D(r_rel_a)).\n\nArguments\n\nstate: Enforce this joint having state, this is often desired and is the default choice.\nsequence: Rotation sequence, defaults to [1, 2, 3]\nw_rel_a_fixed: = true, if w_rel_a_start are used as initial values, else as guess values\nz_rel_a_fixed: = true, if z_rel_a_start are used as initial values, else as guess values\n\nInitial condition arguments:\n\nphi\nphid\nphidd\nw_rel_b\nr_rel_a\nv_rel_a\na_rel_a\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.GearConstraint-Tuple{}","page":"Home","title":"Multibody.GearConstraint","text":"GearConstraint(; name, ratio, checkTotalPower = false, n_a, n_b, r_a, r_b)\n\nThis ideal massless joint provides a gear constraint between frames frame_a and frame_b. The axes of rotation of frame_a and frame_b may be arbitrary.\n\nratio: Gear ratio\nn_a: Axis of rotation of frame_a\nn_b: Axis of rotation of frame_b\nr_a: Vector from frame bearing to frame_a resolved in bearing\nr_b: Vector from frame bearing to frame_b resolved in bearing\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.JointRRR-Tuple{}","page":"Home","title":"Multibody.JointRRR","text":"JointRRR(;\n    name,\n    n_a = [0,0,1],\n    n_b = [0,0,1],\n    rRod1_ia = [1,0,0],\n    rRod2_ib = [-1,0,0],\n    phi_offset = 0, \n    phi_guess = 0,\n\n)\n\nThis component consists of 3 revolute joints with parallel axes of rotation that are connected together by two rods.\n\nThis joint aggregation introduces neither constraints nor state variables and should therefore be used in kinematic loops whenever possible to avoid non-linear systems of equations. It is only meaningful to use this component in planar loops. Basically, the position and orientation of the 3 revolute joints as well as of frame_ia, frame_ib, and frame_im are calculated by solving analytically a non-linear equation, given the position and orientation at frame_a and at frame_b.\n\nConnector frame_a is the \"left\" side of the first revolute joint whereas frame_ia is the \"right side of this revolute joint, fixed in rod 1. Connector frame_b is the \"right\" side of the third revolute joint whereas frame_ib is the \"left\" side of this revolute joint, fixed in rod 2. Finally, connector frame_im is the connector at the \"right\" side of the revolute joint in the middle, fixed in rod 2.\n\nThe easiest way to define the parameters of this joint is by moving the MultiBody system in a reference configuration where all frames of all components are parallel to each other (alternatively, at least frame_a, frame_ia, frame_im, frame_ib, frame_b of the JointRRR joint should be parallel to each other when defining an instance of this component).\n\nBasically, the JointRRR model internally consists of a universal-spherical-revolute joint aggregation (= JointUSR). In a planar loop this will behave as if 3 revolute joints with parallel axes are connected by rigid rods.\n\nArguments\n\nn_a Axis of revolute joints resolved in frame_a (all axes are parallel to each other)\nn_b Axis of revolute joint fixed and resolved in frame_b\nrRod1_ia Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\nrRod2_ib Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\nphi_offset Relative angle offset of revolute joint at frame_b (angle = phi(t) + phi_offset)\n\nConnectors\n\nframe_a: Coordinate system fixed to the component with one cut-force and cut-torque\nframe_b: Coordinate system fixed to the component with one cut-force and cut-torque\nframe_ia: Coordinate system at origin of frame_a fixed at connecting rod of left and middle revolute joint\nframe_ib: Coordinate system at origin of frame_ib fixed at connecting rod of middle and right revolute joint\nframe_im: Coordinate system at origin of revolute joint in the middle fixed at connecting rod of middle and right revolute joint\naxis: 1-dim. rotational flange that drives the right revolute joint at frame_b\nbearing: 1-dim. rotational flange of the drive bearing of the right revolute joint at frame_b\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.JointUSR-Tuple{}","page":"Home","title":"Multibody.JointUSR","text":"JointUSR(;\n    name,\n    n1_a = [0, 0, 1],\n    n_b = [0, 0, 1],\n    rRod1_ia = [1, 0, 0],\n    rRod1_ib = [-1, 0, 0],\n    phi_offset = 0,\n    phi_guess = 0,\n)\n\nThis component consists of a universal joint at frame_a, a revolute joint at frame_b and a spherical joint which is connected via rod1 to the universal and via rod2 to the revolute joint.\n\nThis joint aggregation has no mass and no inertia and introduces neither constraints nor potential state variables. It should be used in kinematic loops whenever possible since the non-linear system of equations introduced by this joint aggregation is solved analytically (i.e., a solution is always computed, if a unique solution exists).\n\nThe universal joint is defined in the following way:\n\nThe rotation axis of revolute joint 1 is along parameter vector n1_a which is fixed in frame_a.\nThe rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint (= rod 1).\n\nThe definition of axis 2 of the universal joint is performed according to the most often occurring case for the sake of simplicity. Otherwise, the treatment is much more complicated and the number of operations is considerably higher, if axis 2 is not orthogonal to axis 1 and to the connecting rod.\n\nNote, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible n1_a should be selected in such a way that it is perpendicular to rRod1_ia in the initial configuration (i.e., the distance to the singularity is as large as possible).\n\nThe rest of this joint aggregation is defined by the following parameters:\n\npositive_branch: The positive branch of the revolute joint is selected (cf. elbow up vs. elbow down).\nThe position of the spherical joint with respect to the universal joint is defined by vector rRod1_ia. This vector is directed from frame_a to the spherical joint and is resolved in frame_ia (it is most simple to select frame_ia such that it is parallel to frame_a in the reference or initial configuration).\nThe position of the spherical joint with respect to the revolute joint is defined by vector rRod2_ib. This vector is directed from the inner frame of the revolute joint (frame_ib or revolute.frame_a) to the spherical joint and is resolved in frame_ib (note, that frame_ib and frame_b are parallel to each other).\nThe axis of rotation of the revolute joint is defined by axis vector n_b. It is fixed and resolved in frame_b.\nWhen specifying this joint aggregation with the definitions above, two different configurations are possible. Via parameter phi_guess a guess value for revolute.phi(t0) at the initial time t0 is given. The configuration is selected that is closest to phi_guess (|revolute.phi - phi_guess| is minimal).\n\nConnectors\n\nframe_a: Frame for the universal joint\nframe_b: Frame for the revolute joint\nAn additional frame_ia is present. It is fixed in the rod connecting the universal and the spherical joint at the origin of frame_a. The placement of frame_ia on the rod is implicitly defined by the universal joint (frame_a and frame_ia coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector rRod1ia, the position vector from the origin of `frameato the spherical joint, resolved inframe_ia`.\nAn additional frame_ib is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the revolute joint that is connected to this rod (= rod2.frame_a = revolute.frame_a).\nAn additional frame_im is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the spherical joint that is connected to this rod (= rod2.frame_b). It is always parallel to frame_ib.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Prismatic-Tuple{}","page":"Home","title":"Multibody.Prismatic","text":"Prismatic(; name, n = [0, 0, 1], axisflange = false)\n\nPrismatic joint with 1 translational degree-of-freedom\n\nn: The axis of motion (unit vector)\naxisflange: If true, the joint will have two additional frames from Mechanical.Translational, axis and support, between which translational components such as springs and dampers can be connected.\n\nIf axisflange, flange connectors for ModelicaStandardLibrary.Mechanics.TranslationalModelica are also available:\n\naxis: 1-dim. translational flange that drives the joint\nsupport: 1-dim. translational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)\n\nThe function returns an ODESystem representing the prismatic joint.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Revolute-Tuple{}","page":"Home","title":"Multibody.Revolute","text":"Revolute(; name, phi0 = 0, w0 = 0, n, axisflange = false)\n\nRevolute joint with 1 rotational degree-of-freedom\n\nphi0: Initial angle\nw0: Iniitial angular velocity\nn: The axis of rotation\naxisflange: If true, the joint will have two additional frames from Mechanical.Rotational, axis and support, between which rotational components such as springs and dampers can be connected.\n\nIf axisflange, flange connectors for ModelicaStandardLibrary.Mechanics.Rotational are also available:\n\naxis: 1-dim. rotational flange that drives the joint\nsupport: 1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)\n\nRendering options\n\nradius = 0.05: Radius of the joint in animations\nlength = radius: Length of the joint in animations\ncolor: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RevolutePlanarLoopConstraint-Tuple{}","page":"Home","title":"Multibody.RevolutePlanarLoopConstraint","text":"RevolutePlanarLoopConstraint(; name, n)\n\nRevolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)\n\nJoint where frame_b rotates around axis n which is fixed in frame_a and where this joint is used in a planar loop providing 2 constraint equations on position level.\n\nIf a planar loop is present, e.g., consisting of 4 revolute joints where the joint axes are all parallel to each other, then there is no unique mathematical solution if all revolute joints are modelled with Revolute and the symbolic algorithms will fail. The reason is that, e.g., the cut-forces in the revolute joints perpendicular to the planar loop are not uniquely defined when 3-dim. descriptions of revolute joints are used. In this case, one revolute joint in the loop has to be replaced by model RevolutePlanarLoopConstraint. The effect is that from the 5 constraints of a 3-dim. revolute joint, 3 constraints are removed and replaced by appropriate known variables (e.g., the force in the direction of the axis of rotation is treated as known with value equal to zero; for standard revolute joints, this force is an unknown quantity).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Spherical-Tuple{}","page":"Home","title":"Multibody.Spherical","text":"Spherical(; name, state = false, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, sequence, phi = 0, phid = 0, phidd = 0, d = 0)\n\nJoint with 3 constraints that define that the origin of frame_a and the origin of frame_b coincide. By default this joint defines only the 3 constraints without any potential state variables. If parameter state is set to true, three states are introduced. The orientation of frame_b is computed by rotating frame_a along the axes defined in parameter vector sequence (default = [1,2,3], i.e., the Cardan angle sequence) around the angles used as state. If angles are used as state there is the slight disadvantage that a singular configuration is present leading to a division by zero.\n\nisroot: Indicate that frame_a is the root, otherwise frame_b is the root. Only relevant if state = true.\nsequence: Rotation sequence\nd: Viscous damping constant. If d > 0. the joint dissipates energy due to viscous damping according to τ  -d*ω.\n\nRendering options\n\nradius = 0.1: Radius of the joint in animations\ncolor = [1,1,0,1]: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values\nrender = true: Render the joint in animations\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.SphericalConstraint-Tuple{}","page":"Home","title":"Multibody.SphericalConstraint","text":"SphericalConstraint(; name, color = [1, 1, 0, 1], radius = 0.1, x_locked = true, y_locked = true, z_locked = true)\n\nSpherical cut joint and translational directions may be constrained or released\n\nThis model does not use explicit variables e.g. state variables in order to describe the relative motion of frame_b with to respect to frame_a, but defines kinematic constraints between the frame_a and frame_b. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.\n\nAs a consequence of the formulation the relative kinematics between frame_a and frame_b cannot be initialized.\n\nIn complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare state realization chosen by structural_simplify using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration. In systems without closed loops the use of this implicit joint is not recommended.\n\nArguments\n\nx_locked: Set to false if the translational motion in x-direction shall be free\ny_locked: Set to false if the translational motion in y-direction shall be free\nz_locked: Set to false if the translational motion in z-direction shall be free\n\nRendering parameters\n\ncolor: Color of the joint in animations (RGBA)\nradius: Radius of the joint in animations\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.SphericalSpherical-Tuple{}","page":"Home","title":"Multibody.SphericalSpherical","text":"SphericalSpherical(; name, state = false, isroot = true, iscut=false, w_rel_a_fixed = false, r_0 = [0,0,0], color = [1, 1, 0, 1], m = 0, radius = 0.1, kinematic_constraint=true)\n\nJoint that has a spherical joint on each of its two ends. The rod connecting the two spherical joints is approximated by a point mass that is located in the middle of the rod. When the mass is set to zero (default), special code for a massless body is generated. \n\nThis joint introduces one constraint defining that the distance between the origin of frame_a and the origin of frame_b is constant (= rodLength). It is highly recommended to use this joint in loops whenever possible, because this enhances the efficiency considerably due to smaller systems of non-linear algebraic equations.\n\nIt is not possible to connect other components, such as a body with mass properties or a special visual shape object to the rod connecting the two spherical joints. If this is needed, use instead joint UniversalSpherical that has the additional frame frame_ia for this.\n\nConnectors:\n\nframe_a: Frame for the first spherical joint\nframe_b: Frame for the second spherical joint\n\nRendering parameters:\n\nradius: Radius of the joint in animations\ncolor: Color of the joint in animations (RGBA)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Universal-Tuple{}","page":"Home","title":"Multibody.Universal","text":"Universal(; name, n_a, n_b, phi_a = 0, phi_b = 0, w_a = 0, w_b = 0, a_a = 0, a_b = 0, state_priority=10)\n\nJoint where frame_a rotates around axis n_a which is fixed in frame_a and frame_b rotates around axis n_b which is fixed in frame_b. The two frames coincide when revolute_a.phi=0 and revolute_b.phi=0. This joint has the following potential states;\n\nThe relative angle phi_a = revolute_a.phi [rad] around axis n_a\nthe relative angle phi_b = revolute_b.phi [rad] around axis n_b\nthe relative angular velocity w_a = D(phi_a)\nthe relative angular velocity w_b = D(phi_b)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.UniversalSpherical-Tuple{}","page":"Home","title":"Multibody.UniversalSpherical","text":"UniversalSpherical(; name, n1_a, rRod_ia, sphere_diameter = 0.1, sphere_color, rod_width = 0.1, rod_height = 0.1, rod_color, cylinder_length = 0.1, cylinder_diameter = 0.1, cylinder_color, kinematic_constraint = true)\n\nUniversal - spherical joint aggregation (1 constraint, no potential states)\n\nThis component consists of a universal joint at frame_a and a spherical joint at frame_b that are connected together with a rigid rod.\n\nThis joint aggregation has no mass and no inertia and introduces the constraint that the distance between the origin of frame_a and the origin of frame_b is constant (= length(rRod_ia)). The universal joint is defined in the following way:\n\nThe rotation axis of revolute joint 1 is along parameter vector n1_a which is fixed in frame_a.\nThe rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint.\n\nNote, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible n1_a should be selected in such a way that it is perpendicular to rRod_ia in the initial configuration (i.e., the distance to the singularity is as large as possible).\n\nAn additional frame_ia is present. It is fixed in the connecting rod at the origin of frame_a. The placement of frame_ia on the rod is implicitly defined by the universal joint (frame_a and frame_ia coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector rRod_ia, the position vector from the origin of frame_a to the origin of frame_b, resolved in frame_ia.\n\nThis joint aggregation can be used in cases where in reality a rod with spherical joints at end are present. Such a system has an additional degree of freedom to rotate the rod along its axis. In practice this rotation is usually of no interest and is mathematically removed by replacing one of the spherical joints by a universal joint. Still, in most cases the SphericalSpherical joint aggregation can be used instead of the UniversalSpherical joint since the rod is animated and its mass properties are approximated by a point mass in the middle of the rod. The SphericalSpherical joint has the advantage that it does not have a singular configuration.\n\nArguments\n\nn1_a Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\nrRod_ia Vector from origin of framea to origin of frameb, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\nkinematic_constraint = true Set to false if no constraint shall be defined, due to analytically solving a kinematic loop\nconstraint_residue If set to :external, an equation in the parent system is expected to define this variable, e.g., rod.constraint_residue ~ rod.f_rod - f_rod where rod is the name of the UniversalSpherical joint. If unspecified, the length constraint rRod_0'rRod_0 - rodLength'rodLength is used\n\nConnectors\n\nframe_a: Frame for the universal joint\nframe_b: Frame for the spherical joint\nframe_ia: Frame fixed in the rod at the origin of frame_a\n\nRendering parameters\n\nsphere_diameter: Diameter of spheres representing the universal and the spherical joint\nsphere_color: Color of spheres representing the universal and the spherical joint (RGBA)\nrod_width: Width of rod shape in direction of axis 2 of universal joint\nrod_height: Height of rod shape in direction that is orthogonal to rod and to axis 2\nrod_color: Color of rod shape connecting the universal and the spherical joints (RGBA)\ncylinder_length: Length of cylinders representing the two universal joint axes\ncylinder_diameter: Diameter of cylinders representing the two universal joint axes\ncylinder_color: Color of cylinders representing the two universal joint axes (RGBA)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.Prismatic-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.Prismatic","text":"Prismatic(; name, f, s = 0, axisflange = false)\n\nA prismatic joint\n\nParameters\n\nr: [m, m] x,y-direction of the rod wrt. body system at phi=0\naxisflange=false: If true, a force flange is enabled, otherwise implicitly grounded\"\nrender: Render the joint in animations\nradius: Radius of the body in animations\ncolor: Color of the body in animations\n\nVariables\n\ns(t): [m] Elongation of the joint\nv(t): [m/s] Velocity of elongation\na(t): [m/s²] Acceleration of elongation\nf(t): [N] Force in direction of elongation\n\nConnectors\n\nframe_a Frame\nframe_b Frame\nfixed Fixed if axisflange == false\nflange_a Flange if axisflange == true\nsupport Support if axisflange == true\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.Revolute-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.Revolute","text":"Revolute(; name, phi = 0.0, tau = 0.0, axisflange = false)\n\nA revolute joint\n\nParameters:\n\naxisflange=false: If true, a force flange is enabled, otherwise implicitly grounded\"\nphi: [rad] Initial angular position for the flange\ntau: [Nm] Initial Cut torque in the flange\n\nVariables:\n\nphi(t): [rad] angular position\nw(t): [rad/s] angular velocity\nα(t): [rad/s²] angular acceleration\ntau(t): [Nm] torque\n\nConnectors\n\nframe_a Frame\nframe_b Frame\nfixed Fixed if axisflange == false\nflange_a Flange if axisflange == true\nsupport Support if axisflange == true\n\n\n\n\n\n","category":"method"},{"location":"#Components","page":"Home","title":"Components","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The perhaps most fundamental component is a Body, this component has a single flange, frame_a, which is used to connect the body to other components. This component has a mass, a vector r_cm from frame_a to the center of mass, and a moment of inertia tensor I in the center of mass. The body can be thought of as a point mass with a moment of inertia tensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A mass with a shape can be modeled using a BodyShape. The primary difference between a Body and a BodyShape is that the latter has an additional flange, frame_b, which is used to connect the body to other components. The translation between flange_a and flange_b is determined by the vector r. The BodyShape is suitable to model, e.g., cylinders, rods, and boxes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A rod without a mass (just a translation), is modeled using FixedTranslation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody, Multibody.PlanarMechanics]\nPages   = [\"components.jl\", \"wheels.jl\", \"PlanarMechanics/components.jl\"]","category":"page"},{"location":"#Multibody.BodyBox","page":"Home","title":"Multibody.BodyBox","text":"BodyBox(; name, m = 1, r = [1, 0, 0], r_shape = [0, 0, 0], width_dir = [0,1,0])\n\nRigid body with box shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the box data. Optionally, the box may be hollow. The (outer) box shape is used in the animation, the hollow part is not shown in the animation. The two connector frames frame_a and frame_b are always parallel to each other.\n\nParameters\n\nr: (structural parameter) Vector from frame_a to frame_b resolved in frame_a\nr_shape: (structural parameter) Vector from frame_a to box origin, resolved in frame_a\nwidth_dir: (structural parameter) Vector in width direction of box, resolved in frame_a\nlength_dir: (structural parameter) Vector in length direction of box, resolved in frame_a\nlength: (structural parameter) Length of box\nwidth = 0.3length: Width of box\nheight = width: Height of box\ninner_width: Width of inner box surface (0 <= inner_width <= width)\ninner_height: Height of inner box surface (0 <= inner_height <= height)\ndensity = 7700: Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)\ncolor: Color of box in animations\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.BodyCylinder","page":"Home","title":"Multibody.BodyCylinder","text":"BodyCylinder(; name, m = 1, r = [0.1, 0, 0], r_shape = [0, 0, 0], dir = r - r_shape, length = _norm(r - r_shape), diameter = 1, inner_diameter = 0, density = 7700, color = purple)\n\nRigid body with cylinder shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the cylinder data. Optionally, the cylinder may be hollow. The two connector frames frame_a and frame_b are always parallel to each other.\n\nParameters\n\nr: (Structural parameter) Vector from frame_a to frame_b resolved in frame_a\nr_shape: (Structural parameter) Vector from frame_a to cylinder origin, resolved in frame_a\ndir: Vector in length direction of cylinder, resolved in frame_a\nlength: Length of cylinder\ndiameter: Diameter of cylinder\ninner_diameter: Inner diameter of cylinder (0 <= inner_diameter <= diameter)\ndensity: Density of cylinder kg/m³\ncolor: Color of cylinder in animations\n\nVariables\n\nr_0: Position vector from origin of world frame to origin of frame_a\nv_0: Absolute velocity of frame_a, resolved in world frame (= D(r_0))\na_0: Absolute acceleration of frame_a resolved in world frame (= D(v_0))\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.world","page":"Home","title":"Multibody.world","text":"The world component is the root of all multibody models. It is a fixed frame with a parallel gravitational field and a gravity vector specified by the unit direction world.n (defaults to [0, -1, 0]) and magnitude world.g (defaults to 9.80665).\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.AccSensor-Tuple{}","page":"Home","title":"Multibody.AccSensor","text":"AccSensor(;name)\n\nIdeal sensor to measure the absolute flange angular acceleration\n\nConnectors:\n\nflange: Flange Flange of shaft from which sensor information shall be measured\na: RealOutput Absolute angular acceleration of flange\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.AxisControlBus-Tuple{}","page":"Home","title":"Multibody.AxisControlBus","text":"@connector AxisControlBus(; name)\n\nmotion_ref(t) = 0: = true, if reference motion is not in rest\nangle_ref(t) = 0: Reference angle of axis flange\nangle(t) = 0: Angle of axis flange\nspeed_ref(t) = 0: Reference speed of axis flange\nspeed(t) = 0: Speed of axis flange\nacceleration_ref(t) = 0: Reference acceleration of axis flange\nacceleration(t) = 0: Acceleration of axis flange\ncurrent_ref(t) = 0: Reference current of motor\ncurrent(t) = 0: Current of motor\nmotorAngle(t) = 0: Angle of motor flange\nmotorSpeed(t) = 0: Speed of motor flange\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.AxisType2-Tuple{}","page":"Home","title":"Multibody.AxisType2","text":"AxisType2(; name)\n\nAxis model of the r3 joints 4,5,6\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Body-Tuple{}","page":"Home","title":"Multibody.Body","text":"Body(; name, m = 1, r_cm, isroot = false, phi0 = zeros(3), phid0 = zeros(3), r_0 = zeros(3), state_priority = 2, quat = false, sparse_I = false)\n\nRepresenting a body with 3 translational and 3 rotational degrees-of-freedom.\n\nThis component has a single frame, frame_a. To represent bodies with more than one frame, see BodyShape, BodyCylinder, BodyBox.\n\nPerformance optimization\n\nsparse_I: If true, the zero elements of the inerita matrix are considered \"structurally zero\", and this fact is used to optimize performance. When this option is enabled, the elements of the inertia matrix that were zero when the component was created cannot changed without reinstantiating the component. This performance optimization may be useful, e.g., when the inertia matrix is known to be diagonal.\n\nParameters\n\nm: Mass\nr_cm: Vector from frame_a to center of mass, resolved in frame_a\nI_11, I_22, I_33, I_21, I_31, I_32: Inertia-matrix elements\nisroot: Indicate whether this component is the root of the system, useful when there are no joints in the model.\nphi0: Initial orientation, only applicable if isroot = true and quat = false\nphid0: Initial angular velocity\n\nVariables\n\nr_0: Position vector from origin of world frame to origin of frame_a\nv_0: Absolute velocity of frame_a, resolved in world frame (= D(r_0))\na_0: Absolute acceleration of frame_a resolved in world frame (= D(v_0))\n\nRendering options\n\nradius: Radius of the joint in animations\ncylinder_radius: Radius of the cylinder from frame to COM in animations (only drawn if r_cm is non-zero). Defaults to radius/2\ncolor: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.BodyShape-Tuple{}","page":"Home","title":"Multibody.BodyShape","text":"BodyShape(; name, m = 1, r, kwargs...)\n\nThe BodyShape component is similar to a Body, but it has two frames and a vector r that describes the translation between them, while the body has a single frame only.\n\nr: Vector from frame_a to frame_b resolved in frame_a\nAll kwargs are passed to the internal Body component.\nshapefile: A path::String to a CAD model that can be imported by MeshIO for 3D rendering. If none is provided, a cylinder shape is rendered.\n\nSee also BodyCylinder and BodyBox for body components with predefined shapes and automatically computed inertial properties based on geometry and density.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.FixedRotation-Tuple{}","page":"Home","title":"Multibody.FixedRotation","text":"FixedRotation(; name, r, n, sequence, isroot = false, angle)\n\nFixed translation followed by a fixed rotation of frame_b with respect to frame_a\n\nr: Translation vector\nn: Axis of rotation, resolved in frame_a\nangle: Angle of rotation around n, given in radians\n\nTo obtain an axis-angle representation of any rotation, see Conversion between orientation formats\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.FixedTranslation-Tuple{}","page":"Home","title":"Multibody.FixedTranslation","text":"FixedTranslation(; name, r)\n\nFixed translation of frame_b with respect to frame_a with position vector r resolved in frame_a.\n\nCan be thought of as a massless rod. For a massive rod, see BodyShape or BodyCylinder.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Rope-Tuple{}","page":"Home","title":"Multibody.Rope","text":"Rope(; name, l = 1, n = 10, m = 1, c = 0, d = 0, kwargs)\n\nModel a rope (string / cable) of length l and mass m.\n\nThe rope is modeled as a series of n links, each connected by a Spherical joint. The links are either fixed in length (default, modeled using BodyShape) or flexible, in which case they are modeled as a Translational.Spring and Translational.Damper in parallel with a Prismatic joint with a Body adding mass to the center of the link segment. The flexibility is controlled by the parameters c and d, which are the stiffness and damping coefficients of the spring and damper, respectively. The default values are c = 0 and d = 0, which corresponds to a stiff rope.\n\nl: Unstretched length of rope\nn: Number of links used to model the rope. For accurate approximations to continuously flexible ropes, a large number may be required.\nm: The total mass of the rope. Each rope segment will have mass m / n.\nc: The equivalent stiffness of the rope, i.e., the rope will act like a spring with stiffness c. \nd: The equivalent damping in the stretching direction of the rope, i.e., the taught rope will act like a damper with damping d.\nd_joint: Viscous damping in the joints between the links. A positive value makes the rope dissipate energy while flexing (as opposed to the damping d which dissipats energy due to stretching).\ndir: A vector of norm 1 indicating the initial direction of the rope.\n\nDamping\n\nThere are three different methods of adding damping to the rope:\n\nDamping in the stretching direction of the rope, controlled by the parameter d.\nDamping in flexing of the rope, modeled as viscous friction in the joints between the links, controlled by the parameter d_joint.\nAir resistance to the rope moving through the air, controlled by the parameter air_resistance. This damping is quadratic in the velocity (f_d  -vv) of each link relative to the world frame.\n\nRendering\n\ncolor = [255, 219, 120, 255]./255\nradius = 0.05f0\njointradius=0\njointcolor=color\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.World-Tuple{}","page":"Home","title":"Multibody.World","text":"World(; name, render=true)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.gravity_acceleration-Tuple{Any}","page":"Home","title":"Multibody.gravity_acceleration","text":"Compute the gravity acceleration, resolved in world frame\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.ori","page":"Home","title":"Multibody.ori","text":"ori(frame, varw = false)\n\nGet the orientation of sys as a RotationMatrix object.\n\nFor frames, the orientation is stored in the metadata field of the system as sys.metadata[:orientation].\n\nIf varw = true, the angular velocity variables w of the frame is also included in the RotationMatrix object, otherwise w is derived as the time derivative of R. varw = true is primarily used when selecting a component as root.\n\n\n\n\n\n","category":"function"},{"location":"#Multibody.RollingConstraintVerticalWheel-Tuple{}","page":"Home","title":"Multibody.RollingConstraintVerticalWheel","text":"RollingConstraintVerticalWheel(;\n    name,\n    radius = 0.3,\n    lateral_sliding_constraint = true,\n)\n\nRolling constraint for wheel that is always perpendicular to x-z plane\n\nJoint for a wheel rolling on the x-z plane of the world frame intended for an idealized wheelset. To meet this objective, the wheel always runs upright and enables no slip in the longitudinal direction of the wheel/ground contact. On the contrary, the wheel can optionally slip in the lateral direction which is reasonable for the wheelset where just one of the wheels should be laterally constrained. The frame frame_a is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. A wheel body collecting the mass and inertia\n\nArguments and parameters:\n\nname: Name of the rolling wheel joint component\nradius: Wheel radius\nlateral_sliding_constraint: true, if lateral sliding constraint taken into account, = false if lateral force = 0 (needed to avoid overconstraining if two ideal rolling wheels are connect on one axis)\n\nConnectors:\n\nframe_a: Frame for the wheel joint\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheel-Tuple{}","page":"Home","title":"Multibody.RollingWheel","text":"RollingWheel(; name, radius, m, I_axis, I_long, width=0.035, x0, y0, kwargs...)\n\nIdeal rolling wheel on flat surface y=0 (5 positional, 3 velocity degrees of freedom)\n\nA wheel rolling on the x-z plane of the world frame including wheel mass. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. The wheel can not take off but it can incline toward the ground. The frame frame_a is placed in the wheel center point and rotates with the wheel itself. A Revolute joint rotationg around n = [0, 1, 0] is required to attach the wheel to a wheel axis.\n\nArguments and parameters:\n\nname: Name of the rolling wheel component\nradius: Radius of the wheel\nm: Mass of the wheel\nI_axis: Moment of inertia of the wheel along its axis\nI_long: Moment of inertia of the wheel perpendicular to its axis\nwidth: Width of the wheel (default: 0.035)\nx0: Initial x-position of the wheel axis\nz0: Initial z-position of the wheel axis\nkwargs...: Additional keyword arguments passed to the RollingWheelJoint function\n\nVariables:\n\nx: x-position of the wheel axis\nz: z-position of the wheel axis\nangles: Angles to rotate world-frame into frame_a around y-, z-, x-axis\nder_angles: Derivatives of angles  (y: like rotational velocity of a spinning coin, z: wheel forward spin speed, x: wheel falling over speed)\n\nNamed components:\n\nframe_a: Frame for the wheel component\nwheeljoint: Rolling wheel joint representing the wheel's contact with the road surface\n\ntip: Rendering tip\nDue to the symmetry of the wheel, it can be hard to discern how the wheel is rotating in animations. Try enabling rendering of the frame of the wheel by setting wheel.frame_a.render => true;\nwheel.frame_a.length => 1.1radius;\nwheel.frame_a.radius => 0.02radius;\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheelJoint-Tuple{}","page":"Home","title":"Multibody.RollingWheelJoint","text":"RollingWheelJoint(; name, radius, angles, x0, y0, z0)\n\nJoint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane y=0). See RollingWheel for a realistic wheel model with inertia.\n\nA joint for a wheel rolling on the x-z plane of the world frame. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. This is simply gained by two non-holonomic constraint equations on velocity level defined for both longitudinal and lateral direction of the wheel. There is also a holonomic constraint equation on position level granting a permanent contact of the wheel to the ground, i.e. the wheel can not take off.\n\nThe origin of the frame frame_a is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. The z-axis of frame_a is identical with the wheel spin axis, i.e. the wheel rotates about z-axis of frame_a. A wheel body collecting the mass and inertia should be connected to this frame.\n\nArguments and parameters:\n\nradius: Radius of the wheel\nangles: Angles to rotate world-frame into frame_a around y-, z-, x-axis\nsurface: By default, the wheel is rolling on a flat xz plane. A function surface = (x, z)->y may be provided to define a road surface. The function should return the height of the road at (x, z).\n\nVariables:\n\nx: x-position of the wheel axis\ny: y-position of the wheel axis\nz: z-position of the wheel axis\nangles: Angles to rotate world-frame into frame_a around y-, z-, x-axis\nder_angles: Derivatives of angles\nr_road_0: Position vector from world frame to contact point on road, resolved in world frame\nf_wheel_0: Force vector on wheel, resolved in world frame\nf_n: Contact force acting on wheel in normal direction\nf_lat: Contact force acting on wheel in lateral direction\nf_long: Contact force acting on wheel in longitudinal direction\nerr: Absolute value of (r_road_0 - frame_a.r_0) - radius (must be zero; used for checking)\ne_axis_0: Unit vector along wheel axis, resolved in world frame\ndelta_0: Distance vector from wheel center to contact point\ne_n_0: Unit vector in normal direction of road at contact point, resolved in world frame\ne_lat_0: Unit vector in lateral direction of road at contact point, resolved in world frame\ne_long_0: Unit vector in longitudinal direction of road at contact point, resolved in world frame\ns: Road surface parameter 1\nw: Road surface parameter 2\ne_s_0: Road heading at (s,w), resolved in world frame (unit vector)\nv_0: Velocity of wheel center, resolved in world frame\nw_0: Angular velocity of wheel, resolved in world frame\nvContact_0: Velocity of contact point, resolved in world frame\n\nConnector frames\n\nframe_a: Frame for the wheel joint\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheelSet-Tuple{}","page":"Home","title":"Multibody.RollingWheelSet","text":"RollingWheelSet(;\n    name,\n    radius = 0.3,\n    m_wheel = 1.0,\n    I_axis = 1.0,\n    I_long = 1.0,\n    track = 1.0,\n    state_priority = 1,\n    x0 = 0,\n    z0 = 0,\n    phi0 = 0,\n    theta1_0 = 0,\n    theta2_0 = 0,\n    der_theta1_0 = 0,\n    der_theta2_0 = 0,\n    width_wheel = 0.01,\n    color = [0.3, 0.3, 0.3, 1],\n    render = true,\n    iscut = false,\n)\n\nIdeal rolling wheel set consisting of two ideal rolling wheels connected together by an axis\n\nTwo wheels are connected by an axis and can rotate around this axis. The wheels are rolling on the x-z plane of the world frame. The coordinate system attached to the center of the wheel axis (frame_middle) is constrained so that it is always parallel to the x-z plane. If all generalized coordinates are zero, frame_middle is parallel to the world frame.\n\nArguments and parameters:\n\niscut: if more than one wheel set is connected to the same rigid body, iscut must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.\nradius: Radius of one wheel\nm_wheel: Mass of one wheel\nI_axis: Moment of inertia of one wheel around its rotation axis\nI_long: Moment of inertia of one wheel perpendicular to its rotation axis\ntrack: Distance between the two wheels (= axle track)\n\nConnectors\n\nframe_middle: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)\nframe1: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)\nframe2: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)\naxis1: 1-dim. Rotational flange that drives the left wheel\naxis2: 1-dim. Rotational flange that drives the right wheel\nsupport: Support of 1D axes\n\nTo connect driving torques or friction to rotation of the wheels, connect between axis1 and support, and axis2 and support respectively. To connect the wheel set to, e.g., a body, connect the frame_middle to the body frame.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RollingWheelSetJoint-Tuple{}","page":"Home","title":"Multibody.RollingWheelSetJoint","text":"RollingWheelSetJoint(;\n    name,\n    radius = 0.3,\n    track = 1.0,\n    state_priority = 1,\n    x0 = 0,\n    z0 = 0,\n    phi0 = 0,\n    theta1_0 = 0,\n    theta2_0 = 0,\n    der_theta1_0 = 0,\n    der_theta2_0 = 0,\n    render = true,\n    iscut = false,\n)\n\nJoint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)\n\nAn assembly joint for a wheelset rolling on the x-z plane of the world frame. The frames frame1 and frame2 are connected to rotating wheels; the frame_middle moves in a plane parallel to the x-z plane of the world and should be connected to the vehicle body.\n\nTo work properly, the gravity acceleration vector g of the world must point in the negative y-axis (default)\n\nArguments and parameters:\n\niscut: if more than one wheel set is connected to the same rigid body, iscut must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.\nradius: Radius of one wheel\ntrack: Distance between the two wheels (= axle track)\n\nConnectors:\n\nframe_middle: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)\nframe1: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)\nframe2: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)\naxis1: 1-dim. Rotational flange that drives the joint\naxis2: 1-dim. Rotational flange that drives the joint\nsupport: Support of 1-dim axes\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.BodyShape","page":"Home","title":"Multibody.PlanarMechanics.BodyShape","text":"BodyShape(; name, r = [1,0], r_cm = 0.5*r, gy = -9.807)\n\nThe BodyShape component is similar to a Body, but it has two frames and a vector r that describes the translation between them, while the body has a single frame only.\n\nParameters\n\nr: (Structural) Vector from frame_a to frame_b resolved in frame_a\nr_cm: (Structural) Vector from frame_a to the center of mass resolved in frame_a\n\nSubsystems\n\ntranslation: FixedTranslation Fixed translation between frame_a and frame_b\ntranslation_cm: FixedTranslation Fixed translation between frame_a and the center of mass\nbody: Body Body component placed at center of mass. This component holds the inertial properties\n\nConnectors\n\nframe_a\nframe_b\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.Damper","page":"Home","title":"Multibody.PlanarMechanics.Damper","text":"Damper(; name, d = 1, s_small = 1.e-10)\n\nLinear (velocity dependent) damper\n\nParameters:\n\nd: [N.s/m] Damping constant \ns_small: [m] Prevent zero-division if distance between framea and frameb is zero\n\nConnectors:\n\nframe_a Frame Coordinate system fixed to the component with one cut-force and cut-torque\nframe_b Frame Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.DifferentialGear","page":"Home","title":"Multibody.PlanarMechanics.DifferentialGear","text":"DifferentialGear(; name)\n\nA 1D-rotational component that is a variant of a planetary gear and can be used to distribute the torque equally among the wheels on one axis.\n\nConnectors:\n\nflange_b (Rotational.Flange) Flange for the input torque\nflange_left (Rotational.Flange) Flange for the left output torque\nflange_right (Rotational.Flange) Flange for the right output torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.Fixed","page":"Home","title":"Multibody.PlanarMechanics.Fixed","text":"Fixed(; name, r = [0.0, 0.0], phi = 0.0)\n\nFrame fixed in the planar world frame at a given position and orientation\n\nParameters:\n\nr: [m, m] Fixed absolute x,y-position, resolved in world frame\nphi: [rad] Fixed angle\n\nConnectors:\n\nframe_b: 2-dim. Coordinate system\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.FixedTranslation","page":"Home","title":"Multibody.PlanarMechanics.FixedTranslation","text":"FixedTranslation(; name, r::AbstractArray, l)\n\nA fixed translation between two components (rigid rod)\n\nParameters:\n\nrx: [m] Fixed x-length of the rod resolved w.r.t to body frame_a at phi = 0\nry: [m] Fixed y-length of the rod resolved w.r.t to body frame_a at phi = 0\nradius: [m] Radius of the rod in animations\nrender: [Bool] Render the rod in animations\n\nConnectors:\n\nframe_a Frame Coordinate system fixed to the component with one cut-force and cut-torque\nframe_b Frame Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.IdealPlanetary","page":"Home","title":"Multibody.PlanarMechanics.IdealPlanetary","text":"IdealPlanetary(; name, ratio = 2)\n\nThe IdealPlanetary gear box is an ideal gear without inertia, elasticity, damping or backlash consisting of an inner sun wheel, an outer ring wheel and a planet wheel located between sun and ring wheel. The bearing of the planet wheel shaft is fixed in the planet carrier. The component can be connected to other elements at the sun, ring and/or carrier flanges. It is not possible to connect to the planet wheel. If inertia shall not be neglected, the sun, ring and carrier inertias can be easily added by attaching inertias (= model Inertia) to the corresponding connectors. The inertias of the planet wheels are always neglected.\n\nThe ideal planetary gearbox is uniquely defined by the ratio of the number of ring teeth z_r with respect to the number of sun teeth z_s. For example, if there are 100 ring teeth and 50 sun teeth then ratio = z_rz_s = 2. The number of planet teeth z_p has to fulfill the following relationship:\n\nz_p = (z_r - z_s)  2\n\nTherefore, in the above example z_p = 25 is required.\n\nAccording to the overall convention, the positive direction of all vectors, especially the absolute angular velocities and cut-torques in the flanges, are along the axis vector displayed in the icon.\n\nParameters:\n\nratio: Number of ring teeth/sun teeth\n\nConnectors:\n\nsun (Rotational.Flange) Sun wheel\ncarrier (Rotational.Flange) Planet carrier\nring (Rotational.Flange) Ring wheel\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.SimpleWheel","page":"Home","title":"Multibody.PlanarMechanics.SimpleWheel","text":"SimpleWheel(; name, radius = 0.3, color = [1, 0, 0, 1], μ = 1e9)\n\nSimple wheel model with viscous lateral friction and a driving torque\n\nConnectors:\n\nframe_a (Frame) Coordinate system fixed to the component with one cut-force and cut-torque\nthrust (RealInput) Input for the longitudinal force applied to the wheel\n\nParameters:\n\nμ: [Ns/m] Viscous friction coefficient\nradius: [m] Radius of the wheel\ncolor: Color of the wheel in animations\n\nVariables:\n\nθ: [rad] Wheel angle\nVx: [m/s] Longitudinal velocity (resolved in local frame)\nVy: [m/s] Lateral velocity (resolved in local frame)\nFy: [N] Lateral friction force\nFx: [N] Applied longitudinal wheel force\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.Spring","page":"Home","title":"Multibody.PlanarMechanics.Spring","text":"Spring(; name, c_x = 1, c_y = 1, c_phi = 1e5, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)\n\nLinear 2D translational spring\n\nParameters:\n\nc_x: [N/m] Spring constant in x dir\nc_y: [N/m] Spring constant in y dir\nc_phi: [N.m/rad] Spring constant in phi dir\ns_relx0: [m] Unstretched spring length\ns_rely0: [m] Unstretched spring length\nphi_rel0: [rad] Unstretched spring angle\ns_small: [m] Prevent zero-division if distance between framea and frameb is zero\nnum_windings: [Int] Number of windings of the coil when rendered\ncolor = [0,0,1,1] Color of the spring in animations\nrender = true Render the spring in animations\nradius = 0.1 Radius of spring when rendered\nN = 200 Number of points in mesh when rendered\n\nConnectors:\n\nframe_a Frame Coordinate system fixed to the component with one cut-force and cut-torque\nframe_b Frame Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.SpringDamper","page":"Home","title":"Multibody.PlanarMechanics.SpringDamper","text":"SpringDamper(; name, c_x = 1, c_y = 1, c_phi = 1e5, d_x = 1, d_y = 1, d_phi = 1, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)\n\nLinear 2D translational spring damper model\n\nParameters:\n\nc_x: [N/m] Spring constant in x dir\nc_y: [N/m] Spring constant in y dir\nc_phi: [N.m/rad] Spring constant in phi dir\nd_x: [N.s/m] Damping constant in x dir\nd_y: [N.s/m] Damping constant in y dir\nd_phi: [N.m.s/rad] Damping constant in phi dir\ns_relx0: [m] Unstretched spring length\ns_rely0: [m] Unstretched spring length\nphi_rel0: [rad] Unstretched spring angle\ns_small: [m] Prevent zero-division if distance between framea and frameb is zero\nnum_windings: [Int] Number of windings of the coil when rendered\ncolor = [0,0,1,1] Color of the spring in animations\nrender = true Render the spring in animations\nradius = 0.1 Radius of spring when rendered\nN = 200 Number of points in mesh when rendered\n\nConnectors:\n\nframe_a Frame Coordinate system fixed to the component with one cut-force and cut-torque\nframe_b Frame Coordinate system fixed to the component with one cut-force and cut-torque\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.Body-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.Body","text":"Body(; name, m=1, I=0.1, r=0, gy=-9.807, radius=0.1, render=true, color=Multibody.purple)\n\nBody component with mass and inertia\n\nParameters:\n\nm: [kg] mass of the body\nI: [kg.m²] inertia of the body with respect to the origin of frame along the z-axis of frame\nr: [m, m] Translational position x,y-position\ngy: [m/s²] gravity field acting on the mass in the y-direction, positive value acts in the positive direction defaults to -9.807\nradius: [m] Radius of the body in animations\nrender: [Bool] Render the body in animations\ncolor: [Array{Float64,1}] Color of the body in animations\n\nVariables:\n\nr: [m, m] x,y position\nv: [m/s, m/s] x,y velocity\na: [m/s², m/s²] x,y acceleration\nphi: [rad] rotation angle (counterclockwise)\nw: [rad/s] angular velocity\nα: [rad/s²] angular acceleration\n\nConnectors:\n\nframe: 2-dim. Coordinate system\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.SlipBasedWheelJoint","text":"SlipBasedWheelJoint(;\n    name,\n    r = [1, 0],\n    N,\n    vAdhesion_min,\n    vSlide_min,\n    sAdhesion,\n    sSlide,\n    mu_A,\n    mu_S,\n    render = true,\n    color = [0.1, 0.1, 0.1, 1],\n    z = 0,\n    diameter = 0.1,\n    width = diameter * 0.6,\n    radius = 0.1,\n    w_roll = nothing,\n)\n\nSlip-based wheel joint\n\nThe ideal wheel joint models the behavior of a wheel rolling on a x,y-plane whose contact patch has slip-dependent friction characteristics. This is an approximation for wheels with a rim and a rubber tire.\n\nThe force depends with friction characteristics on the slip. The slip is split into two components:\n\nlateral slip: the lateral velocity divided by the rolling velocity.\nlongitudinal slip: the longitudinal slip velocity divided by the rolling velocity.\n\nFor low rolling velocity this definition become ill-conditioned. Hence a dry-friction model is used for low rolling velocities. For zero rolling velocity, the intitialization might fail if automatic differentiation is used. Either start with a non-zero (but tiny) rolling velocity or pass autodiff=false to the solver.\n\nThe radius of the wheel can be specified by the parameter radius. The driving direction (for phi = 0) can be specified by the parameter r. The normal load is set by N.\n\nThe wheel contains a 2D connector frame_a for the steering on the plane. The rolling motion of the wheel can be actuated by the 1D connector flange_a.\n\nIn addition there is an input dynamicLoad for a dynamic component of the normal load.\n\nConnectors:\n\nframe_a (Frame) Coordinate system fixed to the component with one cut-force and cut-torque\nflange_a (Rotational.Flange) Flange for the rolling motion\ndynamicLoad (Blocks.RealInput) Input for the dynamic component of the normal load (must be connected)\n\nTerminology:\n\nAdhesion refers to the peak of the traction curve, where the slip is such that the maximum amount of traction is generated.\nSliding velocity refers to the velocity at which the traction curve saturates and stays constant with increased slip velocity.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}","page":"Home","title":"Multibody.PlanarMechanics.limit_S_form","text":"limit_S_form(x_min, x_max, y_min, y_max, x)\n\nReturns a S-shaped transition\n\nA smooth transition between points (x_min, y_min) and (x_max, y_max). The transition is done in such a way that the 1st function's derivative is continuous for all x. The higher derivatives are discontinuous at input points.\n\nx_min = -0.4\nx_max = 0.6\ny_max = 1.4\ny_min = 1.2\n\njulia> plot(x->Multibody.PlanarMechanics.limit_S_form(x_min, x_max, y_min, y_max, x), -1, 1, legend=false)\n         ┌────────────────────────────────────────┐ \n   1.406 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⡠⠔⠒⠒⠒⠒⠒⠒⠒⠂⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠃⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡔⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   1.194 │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⠉⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n         └────────────────────────────────────────┘ \n         ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ \n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}","page":"Home","title":"Multibody.PlanarMechanics.limit_S_triple","text":"limit_S_triple(x_max, x_sat, y_max, y_sat, x)\n\nReturns a point-symmetric Triple S-Function\n\nA point symmetric interpolation between points (0, 0), (x_max, y_max) and (x_sat, y_sat), provided x_max < x_sat. The approximation is done in such a way that the 1st function's derivative is zero at points (x_max, y_max) and (x_sat, y_sat). Thus, the 1st function's derivative is continuous for all x. The higher derivatives are discontinuous at these points.\n\nx_max = 0.2\nx_sat = 0.5\ny_max = 1.4\ny_sat = 1.2\n\nplot(x->Multibody.PlanarMechanics.limit_S_triple(x_max, x_sat, y_max, y_sat, x), -1, 1)\nvline!([x_max x_sat], label=[\"x_max\" \"x_sat\"])\n\n            ┌────────────────────────────────────────┐ \n    1.48385 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⡔⠢⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⡜⠀⠀⠀⠈⠉⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠂⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⣀⡀⠀⠀⠀⡜⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n   -1.48377 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠒⠦⠼⠁⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n            └────────────────────────────────────────┘ \n            ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ \n\n\n\n\n\n","category":"method"},{"location":"#Forces","page":"Home","title":"Forces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"forces.jl\"]","category":"page"},{"location":"#Multibody.BasicTorque-Tuple{}","page":"Home","title":"Multibody.BasicTorque","text":"BasicTorque(; name, resolve_frame = :world)\n\nLow-level torque component used to build Torque\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Damper-Tuple{}","page":"Home","title":"Multibody.Damper","text":"Damper(; d, name, kwargs)\n\nLinear damper acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = d D(s)\n\nwhere d is the (viscous) damping parameter, s is the distance between the origin of frame_a and the origin of frame_b and D(s) is the time derivative of s.\n\nArguments:\n\nd: Damping coefficient\n\nRendering\n\nradius = 0.1: Radius of damper when rendered\nlength_fraction = 0.2: Fraction of the length of the damper that is rendered\ncolor = [0.5, 0.5, 0.5, 1]: Color of the damper when rendered\n\nSee also SpringDamperParallel\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Force-Tuple{}","page":"Home","title":"Multibody.Force","text":"Force(; name, resolve_frame = :frame_b)\n\nForce acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b (default)\n\nConnectors:\n\nframe_a\nframe_b\nforce: Of type Blocks.RealInput(3). x-, y-, z-coordinates of force resolved in frame defined by resolve_frame.\n\nKeyword arguments:\n\nresolve_frame: The frame in which the cut force and cut torque are resolved. Default is :frame_b, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Spring-Tuple{}","page":"Home","title":"Multibody.Spring","text":"Spring(; c, name, m = 0, lengthfraction = 0.5, s_unstretched = 0, kwargs)\n\nLinear spring acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = c s\n\nwhere c is the spring stiffness parameter, s is the distance between the origin of frame_a and the origin of frame_b.\n\nOptionally, the mass of the spring is taken into account by a point mass located on the line between frame_a and frame_b (default: middle of the line). If the spring mass is zero, the additional equations to handle the mass are removed.\n\nArguments:\n\nc: Spring stiffness\nm: Mass of the spring (can be zero)\nlengthfraction: Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)\ns_unstretched: Length of the spring when it is unstretched\nkwargs: are passed to LineForceWithMass\n\nRendering\n\nnum_windings = 6: Number of windings of the coil when rendered\ncolor = [0,0,1,1]: Color of the spring when rendered\nradius = 0.1: Radius of spring when rendered\nN = 200: Number of points in mesh when rendered. Rendering time can be reduced somewhat by reducing this number.\n\nSee also SpringDamperParallel\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.SpringDamperParallel-Tuple{}","page":"Home","title":"Multibody.SpringDamperParallel","text":"SpringDamperParallel(; name, c, d, s_unstretched)\n\nLinear spring and linear damper in parallel acting as line force between frame_a and frame_b. A force f is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:\n\nf = c (s - s_unstretched) + d cdot D(s)\n\nwhere c, s_unstretched and d are parameters, s is the distance between the origin of frame_a and the origin of frame_b and D(s) is the time derivative of s.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Torque-Tuple{}","page":"Home","title":"Multibody.Torque","text":"Torque(; name, resolve_frame = :frame_b)\n\nTorque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b (default)\n\nConnectors:\n\nframe_a\nframe_b\ntorque: Of type Blocks.RealInput(3). x-, y-, z-coordinates of torque resolved in frame defined by resolve_frame.\n\nKeyword arguments:\n\nresolve_frame: The frame in which the cut force and cut torque are resolved. Default is :frame_b, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.WorldForce-Tuple{}","page":"Home","title":"Multibody.WorldForce","text":"WorldForce(; name, resolve_frame = :world)\n\nExternal force acting at frame_b, defined by 3 input signals and resolved in frame :world or :frame_b.\n\nConnectors:\n\nframe_b: Frame at which the force is acting\nforce: Of type Blocks.RealInput(3). x-, y-, z-coordinates of force resolved in frame defined by resolve_frame.\n\nRendering options\n\nscale = 0.1: scaling factor for the force [m/N]\ncolor = [0,1,0,0.5]: color of the force arrow in rendering\nradius = 0.05: radius of the force arrow in rendering\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.WorldTorque-Tuple{}","page":"Home","title":"Multibody.WorldTorque","text":"WorldTorque(; name, resolve_frame = :world)\n\nExternal torque acting at frame_b, defined by 3 input signals and resolved in frame :world or :frame_b.\n\nConnectors:\n\nframe_b: Frame at which the torque is acting\ntorque: Of type Blocks.RealInput(3). x-, y-, z-coordinates of torque resolved in frame defined by resolve_frame.\n\nRendering options\n\nscale = 0.1: scaling factor for the force [m/N]\ncolor = [0,1,0,0.5]: color of the force arrow in rendering\nradius = 0.05: radius of the force arrow in rendering\n\n\n\n\n\n","category":"method"},{"location":"#Sensors","page":"Home","title":"Sensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A sensor is an object that translates quantities in the mechanical domain into causal signals which can interact with causal components from ModelingToolkitStandardLibrary.Blocks, such as control systems etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody, Multibody.PlanarMechanics]\nPages   = [\"sensors.jl\", \"PlanarMechanics/sensors.jl\"]","category":"page"},{"location":"#Multibody.CutForce-Tuple{}","page":"Home","title":"Multibody.CutForce","text":"BasicCutForce(; name, resolve_frame)\n\nBasic sensor to measure cut force vector. Contains a connector of type Blocks.RealOutput with name force.\n\nresolve_frame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.CutTorque-Tuple{}","page":"Home","title":"Multibody.CutTorque","text":"CutTorque(; name, resolve_frame)\n\nBasic sensor to measure cut torque vector. Contains a connector of type Blocks.RealOutput with name torque.\n\nresolve_frame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PartialCutForceBaseSensor-Tuple{}","page":"Home","title":"Multibody.PartialCutForceBaseSensor","text":"PartialCutForceBaseSensor(; name, resolve_frame = :frame_a)\n\nresolve_frame: The frame in which the cut force and cut torque are resolved. Default is :frame_a, options include :frame_a and :world.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.Power-Tuple{}","page":"Home","title":"Multibody.Power","text":"Power(; name)\n\nA sensor measuring mechanical power transmitted from frame_a to frame_b.\n\nConnectors:\n\npower of type RealOutput.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.PartialAbsoluteBaseSensor","page":"Home","title":"Multibody.PlanarMechanics.PartialAbsoluteBaseSensor","text":"PartialAbsoluteBaseSensor(;name)\n\nPartial absolute sensor models for sensors defined by equations (frame_resolve must be connected exactly once)\n\nConnectors:\n\nframe_a: 2-dim. Coordinate system from which kinematic quantities are measured\nframe_resolve: 2-dim. Coordinate system in which vector is optionally resolved\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.PartialAbsoluteSensor","page":"Home","title":"Multibody.PlanarMechanics.PartialAbsoluteSensor","text":"PartialAbsoluteSensor(;name)\n\nPartial absolute sensor model for sensors defined by components\n\nConnectors:\n\n`frame: 2-dim. Coordinate system\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.PartialRelativeBaseSensor","page":"Home","title":"Multibody.PlanarMechanics.PartialRelativeBaseSensor","text":"PartialRelativeBaseSensor(;name)\n\nPartial relative sensor models for sensors defined by equations (frame_resolve must be connected exactly once)\n\nConnectors:\n\nframe_a: \nframe_b: \nframe_resolve: \n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.PartialRelativeSensor","page":"Home","title":"Multibody.PlanarMechanics.PartialRelativeSensor","text":"PartialRelativeSensor(;name)\n\nPartial relative sensor model for sensors defined by components\n\nConnectors:\n\nframe_a: Coordinate system a\nframe_b: Coordinate system b\n\n\n\n\n\n","category":"constant"},{"location":"#Multibody.PlanarMechanics.AbsolutePosition-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.AbsolutePosition","text":"AbsolutePosition(;name, resolve_in_frame = :frame_a)\n\nMeasure absolute position and orientation of the origin of frame connector\n\nConnectors:\n\nx: [m] x-position\ny: [m] y-position\nphi: [rad] rotation angle (counterclockwise)\n\nParameters:\n\nresolve_in_frame: Frame in which output x, y, phi is resolved (1: :world, 2: :framea, 3: :frameresolve)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.BasicAbsolutePosition-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.BasicAbsolutePosition","text":"BasicAbsolutePosition(;name, resolve_in_frame = :frame_a)\n\nMeasure absolute position and orientation (same as Sensors.AbsolutePosition, but frame_resolve is not conditional and must be connected).\n\nConnectors:\n\nx: [m] x-position\ny: [m] y-position\nphi: [rad] rotation angle (counterclockwise)\nframe_a: Coordinate system a\nframe_resolve: 2-dim. Coordinate system in which vector is optionally resolved\n\nParameters:\n\nresolve_in_frame: Frame in which output x, y, phi r is resolved (1: :world, 2: :framea, 3: :frameresolve)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.BasicRelativePosition-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.BasicRelativePosition","text":"BasicRelativePosition(; name, resolve_in_frame = :frame_a)\n\nMeasure relative position and orientation between the origins of two frame connectors\n\nConnectors:\n\nrel_x: [m] Relative x-position\nrel_y: [m] Relative y-position\nrel_phi: [rad] Relative rotation angle (counterclockwise)\nframe_a: Coordinate system a\nframe_b: Coordinate system b\nframe_resolve: \n\nParameters:\n\n- `resolve_in_frame`: Frame in which output x, y, phi is resolved (1: :world, 2: :frame_a, 3: frame_b 4: :frame_resolve)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PlanarMechanics.RelativePosition-Tuple{}","page":"Home","title":"Multibody.PlanarMechanics.RelativePosition","text":"RelativePosition(; name, resolve_in_frame = :frame_a)\n\nMeasure relative position and orientation between the origins of two frame connectors\n\nConnectors:\n\n- `rel_x`: [m] Relative x-position\n- `re_y`: [m] Relative y-position\n- `rel_phi`: [rad] Relative rotation angle (counterclockwise)\n- `frame_a`: Coordinate system a\n- `frame_b`: Coordinate system b\n\nParameters:\n\n- `resolve_in_frame`: Frame in which output x, y, phi is resolved (1: :world, 2: :frame_a, 3: frame_b 4: :frame_resolve)\n\n\n\n\n\n","category":"method"},{"location":"#Orientation-utilities","page":"Home","title":"Orientation utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody, Multibody.PlanarMechanics]\nPages   = [\"orientation.jl\"]","category":"page"},{"location":"#Multibody.RotationMatrix","page":"Home","title":"Multibody.RotationMatrix","text":"RotationMatrix\n\nA struct representing a 3D orientation as a rotation matrix.\n\nIf ODESystem is called on a RotationMatrix object o, symbolic variables for o.R and o.w are created and the value of o.R is used as the default value for the symbolic R.\n\nFields:\n\nR::R3: The rotation 3×3 matrix ∈ SO(3)\nw: The angular velocity vector\n\n\n\n\n\n","category":"type"},{"location":"#Multibody.NumRotationMatrix-Tuple{}","page":"Home","title":"Multibody.NumRotationMatrix","text":"NumRotationMatrix(; R = collect(1.0 * I(3)), w = zeros(3), name, varw = false)\n\nCreate a new RotationMatrix struct with symbolic elements. R,w determine default values.\n\nThe primary difference between NumRotationMatrix and RotationMatrix is that the NumRotationMatrix constructor is used in the constructor of a Frame in order to introduce the frame variables, whereas RorationMatrix (the struct) only wraps existing variables.\n\nvarw: If true, w is a variable, otherwise it is derived from the derivative of R as w = get_w(R).\n\nNever call this function directly from a component constructor, instead call f = Frame(); R = ori(f) and add f to the subsystems.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.absolute_rotation-Tuple{Any, Any}","page":"Home","title":"Multibody.absolute_rotation","text":"R2 = absolute_rotation(R1, Rrel)\n\nR1: Orientation object to rotate frame 0 into frame 1\nRrel: Orientation object to rotate frame 1 into frame 2\nR2: Orientation object to rotate frame 0 into frame 2\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.axes_rotations","page":"Home","title":"Multibody.axes_rotations","text":"axes_rotations(sequence, angles, der_angles; name = :R_ar)\n\nGenerate a rotation matrix for a rotation around the specified axes (Euler/Cardan angles).\n\n\n\n\n\n","category":"function"},{"location":"#Multibody.axis_rotation-Tuple{Any, Any}","page":"Home","title":"Multibody.axis_rotation","text":"axis_rotation(sequence, angle; name = :R)\n\nGenerate a rotation matrix for a rotation around the specified axis.\n\nsequence: The axis to rotate around (1: x-axis, 2: y-axis, 3: z-axis)\nangle: The angle of rotation (in radians)\n\nReturns a RotationMatrix object.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.connect_orientation-Tuple{Any, Any}","page":"Home","title":"Multibody.connect_orientation","text":"connect_orientation(R1,R2; iscut=false)\n\nConnect two rotation matrices together, optionally introducing a cut joint. A normal connection of two rotation matrices introduces 9 constraints, while a cut connection introduces 3 constraints only. This is useful to open kinematic loops, see Using cut joints (docs page) for an example where this is used.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.get_frame-Tuple{Any, Any, Any}","page":"Home","title":"Multibody.get_frame","text":"T_W_F = get_frame(sol, frame, t)\n\nExtract a 4×4 transformation matrix ∈ SE(3) from a solution at time t.\n\nThe transformation matrix returned, T_W^F, is such that when a homogenous-coordinate vector p_F, expressed in the local frame of reference F is multiplied by T_W^F as Tp, the resulting vector is p_W expressed in the world frame:\n\np_W = T_W^F  p_F\n\nSee also get_trans and get_rot, Orientations and directions (docs section).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.get_rot-Tuple{Any, Any, Any}","page":"Home","title":"Multibody.get_rot","text":"R_W_F = get_rot(sol, frame, t)\n\nExtract a 3×3 rotation matrix ∈ SO(3) from a solution at time t.\n\nThe rotation matrix returned, R_W^F, is such that when a vector p_F expressed in the local frame of reference F is multiplied by R_W^F as Rp, the resulting vector is p_W expressed in the world frame:\n\np_W = R_W^F  p_F\n\nThe columns of R_W_F indicate are the basis vectors of the frame F expressed in the world coordinate frame.\n\nSee also get_trans, get_frame, Orientations and directions (docs section).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.get_trans-Tuple{Any, Any, Number}","page":"Home","title":"Multibody.get_trans","text":"get_trans(sol, frame, t)\n\nExtract the translational part of a frame from a solution at time t. See also get_rot, get_frame, Orientations and directions (docs section).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.get_w-Tuple{AbstractMatrix}","page":"Home","title":"Multibody.get_w","text":"get_w(R)\n\nCompute the angular velocity w from the rotation matrix R and its derivative DR = D.(R).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.planar_rotation-Tuple{Any, Any, Any}","page":"Home","title":"Multibody.planar_rotation","text":"planar_rotation(axis, phi, phid)\n\nGenerate a rotation matrix for a rotation around the specified axis (axis-angle representation).\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.resolve1-Tuple{RotationMatrix, Any}","page":"Home","title":"Multibody.resolve1","text":"h1 = resolve1(R21, h2)\n\nR12 is a 3x3 matrix that transforms a vector from frame 1 to frame 2. h2 is a vector resolved in frame 2. h1 is the same vector in frame 1.\n\nTypical usage (local to world):\n\nr_wb = resolve1(ori(frame_a), r_ab)\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.resolve2-Tuple{RotationMatrix, Any}","page":"Home","title":"Multibody.resolve2","text":"h2 = resolve2(R21, h1)\n\nR21 is a 3x3 matrix that transforms a vector from frame 1 to frame 2. h1 is a vector resolved in frame 1. h2 is the same vector in frame 2.\n\nTypical usage (world to local):\n\ng_a = resolve2(ori(frame_a), a_0 - g_0)\n\n\n\n\n\n","category":"method"},{"location":"#Interfaces","page":"Home","title":"Interfaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"interfaces.jl\"]","category":"page"},{"location":"#Trajectory-planning","page":"Home","title":"Trajectory planning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two methods of planning trajectories are available","category":"page"},{"location":"","page":"Home","title":"Home","text":"point_to_point: Generate a minimum-time point-to-point trajectory with specified start and endpoints, not exceeding specified speed and acceleration limits.\ntraj5: Generate a 5:th order polynomial trajectory with specified start and end points. Additionally allows specification of start and end values for velocity and acceleration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Components that make use of these trajectory generators is provided:","category":"page"},{"location":"","page":"Home","title":"Home","text":"KinematicPTP\nKinematic5","category":"page"},{"location":"","page":"Home","title":"Home","text":"These both have output connectors of type RealOutput called q, qd, qdd for positions, velocities and accelerations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Industrial robot for an example making use of the point_to_point planner.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Multibody]\nPages   = [\"path_planning.jl\", \"ptp.jl\"]","category":"page"},{"location":"#Multibody.Kinematic5-Tuple{}","page":"Home","title":"Multibody.Kinematic5","text":"Kinematic5(; time, name, q0 = 0, q1 = 1, qd0 = 0, qd1 = 0, qdd0 = 0, qdd1 = 0)\n\nA component emitting a 5:th order polynomial trajectory created using traj5. traj5 is a simple trajectory planner that plans a 5:th order polynomial trajectory between two points, subject to specified boundary conditions on the position, velocity and acceleration.\n\nArguments\n\ntime: Time vector, e.g., 0:0.01:10\nname: Name of the component\n\nOutputs\n\nq: Position\nqd: Velocity\nqdd: Acceleration\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.KinematicPTP-Tuple{}","page":"Home","title":"Multibody.KinematicPTP","text":"KinematicPTP(; time, name, q0 = 0, q1 = 1, qd_max=1, qdd_max=1)\n\nA component emitting a trajectory created by the point_to_point trajectory generator.\n\nArguments\n\ntime: Time vector, e.g., 0:0.01:10\nname: Name of the component\nq0: Initial position\nq1: Final position\nqd_max: Maximum velocity\nqdd_max: Maximum acceleration\n\nOutputs\n\nq: Position\nqd: Velocity\nqdd: Acceleration\n\nSee also Kinematic5.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PathPlanning1-Tuple{}","page":"Home","title":"Multibody.PathPlanning1","text":"Generate reference angles for specified kinematic movement\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.PathToAxisControlBus-Tuple{}","page":"Home","title":"Multibody.PathToAxisControlBus","text":"Map path planning to one axis control bus\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.RealPassThrough-Tuple{}","page":"Home","title":"Multibody.RealPassThrough","text":"RealPassThrough(; name)\n\nPass a Real signal through without modification\n\nConnectors\n\ninput\noutput\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.traj5-Tuple{Any}","page":"Home","title":"Multibody.traj5","text":"q, qd, qdd = traj5(t; q0, q1, q̇0 = zero(q0), q̇1 = zero(q0), q̈0 = zero(q0), q̈1 = zero(q0))\n\nGenerate a 5:th order polynomial trajectory with specified end points, vels and accs.\n\nSee also point_to_point and Kinematic5.\n\n\n\n\n\n","category":"method"},{"location":"#Multibody.point_to_point-Tuple{Any}","page":"Home","title":"Multibody.point_to_point","text":"q,qd,qdd,t_end = point_to_point(time; q0 = 0.0, q1 = 1.0, t0 = 0, qd_max = 1, qdd_max = 1)\n\nGenerate a minimum-time point-to-point trajectory with specified start and endpoints, not exceeding specified speed and acceleration limits.\n\nThe trajectory produced by this function will typically exhibit piecewise constant accleration, piecewise linear velocity and piecewise quadratic position curves.\n\nIf a vector of time points is provided, the function returns matrices q,qd,qdd of size (length(time), n_dims). If a scalar time point is provided, the function returns q,qd,qdd as vectors with the specified dimension (same dimension as q0). t_end is the time at which the trajectory will reach the specified end position.\n\nArguments:\n\ntime: A scalar or a vector of time points.\nq0: Initial coordinate, may be a scalar or a vector.\nq1: End coordinate\nt0: Tiem at which the motion starts. If time contains time points before t0, the trajectory will stand still at q0 until time reaches t0.\nqd_max: Maximum allowed speed.\nqdd_max: Maximum allowed acceleration.\n\nSee also KinematicPTP and traj5.\n\n\n\n\n\n","category":"method"},{"location":"examples/gyroscopic_effects/#Gyroscopic-effects","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"","category":"section"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"(Image: animation)","category":"page"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"In this example, we demonstrate how a rotating body creates a reaction torque when its axis of rotation is changed.","category":"page"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"The system consists of a pendulum suspended in a spherical joint, a joint without any rotational constraints. The tip of the pendulum is a cylinder that is rotating around a revolute joint in its center. When the pendulum swings, the rotation axis of the rotating tip is changed, this causes the entire pendulum to rotate around the axis through the pendulum rod.","category":"page"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"using Multibody\nusing ModelingToolkit\nusing Plots\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\n\nt = Multibody.t\nD = Differential(t)\nworld = Multibody.world\n\nsystems = @named begin\n    spherical = Spherical(state=true, radius=0.02, color=[1,1,0,1], quat=true)\n    body1 = BodyCylinder(r = [0.25, 0, 0], diameter = 0.05)\n    rot = FixedRotation(; n = [0,1,0], angle=deg2rad(45))\n    revolute = Revolute(n = [1,0,0], radius=0.06, color=[1,0,0,1])\n    trans = FixedTranslation(r = [-0.1, 0, 0])\n    body2 = BodyCylinder(r = [0.2, 0, 0], diameter = 0.1, color=[0,0,0.5,1])\nend\n\nconnections = [\n    connect(world.frame_b, spherical.frame_a)\n    connect(spherical.frame_b, body1.frame_a)\n    connect(body1.frame_b, rot.frame_a)\n    connect(rot.frame_b, revolute.frame_a)\n    connect(revolute.frame_b, trans.frame_a)\n    connect(trans.frame_b, body2.frame_a)\n]\n\n@named model = ODESystem(connections, t, systems = [world; systems])\nmodel = complete(model)\nssys = structural_simplify(IRSystem(model))\n\nprob = ODEProblem(ssys, [model.world.g => 9.80665, model.revolute.w => 10], (0, 5))\n\nsol = solve(prob, FBDF(), abstol=1e-8, reltol=1e-8);\n@assert SciMLBase.successful_retcode(sol)\nusing Test # hide\n@test sol(5, idxs=collect(model.body2.r_0[1:3])) ≈ [-0.0357364, -0.188245, 0.02076935] atol=1e-3 # hide\n# plot(sol, idxs=collect(model.body2.r_0)) # hide\n\nimport GLMakie\nMultibody.render(model, sol; x=1, z=1, filename = \"gyro.gif\") # Use \"gyro.mp4\" for a video file\nnothing # hide","category":"page"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"(Image: animation)","category":"page"},{"location":"examples/gyroscopic_effects/","page":"Gyroscopic effects","title":"Gyroscopic effects","text":"Try setting model.revolute.w => 0 and plot this variable using plot(sol, idxs=model.revolute.w) and you will notice that the swinging of the pendulum induces a rotation around this joint, even if it has no rotational velocity from the start.","category":"page"}]
}
