<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Joints · Multibody.jl</title><meta name="title" content="Joints · Multibody.jl"/><meta property="og:title" content="Joints · Multibody.jl"/><meta property="twitter:title" content="Joints · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/pendulum/">Getting started: Pendulum</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="../examples/spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="../examples/three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="../examples/sensors/">Sensors</a></li><li><a class="tocitem" href="../examples/spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="../examples/gearbox/">Gearbox</a></li><li><a class="tocitem" href="../examples/free_motion/">Free motions</a></li><li><a class="tocitem" href="../examples/prescribed_pose/">Prescribed motions</a></li><li><a class="tocitem" href="../examples/kinematic_loops/">Kinematic loops</a></li><li><a class="tocitem" href="../examples/robot/">Industrial robot</a></li><li><a class="tocitem" href="../examples/ropes_and_cables/">Ropes, cables and chains</a></li><li><a class="tocitem" href="../examples/swing/">Swing</a></li><li><a class="tocitem" href="../examples/space/">Bodies in space</a></li><li><a class="tocitem" href="../examples/gyroscopic_effects/">Gyroscopic effects</a></li><li><a class="tocitem" href="../examples/wheel/">Wheels</a></li><li><a class="tocitem" href="../examples/suspension/">Suspension systems</a></li><li><a class="tocitem" href="../examples/quad/">Quadrotor with cable-suspended load</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../frames/">Frames</a></li><li class="is-active"><a class="tocitem" href>Joints</a><ul class="internal"><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../components/">Components</a></li><li><a class="tocitem" href="../forces/">Forces</a></li><li><a class="tocitem" href="../sensors/">Sensors</a></li><li><a class="tocitem" href="../trajectory_planning/">Trajectory planning</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../rotations/">Rotations and orientation</a></li><li><a class="tocitem" href="../rendering/">3D rendering</a></li><li><a class="tocitem" href="../urdf/">URDF import</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Components</a></li><li class="is-active"><a href>Joints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Joints</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Joints"><a class="docs-heading-anchor" href="#Joints">Joints</a><a id="Joints-1"></a><a class="docs-heading-anchor-permalink" href="#Joints" title="Permalink"></a></h1><p>A joint restricts the number of degrees of freedom (DOF) of a body. For example, a free floating body has 6 DOF, but if it is attached to a <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint, the joint restricts all but one rotational degree of freedom (a revolute joint acts like a hinge). Similarily, a <a href="#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint restricts all but one translational degree of freedom (a prismatic joint acts like a slider).</p><p>A <a href="#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> joints restricts all translational degrees of freedom, but allows all rotational degrees of freedom. It thus transmits no torque. A <a href="#Multibody.Planar"><code>Planar</code></a> joint moves in a plane, i.e., it restricts one translational DOF and two rotational DOF. A <a href="#Multibody.Universal-Tuple{}"><code>Universal</code></a> joint has two rotational DOF.</p><p>Some joints offer the option to add 1-dimensional components to them by providing the keyword <code>axisflange = true</code>. This allows us to add, e.g., springs, dampers, sensors, and actuators to the joint.</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><ul><li><a href="#Multibody.Planar"><code>Multibody.Planar</code></a></li><li><a href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a></li><li><a href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a></li><li><a href="#Multibody.JointRRR-Tuple{}"><code>Multibody.JointRRR</code></a></li><li><a href="#Multibody.JointUSR-Tuple{}"><code>Multibody.JointUSR</code></a></li><li><a href="#Multibody.PlanarMechanics.Prismatic-Tuple{}"><code>Multibody.PlanarMechanics.Prismatic</code></a></li><li><a href="#Multibody.PlanarMechanics.Revolute-Tuple{}"><code>Multibody.PlanarMechanics.Revolute</code></a></li><li><a href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a></li><li><a href="#Multibody.PrismaticConstraint-Tuple{}"><code>Multibody.PrismaticConstraint</code></a></li><li><a href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a></li><li><a href="#Multibody.RevolutePlanarLoopConstraint-Tuple{}"><code>Multibody.RevolutePlanarLoopConstraint</code></a></li><li><a href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a></li><li><a href="#Multibody.SphericalConstraint-Tuple{}"><code>Multibody.SphericalConstraint</code></a></li><li><a href="#Multibody.SphericalSpherical-Tuple{}"><code>Multibody.SphericalSpherical</code></a></li><li><a href="#Multibody.Universal-Tuple{}"><code>Multibody.Universal</code></a></li><li><a href="#Multibody.UniversalSpherical-Tuple{}"><code>Multibody.UniversalSpherical</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Planar" href="#Multibody.Planar"><code>Multibody.Planar</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Planar(; n = [0,0,1], n_x = [1,0,0], cylinderlength = 0.1, cylinderdiameter = 0.05, cylindercolor = [1, 0, 1, 1], boxwidth = 0.3*cylinderdiameter, boxheight = boxwidth, boxcolor = [0, 0, 1, 1])</code></pre><p>Joint where <code>frame_b</code> can move in a plane and can rotate around an axis orthogonal to the plane. The plane is defined by vector <code>n</code> which is perpendicular to the plane and by vector <code>n_x</code>, which points in the direction of the x-axis of the plane. <code>frame_a</code> and <code>frame_b</code> coincide when <code>s_x=prismatic_x.s=0, s_y=prismatic_y.s=0</code> and <code>phi=revolute.phi=0</code>.</p><p><strong>Structural parameters</strong></p><ul><li><code>n</code>: Axis orthogonal to unconstrained plane, resolved in <code>frame_a</code> (= same as in <code>frame_b</code>)</li><li><code>n_x</code>: Vector in direction of x-axis of plane, resolved in <code>frame_a</code> (<code>n_x</code> shall be orthogonal to <code>n</code>)</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the joint</li><li><code>frame_b</code>: Frame for the joint</li></ul><p><strong>Variables</strong></p><ul><li><code>s_x</code>: Relative distance along first prismatic joint starting at <code>frame_a</code></li><li><code>s_y</code>: Relative distance along second prismatic joint starting at first prismatic joint</li><li><code>phi</code>: Relative rotation angle from <code>frame_a</code> to <code>frame_b</code></li><li><code>v_x</code>: Relative velocity along first prismatic joint</li><li><code>v_y</code>: Relative velocity along second prismatic joint</li><li><code>w</code>: Relative angular velocity around revolute joint</li><li><code>a_x</code>: Relative acceleration along first prismatic joint</li><li><code>a_y</code>: Relative acceleration along second prismatic joint</li><li><code>wd</code>: Relative angular acceleration around revolute joint</li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>cylinderlength</code>: Length of the revolute cylinder</li><li><code>cylinderdiameter</code>: Diameter of the revolute cylinder</li><li><code>cylindercolor</code>: (structural) Color of the revolute cylinder</li><li><code>boxwidth</code>: Width of the prismatic joint boxes</li><li><code>boxheight</code>: Height of the prismatic joint boxes</li><li><code>boxcolor</code>: (structural) Color of the prismatic joint boxes</li><li><code>radius</code>: (structural) Radius of the revolute cylinder</li><li><code>render</code>: Enable rendering of the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L652-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FreeMotion-Tuple{}" href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FreeMotion(; name, state = true, sequence, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, phi = 0, phid = 0, phidd = 0, w_rel_b = 0, r_rel_a = 0, v_rel_a = 0, a_rel_a = 0)</code></pre><p>Joint which <em>does not</em> constrain the motion between <code>frame_a</code> and <code>frame_b</code>. Such a joint is only meaningful if the relative distance and orientation between <code>frame_a</code> and <code>frame_b</code>, and their derivatives, shall be used as state.</p><p>Note, that bodies such as <a href="../components/#Multibody.Body-Tuple{}"><code>Body</code></a>, <a href="../components/#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>, have potential state variables describing the distance and orientation, and their derivatives, between the world frame and a body fixed frame. Therefore, if these potential state variables are suited, a <code>FreeMotion</code> joint is not needed.</p><p>The state of the FreeMotion object consits of:</p><p>The relative position vector <code>r_rel_a</code> from the origin of <code>frame_a</code> to the origin of <code>frame_b</code>, resolved in <code>frame_a</code> and the relative velocity <code>v_rel_a</code> of the origin of <code>frame_b</code> with respect to the origin of <code>frame_a</code>, resolved in <code>frame_a (= D(r_rel_a))</code>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Enforce this joint having state, this is often desired and is the default choice.</li><li><code>sequence</code>: Rotation sequence, defaults to <code>[1, 2, 3]</code></li><li><code>w_rel_a_fixed</code>: = true, if <code>w_rel_a_start</code> are used as initial values, else as guess values</li><li><code>z_rel_a_fixed</code>: = true, if <code>z_rel_a_start</code> are used as initial values, else as guess values</li></ul><p><strong>Initial condition arguments:</strong></p><ul><li><code>phi</code></li><li><code>phid</code></li><li><code>phidd</code></li><li><code>w_rel_b</code></li><li><code>r_rel_a</code></li><li><code>v_rel_a</code></li><li><code>a_rel_a</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L454-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.GearConstraint-Tuple{}" href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GearConstraint(; name, ratio, checkTotalPower = false, n_a, n_b, r_a, r_b)</code></pre><p>This ideal massless joint provides a gear constraint between frames <code>frame_a</code> and <code>frame_b</code>. The axes of rotation of <code>frame_a</code> and <code>frame_b</code> may be arbitrary.</p><ul><li><code>ratio</code>: Gear ratio</li><li><code>n_a</code>: Axis of rotation of <code>frame_a</code></li><li><code>n_b</code>: Axis of rotation of <code>frame_b</code></li><li><code>r_a</code>: Vector from frame <code>bearing</code> to <code>frame_a</code> resolved in bearing</li><li><code>r_b</code>: Vector from frame <code>bearing</code> to <code>frame_b</code> resolved in bearing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L356-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.JointRRR-Tuple{}" href="#Multibody.JointRRR-Tuple{}"><code>Multibody.JointRRR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JointRRR(;
    name,
    n_a = [0,0,1],
    n_b = [0,0,1],
    rRod1_ia = [1,0,0],
    rRod2_ib = [-1,0,0],
    phi_offset = 0, 
    phi_guess = 0,

)</code></pre><p>This component consists of 3 revolute joints with parallel axes of rotation that are connected together by two rods.</p><p>This joint aggregation introduces neither constraints nor state variables and should therefore be used in kinematic loops whenever possible to avoid non-linear systems of equations. It is only meaningful to use this component in planar loops. Basically, the position and orientation of the 3 revolute joints as well as of <code>frame_ia</code>, <code>frame_ib</code>, and <code>frame_im</code> are calculated by solving analytically a non-linear equation, given the position and orientation at <code>frame_a</code> and at <code>frame_b</code>.</p><p>Connector <code>frame_a</code> is the &quot;left&quot; side of the first revolute joint whereas <code>frame_ia</code> is the &quot;right side of this revolute joint, fixed in rod 1. Connector <code>frame_b</code> is the &quot;right&quot; side of the third revolute joint whereas <code>frame_ib</code> is the &quot;left&quot; side of this revolute joint, fixed in rod 2. Finally, connector <code>frame_im</code> is the connector at the &quot;right&quot; side of the revolute joint in the middle, fixed in rod 2.</p><p>The easiest way to define the parameters of this joint is by moving the MultiBody system in a reference configuration where all frames of all components are parallel to each other (alternatively, at least <code>frame_a</code>, <code>frame_ia</code>, <code>frame_im</code>, <code>frame_ib</code>, <code>frame_b</code> of the JointRRR joint should be parallel to each other when defining an instance of this component).</p><p>Basically, the JointRRR model internally consists of a universal-spherical-revolute joint aggregation (= JointUSR). In a planar loop this will behave as if 3 revolute joints with parallel axes are connected by rigid rods.</p><p><strong>Arguments</strong></p><ul><li><code>n_a</code> Axis of revolute joints resolved in <code>frame_a</code> (all axes are parallel to each other)</li><li><code>n_b</code> Axis of revolute joint fixed and resolved in <code>frame_b</code></li><li><code>rRod1_ia</code> Vector from origin of <code>frame_a</code> to revolute joint in the middle, resolved in <code>frame_ia</code></li><li><code>rRod2_ib</code> Vector from origin of <code>frame_ib</code> to revolute joint in the middle, resolved in <code>frame_ib</code></li><li><code>phi_offset</code> Relative angle offset of revolute joint at <code>frame_b</code> <code>(angle = phi(t) + phi_offset)</code></li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code>: Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_ia</code>: Coordinate system at origin of <code>frame_a</code> fixed at connecting rod of left and middle revolute joint</li><li><code>frame_ib</code>: Coordinate system at origin of <code>frame_ib</code> fixed at connecting rod of middle and right revolute joint</li><li><code>frame_im</code>: Coordinate system at origin of revolute joint in the middle fixed at connecting rod of middle and right revolute joint</li><li><code>axis</code>: 1-dim. rotational flange that drives the right revolute joint at <code>frame_b</code></li><li><code>bearing</code>: 1-dim. rotational flange of the drive bearing of the right revolute joint at <code>frame_b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L684-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.JointUSR-Tuple{}" href="#Multibody.JointUSR-Tuple{}"><code>Multibody.JointUSR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JointUSR(;
    name,
    n1_a = [0, 0, 1],
    n_b = [0, 0, 1],
    rRod1_ia = [1, 0, 0],
    rRod1_ib = [-1, 0, 0],
    phi_offset = 0,
    phi_guess = 0,
)</code></pre><p>This component consists of a universal joint at <code>frame_a</code>, a revolute joint at <code>frame_b</code> and a spherical joint which is connected via rod1 to the universal and via rod2 to the revolute joint.</p><p>This joint aggregation has no mass and no inertia and introduces neither constraints nor potential state variables. It should be used in kinematic loops whenever possible since the non-linear system of equations introduced by this joint aggregation is solved analytically (i.e., a solution is always computed, if a unique solution exists).</p><p>The universal joint is defined in the following way:</p><ul><li>The rotation axis of revolute joint 1 is along parameter vector <code>n1_a</code> which is fixed in <code>frame_a</code>.</li><li>The rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint (= rod 1).</li></ul><p>The definition of axis 2 of the universal joint is performed according to the most often occurring case for the sake of simplicity. Otherwise, the treatment is much more complicated and the number of operations is considerably higher, if axis 2 is not orthogonal to axis 1 and to the connecting rod.</p><p>Note, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible <code>n1_a</code> should be selected in such a way that it is perpendicular to rRod1_ia in the initial configuration (i.e., the distance to the singularity is as large as possible).</p><p>The rest of this joint aggregation is defined by the following parameters:</p><ul><li><code>positive_branch</code>: The positive branch of the revolute joint is selected (cf. elbow up vs. elbow down).</li><li>The position of the spherical joint with respect to the universal joint is defined by vector <code>rRod1_ia</code>. This vector is directed from <code>frame_a</code> to the spherical joint and is resolved in <code>frame_ia</code> (it is most simple to select <code>frame_ia</code> such that it is parallel to <code>frame_a</code> in the reference or initial configuration).</li><li>The position of the spherical joint with respect to the revolute joint is defined by vector <code>rRod2_ib</code>. This vector is directed from the inner frame of the revolute joint (<code>frame_ib</code> or <code>revolute.frame_a</code>) to the spherical joint and is resolved in <code>frame_ib</code> (note, that <code>frame_ib</code> and <code>frame_b</code> are parallel to each other).</li><li>The axis of rotation of the revolute joint is defined by axis vector <code>n_b</code>. It is fixed and resolved in <code>frame_b</code>.</li><li>When specifying this joint aggregation with the definitions above, two different configurations are possible. Via parameter <code>phi_guess</code> a guess value for <code>revolute.phi(t0)</code> at the initial time <code>t0</code> is given. The configuration is selected that is closest to <code>phi_guess</code> (<code>|revolute.phi - phi_guess|</code> is minimal).</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the universal joint</li><li><code>frame_b</code>: Frame for the revolute joint</li><li>An additional <code>frame_ia</code> is present. It is fixed in the rod connecting the universal and the spherical joint at the origin of <code>frame_a</code>. The placement of <code>frame_ia</code> on the rod is implicitly defined by the universal joint (<code>frame_a</code> and <code>frame_ia</code> coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector rRod1<em>ia, the position vector from the origin of `frame</em>a<code>to the spherical joint, resolved in</code>frame_ia`.</li><li>An additional <code>frame_ib</code> is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the revolute joint that is connected to this rod (<code>= rod2.frame_a = revolute.frame_a</code>).</li><li>An additional <code>frame_im</code> is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the spherical joint that is connected to this rod (<code>= rod2.frame_b</code>). It is always parallel to <code>frame_ib</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L526-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Prismatic-Tuple{}" href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prismatic(; name, n = [0, 0, 1], axisflange = false)</code></pre><p>Prismatic joint with 1 translational degree-of-freedom</p><ul><li><code>n</code>: The axis of motion (unit vector)</li><li><code>axisflange</code>: If true, the joint will have two additional frames from Mechanical.Translational, <code>axis</code> and <code>support</code>, between which translational components such as springs and dampers can be connected.</li></ul><p>If <code>axisflange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.TranslationalModelica are also available:</p><ul><li><code>axis</code>: 1-dim. translational flange that drives the joint</li><li><code>support</code>: 1-dim. translational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul><p>The function returns an ODESystem representing the prismatic joint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PrismaticConstraint-Tuple{}" href="#Multibody.PrismaticConstraint-Tuple{}"><code>Multibody.PrismaticConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrismaticConstraint(; name, color, radius = 0.05, x_locked = true, y_locked = true, z_locked = true, render = true)</code></pre><p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of <code>frame_b</code> with respect to <code>frame_a</code>, but defines kinematic constraints between the <code>frame_a</code> and <code>frame_b</code>. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is called an implicit joint in literature.</p><p>As a consequence of the formulation, the relative kinematics between <code>frame_a</code> and <code>frame_b</code> cannot be initialized.</p><p>In complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Compare the simplification result using the classical joint formulation and this alternative formulation to check which one is more efficient for the particular system under consideration.</p><p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p><p><strong>Parameters</strong></p><ul><li><code>color</code>: Color of the joint in animations (RGBA)</li><li><code>radius</code>: Radius of the joint in animations</li><li><code>x_locked</code>: Set to false if the translational motion in x-direction shall be free</li><li><code>y_locked</code>: Set to false if the translational motion in y-direction shall be free</li><li><code>z_locked</code>: Set to false if the translational motion in z-direction shall be free</li><li><code>render</code>: Whether or not the joint is rendered in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L202-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Revolute-Tuple{}" href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Revolute(; name, phi0 = 0, w0 = 0, n, axisflange = false)</code></pre><p>Revolute joint with 1 rotational degree-of-freedom</p><ul><li><code>phi0</code>: Initial angle</li><li><code>w0</code>: Iniitial angular velocity</li><li><code>n</code>: The axis of rotation</li><li><code>axisflange</code>: If true, the joint will have two additional frames from Mechanical.Rotational, <code>axis</code> and <code>support</code>, between which rotational components such as springs and dampers can be connected.</li></ul><p>If <code>axisflange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.Rotational are also available:</p><ul><li><code>axis</code>: 1-dim. rotational flange that drives the joint</li><li><code>support</code>: 1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius = 0.05</code>: Radius of the joint in animations</li><li><code>length = radius</code>: Length of the joint in animations</li><li><code>color</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RevolutePlanarLoopConstraint-Tuple{}" href="#Multibody.RevolutePlanarLoopConstraint-Tuple{}"><code>Multibody.RevolutePlanarLoopConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RevolutePlanarLoopConstraint(; name, n)</code></pre><p>Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)</p><p>Joint where <code>frame_b</code> rotates around axis <code>n</code> which is fixed in <code>frame_a</code> and where this joint is used in a planar loop providing 2 constraint equations on position level.</p><p>If a planar loop is present, e.g., consisting of 4 revolute joints where the joint axes are all parallel to each other, then there is no unique mathematical solution if all revolute joints are modelled with <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> and the symbolic algorithms will fail. The reason is that, e.g., the cut-forces in the revolute joints perpendicular to the planar loop are not uniquely defined when 3-dim. descriptions of revolute joints are used. In this case, one revolute joint in the loop has to be replaced by model <code>RevolutePlanarLoopConstraint</code>. The effect is that from the 5 constraints of a 3-dim. revolute joint, 3 constraints are removed and replaced by appropriate known variables (e.g., the force in the direction of the axis of rotation is treated as known with value equal to zero; for standard revolute joints, this force is an unknown quantity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L575-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Spherical-Tuple{}" href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spherical(; name, state = false, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, sequence, phi = 0, phid = 0, phidd = 0, d = 0)</code></pre><p>Joint with 3 constraints that define that the origin of <code>frame_a</code> and the origin of <code>frame_b</code> coincide. By default this joint defines only the 3 constraints without any potential state variables. If parameter <code>state</code> is set to true, three states are introduced. The orientation of <code>frame_b</code> is computed by rotating <code>frame_a</code> along the axes defined in parameter vector <code>sequence</code> (default = [1,2,3], i.e., the Cardan angle sequence) around the angles used as state. If angles are used as state there is the slight disadvantage that a singular configuration is present leading to a division by zero.</p><ul><li><code>isroot</code>: Indicate that <code>frame_a</code> is the root, otherwise <code>frame_b</code> is the root. Only relevant if <code>state = true</code>.</li><li><code>sequence</code>: Rotation sequence</li><li><code>d</code>: Viscous damping constant. If <code>d &gt; 0</code>. the joint dissipates energy due to viscous damping according to <span>$τ ~ -d*ω$</span>.</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius = 0.1</code>: Radius of the joint in animations</li><li><code>color = [1,1,0,1]</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li><li><code>render = true</code>: Render the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L166-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SphericalConstraint-Tuple{}" href="#Multibody.SphericalConstraint-Tuple{}"><code>Multibody.SphericalConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalConstraint(; name, color = [1, 1, 0, 1], radius = 0.1, x_locked = true, y_locked = true, z_locked = true)</code></pre><p>Spherical cut joint and translational directions may be constrained or released</p><p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of <code>frame_b</code> with to respect to <code>frame_a</code>, but defines kinematic constraints between the <code>frame_a</code> and <code>frame_b</code>. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.</p><p>As a consequence of the formulation the relative kinematics between <code>frame_a</code> and <code>frame_b</code> cannot be initialized.</p><p>In complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare state realization chosen by <code>structural_simplify</code> using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration. In systems without closed loops the use of this implicit joint is not recommended.</p><p><strong>Arguments</strong></p><ul><li><code>x_locked</code>: Set to false if the translational motion in x-direction shall be free</li><li><code>y_locked</code>: Set to false if the translational motion in y-direction shall be free</li><li><code>z_locked</code>: Set to false if the translational motion in z-direction shall be free</li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>color</code>: Color of the joint in animations (RGBA)</li><li><code>radius</code>: Radius of the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L131-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SphericalSpherical-Tuple{}" href="#Multibody.SphericalSpherical-Tuple{}"><code>Multibody.SphericalSpherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalSpherical(; name, state = false, isroot = true, iscut=false, w_rel_a_fixed = false, r_0 = [0,0,0], color = [1, 1, 0, 1], m = 0, radius = 0.1, kinematic_constraint=true)</code></pre><p>Joint that has a spherical joint on each of its two ends. The rod connecting the two spherical joints is approximated by a point mass that is located in the middle of the rod. When the mass is set to zero (default), special code for a massless body is generated. </p><p>This joint introduces one constraint defining that the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> is constant (= rodLength). It is highly recommended to use this joint in loops whenever possible, because this enhances the efficiency considerably due to smaller systems of non-linear algebraic equations.</p><p>It is not possible to connect other components, such as a body with mass properties or a special visual shape object to the rod connecting the two spherical joints. If this is needed, use instead joint <a href="#Multibody.UniversalSpherical-Tuple{}"><code>UniversalSpherical</code></a> that has the additional frame <code>frame_ia</code> for this.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: Frame for the first spherical joint</li><li><code>frame_b</code>: Frame for the second spherical joint</li></ul><p><strong>Rendering parameters:</strong></p><ul><li><code>radius</code>: Radius of the joint in animations</li><li><code>color</code>: Color of the joint in animations (RGBA)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Universal-Tuple{}" href="#Multibody.Universal-Tuple{}"><code>Multibody.Universal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Universal(; name, n_a, n_b, phi_a = 0, phi_b = 0, w_a = 0, w_b = 0, a_a = 0, a_b = 0, state_priority=10)</code></pre><p>Joint where <code>frame_a</code> rotates around axis <code>n_a</code> which is fixed in <code>frame_a</code> and <code>frame_b</code> rotates around axis <code>n_b</code> which is fixed in <code>frame_b</code>. The two frames coincide when <code>revolute_a.phi=0</code> and <code>revolute_b.phi=0</code>. This joint has the following potential states;</p><ul><li>The relative angle <code>phi_a = revolute_a.phi</code> [rad] around axis <code>n_a</code></li><li>the relative angle <code>phi_b = revolute_b.phi</code> [rad] around axis <code>n_b</code></li><li>the relative angular velocity <code>w_a = D(phi_a)</code></li><li>the relative angular velocity <code>w_b = D(phi_b)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/joints.jl#L275-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.UniversalSpherical-Tuple{}" href="#Multibody.UniversalSpherical-Tuple{}"><code>Multibody.UniversalSpherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniversalSpherical(; name, n1_a, rRod_ia, sphere_diameter = 0.1, sphere_color, rod_width = 0.1, rod_height = 0.1, rod_color, cylinder_length = 0.1, cylinder_diameter = 0.1, cylinder_color, kinematic_constraint = true)</code></pre><p>Universal - spherical joint aggregation (1 constraint, no potential states)</p><p>This component consists of a universal joint at <code>frame_a</code> and a spherical joint at <code>frame_b</code> that are connected together with a rigid rod.</p><p>This joint aggregation has no mass and no inertia and introduces the constraint that the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> is constant (= <code>length(rRod_ia)</code>). The universal joint is defined in the following way:</p><ul><li>The rotation axis of revolute joint 1 is along parameter vector <code>n1_a</code> which is fixed in <code>frame_a</code>.</li><li>The rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint.</li></ul><p>Note, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible <code>n1_a</code> should be selected in such a way that it is perpendicular to <code>rRod_ia</code> in the initial configuration (i.e., the distance to the singularity is as large as possible).</p><p>An additional <code>frame_ia</code> is present. It is fixed in the connecting rod at the origin of <code>frame_a</code>. The placement of <code>frame_ia</code> on the rod is implicitly defined by the universal joint (<code>frame_a</code> and <code>frame_ia</code> coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector <code>rRod_ia</code>, the position vector from the origin of <code>frame_a</code> to the origin of <code>frame_b</code>, resolved in <code>frame_ia</code>.</p><p>This joint aggregation can be used in cases where in reality a rod with spherical joints at end are present. Such a system has an additional degree of freedom to rotate the rod along its axis. In practice this rotation is usually of no interest and is mathematically removed by replacing one of the spherical joints by a universal joint. Still, in most cases the <a href="#Multibody.SphericalSpherical-Tuple{}"><code>SphericalSpherical</code></a> joint aggregation can be used instead of the UniversalSpherical joint since the rod is animated and its mass properties are approximated by a point mass in the middle of the rod. The <a href="#Multibody.SphericalSpherical-Tuple{}"><code>SphericalSpherical</code></a> joint has the advantage that it does not have a singular configuration.</p><p><strong>Arguments</strong></p><ul><li><code>n1_a</code> Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)</li><li><code>rRod_ia</code> Vector from origin of frame<em>a to origin of frame</em>b, resolved in <code>frame_ia</code> (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)</li><li><code>kinematic_constraint = true</code> Set to false if no constraint shall be defined, due to analytically solving a kinematic loop</li><li><code>constraint_residue</code> If set to <code>:external</code>, an equation in the parent system is expected to define this variable, e.g., <code>rod.constraint_residue ~ rod.f_rod - f_rod</code> where <code>rod</code> is the name of the UniversalSpherical joint. If unspecified, the length constraint <code>rRod_0&#39;rRod_0 - rodLength&#39;rodLength</code> is used</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the universal joint</li><li><code>frame_b</code>: Frame for the spherical joint</li><li><code>frame_ia</code>: Frame fixed in the rod at the origin of <code>frame_a</code></li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>sphere_diameter</code>: Diameter of spheres representing the universal and the spherical joint</li><li><code>sphere_color</code>: Color of spheres representing the universal and the spherical joint (RGBA)</li><li><code>rod_width</code>: Width of rod shape in direction of axis 2 of universal joint</li><li><code>rod_height</code>: Height of rod shape in direction that is orthogonal to rod and to axis 2</li><li><code>rod_color</code>: Color of rod shape connecting the universal and the spherical joints (RGBA)</li><li><code>cylinder_length</code>: Length of cylinders representing the two universal joint axes</li><li><code>cylinder_diameter</code>: Diameter of cylinders representing the two universal joint axes</li><li><code>cylinder_color</code>: Color of cylinders representing the two universal joint axes (RGBA)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/fancy_joints.jl#L266-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Prismatic-Tuple{}" href="#Multibody.PlanarMechanics.Prismatic-Tuple{}"><code>Multibody.PlanarMechanics.Prismatic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prismatic(; name, f, s = 0, axisflange = false)</code></pre><p>A prismatic joint</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: [m, m] x,y-direction of the rod wrt. body system at phi=0</li><li><code>axisflange=false</code>: If <code>true</code>, a force flange is enabled, otherwise implicitly grounded&quot;</li><li><code>render</code>: Render the joint in animations</li><li><code>radius</code>: Radius of the body in animations</li><li><code>color</code>: Color of the body in animations</li></ul><p><strong>Variables</strong></p><ul><li><code>s(t)</code>: [m] Elongation of the joint</li><li><code>v(t)</code>: [m/s] Velocity of elongation</li><li><code>a(t)</code>: [m/s²] Acceleration of elongation</li><li><code>f(t)</code>: [N] Force in direction of elongation</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>fixed</code> <a href="../components/#Multibody.PlanarMechanics.Fixed">Fixed</a> if <code>axisflange == false</code></li><li><code>flange_a</code> <a href="@ref">Flange</a> if <code>axisflange == true</code></li><li><code>support</code> <a href="@ref">Support</a> if <code>axisflange == true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/PlanarMechanics/joints.jl#L84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Revolute-Tuple{}" href="#Multibody.PlanarMechanics.Revolute-Tuple{}"><code>Multibody.PlanarMechanics.Revolute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Revolute(; name, phi = 0.0, tau = 0.0, axisflange = false)</code></pre><p>A revolute joint</p><p><strong>Parameters:</strong></p><ul><li><code>axisflange=false</code>: If <code>true</code>, a force flange is enabled, otherwise implicitly grounded&quot;</li><li><code>phi</code>: [rad] Initial angular position for the flange</li><li><code>tau</code>: [Nm] Initial Cut torque in the flange</li></ul><p><strong>Variables:</strong></p><ul><li><code>phi(t)</code>: [rad] angular position</li><li><code>w(t)</code>: [rad/s] angular velocity</li><li><code>α(t)</code>: [rad/s²] angular acceleration</li><li><code>tau(t)</code>: [Nm] torque</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>frame_b</code> <a href="../frames/#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>fixed</code> <a href="../components/#Multibody.PlanarMechanics.Fixed">Fixed</a> if <code>axisflange == false</code></li><li><code>flange_a</code> <a href="@ref">Flange</a> if <code>axisflange == true</code></li><li><code>support</code> <a href="@ref">Support</a> if <code>axisflange == true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/8e70a4f3a28ff2cb4b092fe1eb853ba7879e6011/src/PlanarMechanics/joints.jl#L1-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../frames/">« Frames</a><a class="docs-footer-nextpage" href="../components/">Components »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 2 October 2024 16:54">Wednesday 2 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
