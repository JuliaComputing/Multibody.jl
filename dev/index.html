<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Multibody.jl</title><meta name="title" content="Home · Multibody.jl"/><meta property="og:title" content="Home · Multibody.jl"/><meta property="twitter:title" content="Home · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Example-overview"><span>Example overview</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Notable-differences-from-Modelica"><span>Notable differences from Modelica</span></a></li><li><a class="tocitem" href="#2D-and-3D-modeling"><span>2D and 3D modeling</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Frames"><span>Frames</span></a></li><li><a class="tocitem" href="#Joints"><span>Joints</span></a></li><li><a class="tocitem" href="#Components"><span>Components</span></a></li><li><a class="tocitem" href="#Forces"><span>Forces</span></a></li><li><a class="tocitem" href="#Sensors"><span>Sensors</span></a></li><li><a class="tocitem" href="#Orientation-utilities"><span>Orientation utilities</span></a></li><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li><li><a class="tocitem" href="#Trajectory-planning"><span>Trajectory planning</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="examples/pendulum/">Getting started: Pendulum</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="examples/spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="examples/three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="examples/sensors/">Sensors</a></li><li><a class="tocitem" href="examples/spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="examples/gearbox/">Gearbox</a></li><li><a class="tocitem" href="examples/free_motion/">Free motions</a></li><li><a class="tocitem" href="examples/kinematic_loops/">Kinematic loops</a></li><li><a class="tocitem" href="examples/robot/">Industrial robot</a></li><li><a class="tocitem" href="examples/ropes_and_cables/">Ropes, cables and chains</a></li><li><a class="tocitem" href="examples/swing/">Swing</a></li><li><a class="tocitem" href="examples/space/">Bodies in space</a></li><li><a class="tocitem" href="examples/gyroscopic_effects/">Gyroscopic effects</a></li><li><a class="tocitem" href="examples/wheel/">Wheels</a></li><li><a class="tocitem" href="examples/suspension/">Suspension systems</a></li><li><a class="tocitem" href="examples/quad/">Quadrotor with cable-suspended load</a></li></ul></li><li><a class="tocitem" href="rotations/">Rotations and orientation</a></li><li><a class="tocitem" href="rendering/">3D rendering</a></li><li><a class="tocitem" href="urdf/">URDF import</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multibody"><a class="docs-heading-anchor" href="#Multibody">Multibody</a><a id="Multibody-1"></a><a class="docs-heading-anchor-permalink" href="#Multibody" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/JuliaComputing/Multibody.jl">Multibody</a>.</p><p><img src="JuliaSim_logo.gif" alt="animated logo"/></p><p>Welcome to the world of Multibody.jl, a powerful and flexible component of JuliaSim designed to model, analyze, and simulate multibody systems in Julia. As a state-of-the-art tool, Multibody.jl enables users to efficiently study the dynamics of complex mechanical systems in various fields, such as robotics, biomechanics, aerospace, and vehicle dynamics.</p><p>Built on top of the Julia language and the JuliaSim suite of tools for modeling, simulation, optimization and control, Multibody.jl harnesses the power of Julia&#39;s high-performance computing capabilities, making it a go-to choice for both researchers and engineers who require fast simulations and real-time performance. With an intuitive syntax and a comprehensive set of features, this package seamlessly integrates with other Julia and JuliaSim libraries, enabling users to tackle diverse and sophisticated problems in multibody dynamics.</p><p>In this documentation, you will find everything you need to get started with Multibody.jl, from basic component descriptions to detailed examples showcasing the package&#39;s capabilities. As you explore this documentation, you&#39;ll learn how to create complex models, work with forces and torques, simulate various types of motions, and visualize your results in both 2D and 3D. Whether you are a seasoned researcher or a newcomer to the field, Multibody.jl will empower you to bring your ideas to life and unlock new possibilities in the fascinating world of multibody dynamics.</p><h2 id="Example-overview"><a class="docs-heading-anchor" href="#Example-overview">Example overview</a><a id="Example-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Example-overview" title="Permalink"></a></h2><p>The following animations give a quick overview of simple mechanisms that can be modeled using Multibody.jl. The examples are ordered from simple at the top, to more advanced at the bottom. Please browse the examples for even more examples!</p><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF Grid</title>
    <style>
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(4, auto);
            gap: 10px;
            padding: 20px;
        }
        .grid-item {
            width: 100%;
            height: auto;
        }
        .grid-item img {
            width: 100%;
            height: auto;
            display: block;
        }
    </style>
</head>
<body>

<div class="grid-container">
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/pendulum/">
        <img src="https://help.juliahub.com/multibody/dev/examples/furuta.gif" alt="Furuta">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/spring_damper_system/">
        <img src="https://help.juliahub.com/multibody/dev/examples/springdamper.gif" alt="springdamper">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/wheel/">
        <img src="https://help.juliahub.com/multibody/dev/examples/wheelset.gif" alt="wheels">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/three_springs/">
        <img src="https://help.juliahub.com/multibody/dev/examples/three_springs.gif" alt="three_springs">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/space/">
        <img src="https://help.juliahub.com/multibody/dev/examples/space.gif" alt="space">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/free_motion/#Body-suspended-in-springs">
        <img src="https://help.juliahub.com/multibody/dev/examples/free_body.gif" alt="free_body">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/ropes_and_cables/">
        <img src="https://help.juliahub.com/multibody/dev/examples/flexible_rope.gif" alt="flexible_rope">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/ropes_and_cables/">
        <img src="https://help.juliahub.com/multibody/dev/examples/mounted_chain.gif" alt="mounted_chain">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/quad/">
        <img src="https://help.juliahub.com/multibody/dev/examples/quadrotor.gif" alt="quadrotor">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/kinematic_loops/">
        <img src="https://help.juliahub.com/multibody/dev/examples/fourbar2.gif" alt="fourbar2">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/kinematic_loops/">
        <img src="https://help.juliahub.com/multibody/dev/examples/fourbar.gif" alt="fourbar">
    </a>
    <a class="grid-item" href="https://help.juliahub.com/multibody/dev/examples/robot/">
        <img src="https://help.juliahub.com/multibody/dev/examples/robot.gif" alt="robot">
    </a>
</div>

</body>
</html><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install this library, first follow the <a href="https://juliacomputing.github.io/JuliaSimCompiler.jl/stable/#Installing-and-Using-JuliaSimCompiler">installation instructions for JuliaSimCompiler</a>. In particular, you need to <a href="https://help.juliahub.com/juliasim/dev/gettingstarted/juliahubregistry/">add the JuliaHub Registry</a>. </p><p>After the registry is added and JuliaSimCompiler is installed, you may install this package using</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;Multibody&quot;)</code></pre><h2 id="Notable-differences-from-Modelica"><a class="docs-heading-anchor" href="#Notable-differences-from-Modelica">Notable differences from Modelica</a><a id="Notable-differences-from-Modelica-1"></a><a class="docs-heading-anchor-permalink" href="#Notable-differences-from-Modelica" title="Permalink"></a></h2><ul><li>The torque variable in Multibody.jl is typically called <code>tau</code> rather than <code>t</code> to not conflict with the often used independent variable <code>t</code> used to denote time.</li><li>Multibody.jl occasionally requires the user to specify which component should act as the root of the kinematic tree. This only occurs when bodies are connected directly to force components without a joint parallel to the force component.</li><li>In Multibody.jl, the orientation object of a <a href="#Multibody.Frame"><code>Frame</code></a> is accessed using the function <a href="#Multibody.ori"><code>ori</code></a>.</li><li>Quaternions in Multibody.jl follow the order <span>$[s, i, j, k]$</span>, i.e., scalar/real part first.</li></ul><h2 id="2D-and-3D-modeling"><a class="docs-heading-anchor" href="#2D-and-3D-modeling">2D and 3D modeling</a><a id="2D-and-3D-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#2D-and-3D-modeling" title="Permalink"></a></h2><p>Multibody.jl offers components for modeling in both 2D and 3D. 2D modeling, often referred to as planar mechanics, is a subset of 3D modeling where the motion is constrained to a plane, the x,y plane. Planar mechanics is sometimes referred to as 3 degrees of freedom (DOF) modeling, referring to the 2 translational DOF and one rotational DOF that the plane offers. Most components in Multibody.jl are aimed at 3D modeling (sometimes referred to as 6 DOF modeling), but components for 2D modeling exist in the submodule <code>Multibody.PlanarMechanics</code>.</p><p>The components from <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/mechanical/"><code>ModelingToolkitStandardLibrary.Mechanical</code></a> are 1D, i.e., a single degree of freedom only. These components can be used in both 2D and 3D modeling together with Multibody components that have support for attaching 1D components, such as joints supporting the <code>axisflange</code> keyword.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Multibody.BodyBox"><code>Multibody.BodyBox</code></a></li><li><a href="#Multibody.BodyCylinder"><code>Multibody.BodyCylinder</code></a></li><li><a href="#Multibody.Planar"><code>Multibody.Planar</code></a></li><li><a href="#Multibody.PlanarMechanics.BodyShape"><code>Multibody.PlanarMechanics.BodyShape</code></a></li><li><a href="#Multibody.PlanarMechanics.Damper"><code>Multibody.PlanarMechanics.Damper</code></a></li><li><a href="#Multibody.PlanarMechanics.DifferentialGear"><code>Multibody.PlanarMechanics.DifferentialGear</code></a></li><li><a href="#Multibody.PlanarMechanics.Fixed"><code>Multibody.PlanarMechanics.Fixed</code></a></li><li><a href="#Multibody.PlanarMechanics.FixedTranslation"><code>Multibody.PlanarMechanics.FixedTranslation</code></a></li><li><a href="#Multibody.PlanarMechanics.IdealPlanetary"><code>Multibody.PlanarMechanics.IdealPlanetary</code></a></li><li><a href="#Multibody.PlanarMechanics.PartialAbsoluteBaseSensor"><code>Multibody.PlanarMechanics.PartialAbsoluteBaseSensor</code></a></li><li><a href="#Multibody.PlanarMechanics.PartialAbsoluteSensor"><code>Multibody.PlanarMechanics.PartialAbsoluteSensor</code></a></li><li><a href="#Multibody.PlanarMechanics.PartialRelativeBaseSensor"><code>Multibody.PlanarMechanics.PartialRelativeBaseSensor</code></a></li><li><a href="#Multibody.PlanarMechanics.PartialRelativeSensor"><code>Multibody.PlanarMechanics.PartialRelativeSensor</code></a></li><li><a href="#Multibody.PlanarMechanics.PartialTwoFrames"><code>Multibody.PlanarMechanics.PartialTwoFrames</code></a></li><li><a href="#Multibody.PlanarMechanics.SimpleWheel"><code>Multibody.PlanarMechanics.SimpleWheel</code></a></li><li><a href="#Multibody.PlanarMechanics.Spring"><code>Multibody.PlanarMechanics.Spring</code></a></li><li><a href="#Multibody.PlanarMechanics.SpringDamper"><code>Multibody.PlanarMechanics.SpringDamper</code></a></li><li><a href="#Multibody.PlanarMechanics.ZeroPosition"><code>Multibody.PlanarMechanics.ZeroPosition</code></a></li><li><a href="#Multibody.world"><code>Multibody.world</code></a></li><li><a href="#Multibody.RotationMatrix"><code>Multibody.RotationMatrix</code></a></li><li><a href="#Multibody.AccSensor-Tuple{}"><code>Multibody.AccSensor</code></a></li><li><a href="#Multibody.AxisControlBus-Tuple{}"><code>Multibody.AxisControlBus</code></a></li><li><a href="#Multibody.AxisType2-Tuple{}"><code>Multibody.AxisType2</code></a></li><li><a href="#Multibody.BasicTorque-Tuple{}"><code>Multibody.BasicTorque</code></a></li><li><a href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a></li><li><a href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a></li><li><a href="#Multibody.CutForce-Tuple{}"><code>Multibody.CutForce</code></a></li><li><a href="#Multibody.CutTorque-Tuple{}"><code>Multibody.CutTorque</code></a></li><li><a href="#Multibody.Damper-Tuple{}"><code>Multibody.Damper</code></a></li><li><a href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a></li><li><a href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a></li><li><a href="#Multibody.Force-Tuple{}"><code>Multibody.Force</code></a></li><li><a href="#Multibody.Frame"><code>Multibody.Frame</code></a></li><li><a href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a></li><li><a href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a></li><li><a href="#Multibody.JointRRR-Tuple{}"><code>Multibody.JointRRR</code></a></li><li><a href="#Multibody.JointUSR-Tuple{}"><code>Multibody.JointUSR</code></a></li><li><a href="#Multibody.Kinematic5-Tuple{}"><code>Multibody.Kinematic5</code></a></li><li><a href="#Multibody.KinematicPTP-Tuple{}"><code>Multibody.KinematicPTP</code></a></li><li><a href="#Multibody.NumRotationMatrix-Tuple{}"><code>Multibody.NumRotationMatrix</code></a></li><li><a href="#Multibody.PartialCutForceBaseSensor-Tuple{}"><code>Multibody.PartialCutForceBaseSensor</code></a></li><li><a href="#Multibody.PathPlanning1-Tuple{}"><code>Multibody.PathPlanning1</code></a></li><li><a href="#Multibody.PathToAxisControlBus-Tuple{}"><code>Multibody.PathToAxisControlBus</code></a></li><li><a href="#Multibody.PlanarMechanics.AbsolutePosition-Tuple{}"><code>Multibody.PlanarMechanics.AbsolutePosition</code></a></li><li><a href="#Multibody.PlanarMechanics.BasicAbsolutePosition-Tuple{}"><code>Multibody.PlanarMechanics.BasicAbsolutePosition</code></a></li><li><a href="#Multibody.PlanarMechanics.BasicRelativePosition-Tuple{}"><code>Multibody.PlanarMechanics.BasicRelativePosition</code></a></li><li><a href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Multibody.PlanarMechanics.Body</code></a></li><li><a href="#Multibody.PlanarMechanics.Frame"><code>Multibody.PlanarMechanics.Frame</code></a></li><li><a href="#Multibody.PlanarMechanics.Prismatic-Tuple{}"><code>Multibody.PlanarMechanics.Prismatic</code></a></li><li><a href="#Multibody.PlanarMechanics.RelativePosition-Tuple{}"><code>Multibody.PlanarMechanics.RelativePosition</code></a></li><li><a href="#Multibody.PlanarMechanics.Revolute-Tuple{}"><code>Multibody.PlanarMechanics.Revolute</code></a></li><li><a href="#Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}"><code>Multibody.PlanarMechanics.SlipBasedWheelJoint</code></a></li><li><a href="#Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_form</code></a></li><li><a href="#Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_triple</code></a></li><li><a href="#Multibody.Power-Tuple{}"><code>Multibody.Power</code></a></li><li><a href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a></li><li><a href="#Multibody.PrismaticConstraint-Tuple{}"><code>Multibody.PrismaticConstraint</code></a></li><li><a href="#Multibody.RealPassThrough-Tuple{}"><code>Multibody.RealPassThrough</code></a></li><li><a href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a></li><li><a href="#Multibody.RevolutePlanarLoopConstraint-Tuple{}"><code>Multibody.RevolutePlanarLoopConstraint</code></a></li><li><a href="#Multibody.RollingConstraintVerticalWheel-Tuple{}"><code>Multibody.RollingConstraintVerticalWheel</code></a></li><li><a href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a></li><li><a href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a></li><li><a href="#Multibody.RollingWheelSet-Tuple{}"><code>Multibody.RollingWheelSet</code></a></li><li><a href="#Multibody.RollingWheelSetJoint-Tuple{}"><code>Multibody.RollingWheelSetJoint</code></a></li><li><a href="#Multibody.Rope-Tuple{}"><code>Multibody.Rope</code></a></li><li><a href="#Multibody.SlipWheelJoint-Tuple{}"><code>Multibody.SlipWheelJoint</code></a></li><li><a href="#Multibody.SlippingWheel-Tuple{}"><code>Multibody.SlippingWheel</code></a></li><li><a href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a></li><li><a href="#Multibody.SphericalConstraint-Tuple{}"><code>Multibody.SphericalConstraint</code></a></li><li><a href="#Multibody.SphericalSpherical-Tuple{}"><code>Multibody.SphericalSpherical</code></a></li><li><a href="#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a></li><li><a href="#Multibody.SpringDamperParallel-Tuple{}"><code>Multibody.SpringDamperParallel</code></a></li><li><a href="#Multibody.Torque-Tuple{}"><code>Multibody.Torque</code></a></li><li><a href="#Multibody.Universal-Tuple{}"><code>Multibody.Universal</code></a></li><li><a href="#Multibody.UniversalSpherical-Tuple{}"><code>Multibody.UniversalSpherical</code></a></li><li><a href="#Multibody.World-Tuple{}"><code>Multibody.World</code></a></li><li><a href="#Multibody.WorldForce-Tuple{}"><code>Multibody.WorldForce</code></a></li><li><a href="#Multibody.WorldTorque-Tuple{}"><code>Multibody.WorldTorque</code></a></li><li><a href="#Multibody.absolute_rotation-Tuple{Any, Any}"><code>Multibody.absolute_rotation</code></a></li><li><a href="#Multibody.axes_rotations"><code>Multibody.axes_rotations</code></a></li><li><a href="#Multibody.axis_rotation-Tuple{Any, Any}"><code>Multibody.axis_rotation</code></a></li><li><a href="#Multibody.connect_orientation-Tuple{Any, Any}"><code>Multibody.connect_orientation</code></a></li><li><a href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>Multibody.get_frame</code></a></li><li><a href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>Multibody.get_rot</code></a></li><li><a href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>Multibody.get_trans</code></a></li><li><a href="#Multibody.get_w-Tuple{AbstractMatrix}"><code>Multibody.get_w</code></a></li><li><a href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a></li><li><a href="#Multibody.ori"><code>Multibody.ori</code></a></li><li><a href="#Multibody.planar_rotation-Tuple{Any, Any, Any}"><code>Multibody.planar_rotation</code></a></li><li><a href="#Multibody.point_to_point-Tuple{Any}"><code>Multibody.point_to_point</code></a></li><li><a href="rendering/#Multibody.render"><code>Multibody.render</code></a></li><li><a href="rendering/#Multibody.render!"><code>Multibody.render!</code></a></li><li><a href="#Multibody.resolve1-Tuple{RotationMatrix, Any}"><code>Multibody.resolve1</code></a></li><li><a href="#Multibody.resolve2-Tuple{RotationMatrix, Any}"><code>Multibody.resolve2</code></a></li><li><a href="#Multibody.traj5-Tuple{Any}"><code>Multibody.traj5</code></a></li><li><a href="urdf/#Multibody.urdf2multibody"><code>Multibody.urdf2multibody</code></a></li></ul><h2 id="Frames"><a class="docs-heading-anchor" href="#Frames">Frames</a><a id="Frames-1"></a><a class="docs-heading-anchor-permalink" href="#Frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Frame" href="#Multibody.Frame"><code>Multibody.Frame</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Frame(; name)</code></pre><p><code>Frame</code> is the fundamental 3D connector in the multibody library. Most components have one or several <code>Frame</code> connectors that can be connected together.</p><p>The <code>Frame</code> connector has internal variables for</p><ul><li><code>r_0</code>: The position vector from the world frame to the frame origin, resolved in the world frame</li><li><code>f</code>: The cut force resolved in the connector frame</li><li><code>tau</code>: The cut torque resolved in the connector frame</li><li>Depending on usage, also rotation and rotational velocity variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/frames.jl#L27-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.PartialTwoFrames" href="#Multibody.PlanarMechanics.PartialTwoFrames"><code>Multibody.PlanarMechanics.PartialTwoFrames</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialTwoFrames(;name)</code></pre><p>Partial model with two frames</p><p><strong>Connectors:</strong></p><pre><code class="nohighlight hljs">- `frame_a` [Frame](@ref) Coordinate system fixed to the component with one cut-force and cut-torque
- `frame_b` [Frame](@ref) Coordinate system fixed to the component with one cut-force and cut-torque</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/utils.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.ZeroPosition" href="#Multibody.PlanarMechanics.ZeroPosition"><code>Multibody.PlanarMechanics.ZeroPosition</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroPosition(;name)</code></pre><p>Set zero position vector and orientation object of frame_resolve</p><p><strong>Connectors:</strong></p><pre><code class="nohighlight hljs">- `frame_resolve` [FrameResolve](@ref) Coordinate system fixed to the component with one cut-force and cut-torque</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/utils.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Frame" href="#Multibody.PlanarMechanics.Frame"><code>Multibody.PlanarMechanics.Frame</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Frame(;name)</code></pre><p>Coordinate system (2-dim.) fixed to the component with one cut-force and cut-torque</p><p><strong>Variables:</strong></p><ul><li><code>x</code>: [m] x position</li><li><code>y</code>: [m] y position</li><li><code>phi</code>: [rad] rotation angle (counterclockwise)</li><li><code>fx</code>: [N] force in the x direction</li><li><code>fy</code>: [N] force in the y direction</li><li><code>tau</code>: [N.m] torque (clockwise)</li></ul><p><strong>Parameters:</strong></p><ul><li><code>render</code>: [Bool] Render the joint in animations</li><li><code>length</code>: [m] Length of each axis in animations</li><li><code>radius</code>: [m] Radius of each axis in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/utils.jl#L18-L35">source</a></section></article><h2 id="Joints"><a class="docs-heading-anchor" href="#Joints">Joints</a><a id="Joints-1"></a><a class="docs-heading-anchor-permalink" href="#Joints" title="Permalink"></a></h2><p>A joint restricts the number of degrees of freedom (DOF) of a body. For example, a free floating body has 6 DOF, but if it is attached to a <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint, the joint restricts all but one rotational degree of freedom (a revolute joint acts like a hinge). Similarily, a <a href="#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint restricts all but one translational degree of freedom (a prismatic joint acts like a slider).</p><p>A <a href="#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> joints restricts all translational degrees of freedom, but allows all rotational degrees of freedom. It thus transmits no torque. A <a href="#Multibody.Planar"><code>Planar</code></a> joint moves in a plane, i.e., it restricts one translational DOF and two rotational DOF. A <a href="#Multibody.Universal-Tuple{}"><code>Universal</code></a> joint has two rotational DOF.</p><p>Some joints offer the option to add 1-dimensional components to them by providing the keyword <code>axisflange = true</code>. This allows us to add, e.g., springs, dampers, sensors, and actuators to the joint.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Planar" href="#Multibody.Planar"><code>Multibody.Planar</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Planar(; n = [0,0,1], n_x = [1,0,0], cylinderlength = 0.1, cylinderdiameter = 0.05, cylindercolor = [1, 0, 1, 1], boxwidth = 0.3*cylinderdiameter, boxheight = boxwidth, boxcolor = [0, 0, 1, 1])</code></pre><p>Joint where <code>frame_b</code> can move in a plane and can rotate around an axis orthogonal to the plane. The plane is defined by vector <code>n</code> which is perpendicular to the plane and by vector <code>n_x</code>, which points in the direction of the x-axis of the plane. <code>frame_a</code> and <code>frame_b</code> coincide when <code>s_x=prismatic_x.s=0, s_y=prismatic_y.s=0</code> and <code>phi=revolute.phi=0</code>.</p><p><strong>Structural parameters</strong></p><ul><li><code>n</code>: Axis orthogonal to unconstrained plane, resolved in <code>frame_a</code> (= same as in <code>frame_b</code>)</li><li><code>n_x</code>: Vector in direction of x-axis of plane, resolved in <code>frame_a</code> (<code>n_x</code> shall be orthogonal to <code>n</code>)</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the joint</li><li><code>frame_b</code>: Frame for the joint</li></ul><p><strong>Variables</strong></p><ul><li><code>s_x</code>: Relative distance along first prismatic joint starting at <code>frame_a</code></li><li><code>s_y</code>: Relative distance along second prismatic joint starting at first prismatic joint</li><li><code>phi</code>: Relative rotation angle from <code>frame_a</code> to <code>frame_b</code></li><li><code>v_x</code>: Relative velocity along first prismatic joint</li><li><code>v_y</code>: Relative velocity along second prismatic joint</li><li><code>w</code>: Relative angular velocity around revolute joint</li><li><code>a_x</code>: Relative acceleration along first prismatic joint</li><li><code>a_y</code>: Relative acceleration along second prismatic joint</li><li><code>wd</code>: Relative angular acceleration around revolute joint</li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>cylinderlength</code>: Length of the revolute cylinder</li><li><code>cylinderdiameter</code>: Diameter of the revolute cylinder</li><li><code>cylindercolor</code>: (structural) Color of the revolute cylinder</li><li><code>boxwidth</code>: Width of the prismatic joint boxes</li><li><code>boxheight</code>: Height of the prismatic joint boxes</li><li><code>boxcolor</code>: (structural) Color of the prismatic joint boxes</li><li><code>radius</code>: (structural) Radius of the revolute cylinder</li><li><code>render</code>: Enable rendering of the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L652-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FreeMotion-Tuple{}" href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FreeMotion(; name, state = true, sequence, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, phi = 0, phid = 0, phidd = 0, w_rel_b = 0, r_rel_a = 0, v_rel_a = 0, a_rel_a = 0)</code></pre><p>Joint which <em>does not</em> constrain the motion between <code>frame_a</code> and <code>frame_b</code>. Such a joint is only meaningful if the relative distance and orientation between <code>frame_a</code> and <code>frame_b</code>, and their derivatives, shall be used as state.</p><p>Note, that bodies such as <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>, have potential state variables describing the distance and orientation, and their derivatives, between the world frame and a body fixed frame. Therefore, if these potential state variables are suited, a <code>FreeMotion</code> joint is not needed.</p><p>The state of the FreeMotion object consits of:</p><p>The relative position vector <code>r_rel_a</code> from the origin of <code>frame_a</code> to the origin of <code>frame_b</code>, resolved in <code>frame_a</code> and the relative velocity <code>v_rel_a</code> of the origin of <code>frame_b</code> with respect to the origin of <code>frame_a</code>, resolved in <code>frame_a (= D(r_rel_a))</code>.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Enforce this joint having state, this is often desired and is the default choice.</li><li><code>sequence</code>: Rotation sequence, defaults to <code>[1, 2, 3]</code></li><li><code>w_rel_a_fixed</code>: = true, if <code>w_rel_a_start</code> are used as initial values, else as guess values</li><li><code>z_rel_a_fixed</code>: = true, if <code>z_rel_a_start</code> are used as initial values, else as guess values</li></ul><p><strong>Initial condition arguments:</strong></p><ul><li><code>phi</code></li><li><code>phid</code></li><li><code>phidd</code></li><li><code>w_rel_b</code></li><li><code>r_rel_a</code></li><li><code>v_rel_a</code></li><li><code>a_rel_a</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L454-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.GearConstraint-Tuple{}" href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GearConstraint(; name, ratio, checkTotalPower = false, n_a, n_b, r_a, r_b)</code></pre><p>This ideal massless joint provides a gear constraint between frames <code>frame_a</code> and <code>frame_b</code>. The axes of rotation of <code>frame_a</code> and <code>frame_b</code> may be arbitrary.</p><ul><li><code>ratio</code>: Gear ratio</li><li><code>n_a</code>: Axis of rotation of <code>frame_a</code></li><li><code>n_b</code>: Axis of rotation of <code>frame_b</code></li><li><code>r_a</code>: Vector from frame <code>bearing</code> to <code>frame_a</code> resolved in bearing</li><li><code>r_b</code>: Vector from frame <code>bearing</code> to <code>frame_b</code> resolved in bearing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L356-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.JointRRR-Tuple{}" href="#Multibody.JointRRR-Tuple{}"><code>Multibody.JointRRR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JointRRR(;
    name,
    n_a = [0,0,1],
    n_b = [0,0,1],
    rRod1_ia = [1,0,0],
    rRod2_ib = [-1,0,0],
    phi_offset = 0, 
    phi_guess = 0,

)</code></pre><p>This component consists of 3 revolute joints with parallel axes of rotation that are connected together by two rods.</p><p>This joint aggregation introduces neither constraints nor state variables and should therefore be used in kinematic loops whenever possible to avoid non-linear systems of equations. It is only meaningful to use this component in planar loops. Basically, the position and orientation of the 3 revolute joints as well as of <code>frame_ia</code>, <code>frame_ib</code>, and <code>frame_im</code> are calculated by solving analytically a non-linear equation, given the position and orientation at <code>frame_a</code> and at <code>frame_b</code>.</p><p>Connector <code>frame_a</code> is the &quot;left&quot; side of the first revolute joint whereas <code>frame_ia</code> is the &quot;right side of this revolute joint, fixed in rod 1. Connector <code>frame_b</code> is the &quot;right&quot; side of the third revolute joint whereas <code>frame_ib</code> is the &quot;left&quot; side of this revolute joint, fixed in rod 2. Finally, connector <code>frame_im</code> is the connector at the &quot;right&quot; side of the revolute joint in the middle, fixed in rod 2.</p><p>The easiest way to define the parameters of this joint is by moving the MultiBody system in a reference configuration where all frames of all components are parallel to each other (alternatively, at least <code>frame_a</code>, <code>frame_ia</code>, <code>frame_im</code>, <code>frame_ib</code>, <code>frame_b</code> of the JointRRR joint should be parallel to each other when defining an instance of this component).</p><p>Basically, the JointRRR model internally consists of a universal-spherical-revolute joint aggregation (= JointUSR). In a planar loop this will behave as if 3 revolute joints with parallel axes are connected by rigid rods.</p><p><strong>Arguments</strong></p><ul><li><code>n_a</code> Axis of revolute joints resolved in <code>frame_a</code> (all axes are parallel to each other)</li><li><code>n_b</code> Axis of revolute joint fixed and resolved in <code>frame_b</code></li><li><code>rRod1_ia</code> Vector from origin of <code>frame_a</code> to revolute joint in the middle, resolved in <code>frame_ia</code></li><li><code>rRod2_ib</code> Vector from origin of <code>frame_ib</code> to revolute joint in the middle, resolved in <code>frame_ib</code></li><li><code>phi_offset</code> Relative angle offset of revolute joint at <code>frame_b</code> <code>(angle = phi(t) + phi_offset)</code></li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code>: Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_ia</code>: Coordinate system at origin of <code>frame_a</code> fixed at connecting rod of left and middle revolute joint</li><li><code>frame_ib</code>: Coordinate system at origin of <code>frame_ib</code> fixed at connecting rod of middle and right revolute joint</li><li><code>frame_im</code>: Coordinate system at origin of revolute joint in the middle fixed at connecting rod of middle and right revolute joint</li><li><code>axis</code>: 1-dim. rotational flange that drives the right revolute joint at <code>frame_b</code></li><li><code>bearing</code>: 1-dim. rotational flange of the drive bearing of the right revolute joint at <code>frame_b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L684-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.JointUSR-Tuple{}" href="#Multibody.JointUSR-Tuple{}"><code>Multibody.JointUSR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JointUSR(;
    name,
    n1_a = [0, 0, 1],
    n_b = [0, 0, 1],
    rRod1_ia = [1, 0, 0],
    rRod1_ib = [-1, 0, 0],
    phi_offset = 0,
    phi_guess = 0,
)</code></pre><p>This component consists of a universal joint at <code>frame_a</code>, a revolute joint at <code>frame_b</code> and a spherical joint which is connected via rod1 to the universal and via rod2 to the revolute joint.</p><p>This joint aggregation has no mass and no inertia and introduces neither constraints nor potential state variables. It should be used in kinematic loops whenever possible since the non-linear system of equations introduced by this joint aggregation is solved analytically (i.e., a solution is always computed, if a unique solution exists).</p><p>The universal joint is defined in the following way:</p><ul><li>The rotation axis of revolute joint 1 is along parameter vector <code>n1_a</code> which is fixed in <code>frame_a</code>.</li><li>The rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint (= rod 1).</li></ul><p>The definition of axis 2 of the universal joint is performed according to the most often occurring case for the sake of simplicity. Otherwise, the treatment is much more complicated and the number of operations is considerably higher, if axis 2 is not orthogonal to axis 1 and to the connecting rod.</p><p>Note, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible <code>n1_a</code> should be selected in such a way that it is perpendicular to rRod1_ia in the initial configuration (i.e., the distance to the singularity is as large as possible).</p><p>The rest of this joint aggregation is defined by the following parameters:</p><ul><li><code>positive_branch</code>: The positive branch of the revolute joint is selected (cf. elbow up vs. elbow down).</li><li>The position of the spherical joint with respect to the universal joint is defined by vector <code>rRod1_ia</code>. This vector is directed from <code>frame_a</code> to the spherical joint and is resolved in <code>frame_ia</code> (it is most simple to select <code>frame_ia</code> such that it is parallel to <code>frame_a</code> in the reference or initial configuration).</li><li>The position of the spherical joint with respect to the revolute joint is defined by vector <code>rRod2_ib</code>. This vector is directed from the inner frame of the revolute joint (<code>frame_ib</code> or <code>revolute.frame_a</code>) to the spherical joint and is resolved in <code>frame_ib</code> (note, that <code>frame_ib</code> and <code>frame_b</code> are parallel to each other).</li><li>The axis of rotation of the revolute joint is defined by axis vector <code>n_b</code>. It is fixed and resolved in <code>frame_b</code>.</li><li>When specifying this joint aggregation with the definitions above, two different configurations are possible. Via parameter <code>phi_guess</code> a guess value for <code>revolute.phi(t0)</code> at the initial time <code>t0</code> is given. The configuration is selected that is closest to <code>phi_guess</code> (<code>|revolute.phi - phi_guess|</code> is minimal).</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the universal joint</li><li><code>frame_b</code>: Frame for the revolute joint</li><li>An additional <code>frame_ia</code> is present. It is fixed in the rod connecting the universal and the spherical joint at the origin of <code>frame_a</code>. The placement of <code>frame_ia</code> on the rod is implicitly defined by the universal joint (<code>frame_a</code> and <code>frame_ia</code> coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector rRod1<em>ia, the position vector from the origin of `frame</em>a<code>to the spherical joint, resolved in</code>frame_ia`.</li><li>An additional <code>frame_ib</code> is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the revolute joint that is connected to this rod (<code>= rod2.frame_a = revolute.frame_a</code>).</li><li>An additional <code>frame_im</code> is present. It is fixed in the rod connecting the revolute and the spherical joint at the side of the spherical joint that is connected to this rod (<code>= rod2.frame_b</code>). It is always parallel to <code>frame_ib</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L526-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Prismatic-Tuple{}" href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prismatic(; name, n = [0, 0, 1], axisflange = false)</code></pre><p>Prismatic joint with 1 translational degree-of-freedom</p><ul><li><code>n</code>: The axis of motion (unit vector)</li><li><code>axisflange</code>: If true, the joint will have two additional frames from Mechanical.Translational, <code>axis</code> and <code>support</code>, between which translational components such as springs and dampers can be connected.</li></ul><p>If <code>axisflange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.TranslationalModelica are also available:</p><ul><li><code>axis</code>: 1-dim. translational flange that drives the joint</li><li><code>support</code>: 1-dim. translational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul><p>The function returns an ODESystem representing the prismatic joint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PrismaticConstraint-Tuple{}" href="#Multibody.PrismaticConstraint-Tuple{}"><code>Multibody.PrismaticConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrismaticConstraint(; name, color, radius = 0.05, x_locked = true, y_locked = true, z_locked = true, render = true)</code></pre><p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of <code>frame_b</code> with respect to <code>frame_a</code>, but defines kinematic constraints between the <code>frame_a</code> and <code>frame_b</code>. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is called an implicit joint in literature.</p><p>As a consequence of the formulation, the relative kinematics between <code>frame_a</code> and <code>frame_b</code> cannot be initialized.</p><p>In complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Compare the simplification result using the classical joint formulation and this alternative formulation to check which one is more efficient for the particular system under consideration.</p><p>In systems without closed loops the use of this implicit joint does not make sense or may even be disadvantageous.</p><p><strong>Parameters</strong></p><ul><li><code>color</code>: Color of the joint in animations (RGBA)</li><li><code>radius</code>: Radius of the joint in animations</li><li><code>x_locked</code>: Set to false if the translational motion in x-direction shall be free</li><li><code>y_locked</code>: Set to false if the translational motion in y-direction shall be free</li><li><code>z_locked</code>: Set to false if the translational motion in z-direction shall be free</li><li><code>render</code>: Whether or not the joint is rendered in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L202-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Revolute-Tuple{}" href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Revolute(; name, phi0 = 0, w0 = 0, n, axisflange = false)</code></pre><p>Revolute joint with 1 rotational degree-of-freedom</p><ul><li><code>phi0</code>: Initial angle</li><li><code>w0</code>: Iniitial angular velocity</li><li><code>n</code>: The axis of rotation</li><li><code>axisflange</code>: If true, the joint will have two additional frames from Mechanical.Rotational, <code>axis</code> and <code>support</code>, between which rotational components such as springs and dampers can be connected.</li></ul><p>If <code>axisflange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.Rotational are also available:</p><ul><li><code>axis</code>: 1-dim. rotational flange that drives the joint</li><li><code>support</code>: 1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius = 0.05</code>: Radius of the joint in animations</li><li><code>length = radius</code>: Length of the joint in animations</li><li><code>color</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RevolutePlanarLoopConstraint-Tuple{}" href="#Multibody.RevolutePlanarLoopConstraint-Tuple{}"><code>Multibody.RevolutePlanarLoopConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RevolutePlanarLoopConstraint(; name, n)</code></pre><p>Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)</p><p>Joint where <code>frame_b</code> rotates around axis <code>n</code> which is fixed in <code>frame_a</code> and where this joint is used in a planar loop providing 2 constraint equations on position level.</p><p>If a planar loop is present, e.g., consisting of 4 revolute joints where the joint axes are all parallel to each other, then there is no unique mathematical solution if all revolute joints are modelled with <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> and the symbolic algorithms will fail. The reason is that, e.g., the cut-forces in the revolute joints perpendicular to the planar loop are not uniquely defined when 3-dim. descriptions of revolute joints are used. In this case, one revolute joint in the loop has to be replaced by model <code>RevolutePlanarLoopConstraint</code>. The effect is that from the 5 constraints of a 3-dim. revolute joint, 3 constraints are removed and replaced by appropriate known variables (e.g., the force in the direction of the axis of rotation is treated as known with value equal to zero; for standard revolute joints, this force is an unknown quantity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L575-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Spherical-Tuple{}" href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spherical(; name, state = false, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, sequence, phi = 0, phid = 0, phidd = 0, d = 0)</code></pre><p>Joint with 3 constraints that define that the origin of <code>frame_a</code> and the origin of <code>frame_b</code> coincide. By default this joint defines only the 3 constraints without any potential state variables. If parameter <code>state</code> is set to true, three states are introduced. The orientation of <code>frame_b</code> is computed by rotating <code>frame_a</code> along the axes defined in parameter vector <code>sequence</code> (default = [1,2,3], i.e., the Cardan angle sequence) around the angles used as state. If angles are used as state there is the slight disadvantage that a singular configuration is present leading to a division by zero.</p><ul><li><code>isroot</code>: Indicate that <code>frame_a</code> is the root, otherwise <code>frame_b</code> is the root. Only relevant if <code>state = true</code>.</li><li><code>sequence</code>: Rotation sequence</li><li><code>d</code>: Viscous damping constant. If <code>d &gt; 0</code>. the joint dissipates energy due to viscous damping according to <span>$τ ~ -d*ω$</span>.</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius = 0.1</code>: Radius of the joint in animations</li><li><code>color = [1,1,0,1]</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li><li><code>render = true</code>: Render the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L166-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SphericalConstraint-Tuple{}" href="#Multibody.SphericalConstraint-Tuple{}"><code>Multibody.SphericalConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalConstraint(; name, color = [1, 1, 0, 1], radius = 0.1, x_locked = true, y_locked = true, z_locked = true)</code></pre><p>Spherical cut joint and translational directions may be constrained or released</p><p>This model does not use explicit variables e.g. state variables in order to describe the relative motion of <code>frame_b</code> with to respect to <code>frame_a</code>, but defines kinematic constraints between the <code>frame_a</code> and <code>frame_b</code>. The forces and torques at both frames are then evaluated in such a way that the constraints are satisfied. Sometimes this type of formulation is also called an implicit joint in literature.</p><p>As a consequence of the formulation the relative kinematics between <code>frame_a</code> and <code>frame_b</code> cannot be initialized.</p><p>In complex multibody systems with closed loops this may help to simplify the system of non-linear equations. Please compare state realization chosen by <code>structural_simplify</code> using the classical joint formulation and the alternative formulation used here in order to check whether this fact applies to the particular system under consideration. In systems without closed loops the use of this implicit joint is not recommended.</p><p><strong>Arguments</strong></p><ul><li><code>x_locked</code>: Set to false if the translational motion in x-direction shall be free</li><li><code>y_locked</code>: Set to false if the translational motion in y-direction shall be free</li><li><code>z_locked</code>: Set to false if the translational motion in z-direction shall be free</li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>color</code>: Color of the joint in animations (RGBA)</li><li><code>radius</code>: Radius of the joint in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L131-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SphericalSpherical-Tuple{}" href="#Multibody.SphericalSpherical-Tuple{}"><code>Multibody.SphericalSpherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalSpherical(; name, state = false, isroot = true, iscut=false, w_rel_a_fixed = false, r_0 = [0,0,0], color = [1, 1, 0, 1], m = 0, radius = 0.1, kinematic_constraint=true)</code></pre><p>Joint that has a spherical joint on each of its two ends. The rod connecting the two spherical joints is approximated by a point mass that is located in the middle of the rod. When the mass is set to zero (default), special code for a massless body is generated. </p><p>This joint introduces one constraint defining that the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> is constant (= rodLength). It is highly recommended to use this joint in loops whenever possible, because this enhances the efficiency considerably due to smaller systems of non-linear algebraic equations.</p><p>It is not possible to connect other components, such as a body with mass properties or a special visual shape object to the rod connecting the two spherical joints. If this is needed, use instead joint <a href="#Multibody.UniversalSpherical-Tuple{}"><code>UniversalSpherical</code></a> that has the additional frame <code>frame_ia</code> for this.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: Frame for the first spherical joint</li><li><code>frame_b</code>: Frame for the second spherical joint</li></ul><p><strong>Rendering parameters:</strong></p><ul><li><code>radius</code>: Radius of the joint in animations</li><li><code>color</code>: Color of the joint in animations (RGBA)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Universal-Tuple{}" href="#Multibody.Universal-Tuple{}"><code>Multibody.Universal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Universal(; name, n_a, n_b, phi_a = 0, phi_b = 0, w_a = 0, w_b = 0, a_a = 0, a_b = 0, state_priority=10)</code></pre><p>Joint where <code>frame_a</code> rotates around axis <code>n_a</code> which is fixed in <code>frame_a</code> and <code>frame_b</code> rotates around axis <code>n_b</code> which is fixed in <code>frame_b</code>. The two frames coincide when <code>revolute_a.phi=0</code> and <code>revolute_b.phi=0</code>. This joint has the following potential states;</p><ul><li>The relative angle <code>phi_a = revolute_a.phi</code> [rad] around axis <code>n_a</code></li><li>the relative angle <code>phi_b = revolute_b.phi</code> [rad] around axis <code>n_b</code></li><li>the relative angular velocity <code>w_a = D(phi_a)</code></li><li>the relative angular velocity <code>w_b = D(phi_b)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/joints.jl#L275-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.UniversalSpherical-Tuple{}" href="#Multibody.UniversalSpherical-Tuple{}"><code>Multibody.UniversalSpherical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniversalSpherical(; name, n1_a, rRod_ia, sphere_diameter = 0.1, sphere_color, rod_width = 0.1, rod_height = 0.1, rod_color, cylinder_length = 0.1, cylinder_diameter = 0.1, cylinder_color, kinematic_constraint = true)</code></pre><p>Universal - spherical joint aggregation (1 constraint, no potential states)</p><p>This component consists of a universal joint at <code>frame_a</code> and a spherical joint at <code>frame_b</code> that are connected together with a rigid rod.</p><p>This joint aggregation has no mass and no inertia and introduces the constraint that the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> is constant (= <code>length(rRod_ia)</code>). The universal joint is defined in the following way:</p><ul><li>The rotation axis of revolute joint 1 is along parameter vector <code>n1_a</code> which is fixed in <code>frame_a</code>.</li><li>The rotation axis of revolute joint 2 is perpendicular to axis 1 and to the line connecting the universal and the spherical joint.</li></ul><p>Note, there is a singularity when axis 1 and the connecting rod are parallel to each other. Therefore, if possible <code>n1_a</code> should be selected in such a way that it is perpendicular to <code>rRod_ia</code> in the initial configuration (i.e., the distance to the singularity is as large as possible).</p><p>An additional <code>frame_ia</code> is present. It is fixed in the connecting rod at the origin of <code>frame_a</code>. The placement of <code>frame_ia</code> on the rod is implicitly defined by the universal joint (<code>frame_a</code> and <code>frame_ia</code> coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector <code>rRod_ia</code>, the position vector from the origin of <code>frame_a</code> to the origin of <code>frame_b</code>, resolved in <code>frame_ia</code>.</p><p>This joint aggregation can be used in cases where in reality a rod with spherical joints at end are present. Such a system has an additional degree of freedom to rotate the rod along its axis. In practice this rotation is usually of no interest and is mathematically removed by replacing one of the spherical joints by a universal joint. Still, in most cases the <a href="#Multibody.SphericalSpherical-Tuple{}"><code>SphericalSpherical</code></a> joint aggregation can be used instead of the UniversalSpherical joint since the rod is animated and its mass properties are approximated by a point mass in the middle of the rod. The <a href="#Multibody.SphericalSpherical-Tuple{}"><code>SphericalSpherical</code></a> joint has the advantage that it does not have a singular configuration.</p><p><strong>Arguments</strong></p><ul><li><code>n1_a</code> Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)</li><li><code>rRod_ia</code> Vector from origin of frame<em>a to origin of frame</em>b, resolved in <code>frame_ia</code> (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)</li><li><code>kinematic_constraint = true</code> Set to false if no constraint shall be defined, due to analytically solving a kinematic loop</li><li><code>constraint_residue</code> If set to <code>:external</code>, an equation in the parent system is expected to define this variable, e.g., <code>rod.constraint_residue ~ rod.f_rod - f_rod</code> where <code>rod</code> is the name of the UniversalSpherical joint. If unspecified, the length constraint <code>rRod_0&#39;rRod_0 - rodLength&#39;rodLength</code> is used</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the universal joint</li><li><code>frame_b</code>: Frame for the spherical joint</li><li><code>frame_ia</code>: Frame fixed in the rod at the origin of <code>frame_a</code></li></ul><p><strong>Rendering parameters</strong></p><ul><li><code>sphere_diameter</code>: Diameter of spheres representing the universal and the spherical joint</li><li><code>sphere_color</code>: Color of spheres representing the universal and the spherical joint (RGBA)</li><li><code>rod_width</code>: Width of rod shape in direction of axis 2 of universal joint</li><li><code>rod_height</code>: Height of rod shape in direction that is orthogonal to rod and to axis 2</li><li><code>rod_color</code>: Color of rod shape connecting the universal and the spherical joints (RGBA)</li><li><code>cylinder_length</code>: Length of cylinders representing the two universal joint axes</li><li><code>cylinder_diameter</code>: Diameter of cylinders representing the two universal joint axes</li><li><code>cylinder_color</code>: Color of cylinders representing the two universal joint axes (RGBA)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/fancy_joints.jl#L266-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Prismatic-Tuple{}" href="#Multibody.PlanarMechanics.Prismatic-Tuple{}"><code>Multibody.PlanarMechanics.Prismatic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prismatic(; name, f, s = 0, axisflange = false)</code></pre><p>A prismatic joint</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: [m, m] x,y-direction of the rod wrt. body system at phi=0</li><li><code>axisflange=false</code>: If <code>true</code>, a force flange is enabled, otherwise implicitly grounded&quot;</li><li><code>render</code>: Render the joint in animations</li><li><code>radius</code>: Radius of the body in animations</li><li><code>color</code>: Color of the body in animations</li></ul><p><strong>Variables</strong></p><ul><li><code>s(t)</code>: [m] Elongation of the joint</li><li><code>v(t)</code>: [m/s] Velocity of elongation</li><li><code>a(t)</code>: [m/s²] Acceleration of elongation</li><li><code>f(t)</code>: [N] Force in direction of elongation</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>fixed</code> <a href="#Multibody.PlanarMechanics.Fixed">Fixed</a> if <code>axisflange == false</code></li><li><code>flange_a</code> <a href="@ref">Flange</a> if <code>axisflange == true</code></li><li><code>support</code> <a href="@ref">Support</a> if <code>axisflange == true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/joints.jl#L84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Revolute-Tuple{}" href="#Multibody.PlanarMechanics.Revolute-Tuple{}"><code>Multibody.PlanarMechanics.Revolute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Revolute(; name, phi = 0.0, tau = 0.0, axisflange = false)</code></pre><p>A revolute joint</p><p><strong>Parameters:</strong></p><ul><li><code>axisflange=false</code>: If <code>true</code>, a force flange is enabled, otherwise implicitly grounded&quot;</li><li><code>phi</code>: [rad] Initial angular position for the flange</li><li><code>tau</code>: [Nm] Initial Cut torque in the flange</li></ul><p><strong>Variables:</strong></p><ul><li><code>phi(t)</code>: [rad] angular position</li><li><code>w(t)</code>: [rad/s] angular velocity</li><li><code>α(t)</code>: [rad/s²] angular acceleration</li><li><code>tau(t)</code>: [Nm] torque</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a></li><li><code>fixed</code> <a href="#Multibody.PlanarMechanics.Fixed">Fixed</a> if <code>axisflange == false</code></li><li><code>flange_a</code> <a href="@ref">Flange</a> if <code>axisflange == true</code></li><li><code>support</code> <a href="@ref">Support</a> if <code>axisflange == true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/joints.jl#L1-L22">source</a></section></article><h2 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h2><p>The perhaps most fundamental component is a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, this component has a single flange, <code>frame_a</code>, which is used to connect the body to other components. This component has a mass, a vector <code>r_cm</code> from <code>frame_a</code> to the center of mass, and a moment of inertia tensor <code>I</code> in the center of mass. The body can be thought of as a point mass with a moment of inertia tensor.</p><p>A mass with a shape can be modeled using a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>. The primary difference between a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a> and a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is that the latter has an additional flange, <code>frame_b</code>, which is used to connect the body to other components. The translation between <code>flange_a</code> and <code>flange_b</code> is determined by the vector <code>r</code>. The <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is suitable to model, e.g., cylinders, rods, and boxes.</p><p>A rod without a mass (just a translation), is modeled using <a href="#Multibody.FixedTranslation-Tuple{}"><code>FixedTranslation</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyBox" href="#Multibody.BodyBox"><code>Multibody.BodyBox</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyBox(; name, m = 1, r = [1, 0, 0], r_shape = [0, 0, 0], width_dir = [0,1,0])</code></pre><p>Rigid body with box shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the box data. Optionally, the box may be hollow. The (outer) box shape is used in the animation, the hollow part is not shown in the animation. The two connector frames <code>frame_a</code> and <code>frame_b</code> are always parallel to each other.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (structural parameter) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_shape</code>: (structural parameter) Vector from <code>frame_a</code> to box origin, resolved in <code>frame_a</code></li><li><code>width_dir</code>: (structural parameter) Vector in width direction of box, resolved in <code>frame_a</code></li><li><code>length_dir</code>: (structural parameter) Vector in length direction of box, resolved in <code>frame_a</code></li><li><code>length</code>: (structural parameter) Length of box</li><li><code>width = 0.3length</code>: Width of box</li><li><code>height = width</code>: Height of box</li><li><code>inner_width</code>: Width of inner box surface (0 &lt;= inner_width &lt;= width)</li><li><code>inner_height</code>: Height of inner box surface (0 &lt;= inner_height &lt;= height)</li><li><code>density = 7700</code>: Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)</li><li><code>color</code>: Color of box in animations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L730-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyCylinder" href="#Multibody.BodyCylinder"><code>Multibody.BodyCylinder</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyCylinder(; name, m = 1, r = [0.1, 0, 0], r_shape = [0, 0, 0], dir = r - r_shape, length = _norm(r - r_shape), diameter = 1, inner_diameter = 0, density = 7700, color = purple)</code></pre><p>Rigid body with cylinder shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the cylinder data. Optionally, the cylinder may be hollow. The two connector frames <code>frame_a</code> and <code>frame_b</code> are always parallel to each other.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (Structural parameter) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_shape</code>: (Structural parameter) Vector from <code>frame_a</code> to cylinder origin, resolved in <code>frame_a</code></li><li><code>dir</code>: Vector in length direction of cylinder, resolved in <code>frame_a</code></li><li><code>length</code>: Length of cylinder</li><li><code>diameter</code>: Diameter of cylinder</li><li><code>inner_diameter</code>: Inner diameter of cylinder (0 &lt;= inner_diameter &lt;= diameter)</li><li><code>density</code>: Density of cylinder <a href="e.g., steel: 7700 .. 7900, wood : 400 .. 800">kg/m³</a></li><li><code>color</code>: Color of cylinder in animations</li></ul><p><strong>Variables</strong></p><ul><li><code>r_0</code>: Position vector from origin of world frame to origin of <code>frame_a</code></li><li><code>v_0</code>: Absolute velocity of <code>frame_a</code>, resolved in world frame (= D(r_0))</li><li><code>a_0</code>: Absolute acceleration of <code>frame_a</code> resolved in world frame (= D(v_0))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L619-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.world" href="#Multibody.world"><code>Multibody.world</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The world component is the root of all multibody models. It is a fixed frame with a parallel gravitational field and a gravity vector specified by the unit direction <code>world.n</code> (defaults to [0, -1, 0]) and magnitude <code>world.g</code> (defaults to 9.80665).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L64-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AccSensor-Tuple{}" href="#Multibody.AccSensor-Tuple{}"><code>Multibody.AccSensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AccSensor(;name)</code></pre><p>Ideal sensor to measure the absolute flange angular acceleration</p><p><strong>Connectors:</strong></p><ul><li><code>flange</code>: <a href="@ref">Flange</a> Flange of shaft from which sensor information shall be measured</li><li><code>a</code>: <a href="@ref">RealOutput</a> Absolute angular acceleration of flange</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/robot_components.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AxisControlBus-Tuple{}" href="#Multibody.AxisControlBus-Tuple{}"><code>Multibody.AxisControlBus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@connector AxisControlBus(; name)</code></pre><ul><li><code>motion_ref(t) = 0</code>: = true, if reference motion is not in rest</li><li><code>angle_ref(t) = 0</code>: Reference angle of axis flange</li><li><code>angle(t) = 0</code>: Angle of axis flange</li><li><code>speed_ref(t) = 0</code>: Reference speed of axis flange</li><li><code>speed(t) = 0</code>: Speed of axis flange</li><li><code>acceleration_ref(t) = 0</code>: Reference acceleration of axis flange</li><li><code>acceleration(t) = 0</code>: Acceleration of axis flange</li><li><code>current_ref(t) = 0</code>: Reference current of motor</li><li><code>current(t) = 0</code>: Current of motor</li><li><code>motorAngle(t) = 0</code>: Angle of motor flange</li><li><code>motorSpeed(t) = 0</code>: Speed of motor flange</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/robot_components.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.AxisType2-Tuple{}" href="#Multibody.AxisType2-Tuple{}"><code>Multibody.AxisType2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AxisType2(; name)</code></pre><p>Axis model of the r3 joints 4,5,6</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/robot_components.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Body-Tuple{}" href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Body(; name, m = 1, r_cm, isroot = false, phi0 = zeros(3), phid0 = zeros(3), r_0 = zeros(3), state_priority = 2, quat = false, sparse_I = false)</code></pre><p>Representing a body with 3 translational and 3 rotational degrees-of-freedom.</p><p>This component has a single frame, <code>frame_a</code>. To represent bodies with more than one frame, see <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>, <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a>, <a href="#Multibody.BodyBox"><code>BodyBox</code></a>.</p><p><strong>Performance optimization</strong></p><ul><li><code>sparse_I</code>: If <code>true</code>, the zero elements of the inerita matrix are considered &quot;structurally zero&quot;, and this fact is used to optimize performance. When this option is enabled, the elements of the inertia matrix that were zero when the component was created cannot changed without reinstantiating the component. This performance optimization may be useful, e.g., when the inertia matrix is known to be diagonal.</li></ul><p><strong>Parameters</strong></p><ul><li><code>m</code>: Mass</li><li><code>r_cm</code>: Vector from <code>frame_a</code> to center of mass, resolved in <code>frame_a</code></li><li><code>I_11, I_22, I_33, I_21, I_31, I_32</code>: Inertia-matrix elements</li><li><code>isroot</code>: Indicate whether this component is the root of the system, useful when there are no joints in the model.</li><li><code>phi0</code>: Initial orientation, only applicable if <code>isroot = true</code> and <code>quat = false</code></li><li><code>phid0</code>: Initial angular velocity</li></ul><p><strong>Variables</strong></p><ul><li><code>r_0</code>: Position vector from origin of world frame to origin of <code>frame_a</code></li><li><code>v_0</code>: Absolute velocity of <code>frame_a</code>, resolved in world frame (= D(r_0))</li><li><code>a_0</code>: Absolute acceleration of <code>frame_a</code> resolved in world frame (= D(v_0))</li></ul><p><strong>Rendering options</strong></p><ul><li><code>radius</code>: Radius of the joint in animations</li><li><code>cylinder_radius</code>: Radius of the cylinder from frame to COM in animations (only drawn if <code>r_cm</code> is non-zero). Defaults to <code>radius/2</code></li><li><code>color</code>: Color of the joint in animations, a vector of length 4 with values between [0, 1] providing RGBA values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L212-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyShape-Tuple{}" href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyShape(; name, m = 1, r, kwargs...)</code></pre><p>The <code>BodyShape</code> component is similar to a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, but it has two frames and a vector <code>r</code> that describes the translation between them, while the body has a single frame only.</p><ul><li><code>r</code>: Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li>All <code>kwargs</code> are passed to the internal <code>Body</code> component.</li><li><code>shapefile</code>: A path::String to a CAD model that can be imported by MeshIO for 3D rendering. If none is provided, a cylinder shape is rendered.</li></ul><p>See also <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a> and <a href="#Multibody.BodyBox"><code>BodyBox</code></a> for body components with predefined shapes and automatically computed inertial properties based on geometry and density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L385-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedRotation-Tuple{}" href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedRotation(; name, r, n, sequence, isroot = false, angle)</code></pre><p>Fixed translation followed by a fixed rotation of <code>frame_b</code> with respect to <code>frame_a</code></p><ul><li><code>r</code>: Translation vector</li><li><code>n</code>: Axis of rotation, resolved in frame_a</li><li><code>angle</code>: Angle of rotation around <code>n</code>, given in radians</li></ul><p>To obtain an axis-angle representation of any rotation, see <a href="rotations/#Conversion-between-orientation-formats">Conversion between orientation formats</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L149-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedTranslation-Tuple{}" href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedTranslation(; name, r)</code></pre><p>Fixed translation of <code>frame_b</code> with respect to <code>frame_a</code> with position vector <code>r</code> resolved in <code>frame_a</code>.</p><p>Can be thought of as a massless rod. For a massive rod, see <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> or <a href="#Multibody.BodyCylinder"><code>BodyCylinder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Rope-Tuple{}" href="#Multibody.Rope-Tuple{}"><code>Multibody.Rope</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rope(; name, l = 1, n = 10, m = 1, c = 0, d = 0, kwargs)</code></pre><p>Model a rope (string / cable) of length <code>l</code> and mass <code>m</code>.</p><p>The rope is modeled as a series of <code>n</code> links, each connected by a <a href="#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> joint. The links are either fixed in length (default, modeled using <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>) or flexible, in which case they are modeled as a <a href="@ref"><code>Translational.Spring</code></a> and <a href="@ref"><code>Translational.Damper</code></a> in parallel with a <a href="#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint with a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a> adding mass to the center of the link segment. The flexibility is controlled by the parameters <code>c</code> and <code>d</code>, which are the stiffness and damping coefficients of the spring and damper, respectively. The default values are <code>c = 0</code> and <code>d = 0</code>, which corresponds to a stiff rope.</p><ul><li><code>l</code>: Unstretched length of rope</li><li><code>n</code>: Number of links used to model the rope. For accurate approximations to continuously flexible ropes, a large number may be required.</li><li><code>m</code>: The total mass of the rope. Each rope segment will have mass <code>m / n</code>.</li><li><code>c</code>: The equivalent stiffness of the rope, i.e., the rope will act like a spring with stiffness <code>c</code>. </li><li><code>d</code>: The equivalent damping in the stretching direction of the rope, i.e., the taught rope will act like a damper with damping <code>d</code>.</li><li><code>d_joint</code>: Viscous damping in the joints between the links. A positive value makes the rope dissipate energy while flexing (as opposed to the damping <code>d</code> which dissipats energy due to stretching).</li><li><code>dir</code>: A vector of norm 1 indicating the initial direction of the rope.</li></ul><p><strong>Damping</strong></p><p>There are three different methods of adding damping to the rope:</p><ul><li>Damping in the stretching direction of the rope, controlled by the parameter <code>d</code>.</li><li>Damping in flexing of the rope, modeled as viscous friction in the joints between the links, controlled by the parameter <code>d_joint</code>.</li><li>Air resistance to the rope moving through the air, controlled by the parameter <code>air_resistance</code>. This damping is quadratic in the velocity (<span>$f_d ~ -||v||v$</span>) of each link relative to the world frame.</li></ul><p><strong>Rendering</strong></p><ul><li><code>color = [255, 219, 120, 255]./255</code></li><li><code>radius = 0.05f0</code></li><li><code>jointradius=0</code></li><li><code>jointcolor=color</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L447-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.World-Tuple{}" href="#Multibody.World-Tuple{}"><code>Multibody.World</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">World(; name, render=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.gravity_acceleration-Tuple{Any}" href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute the gravity acceleration, resolved in world frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.ori" href="#Multibody.ori"><code>Multibody.ori</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ori(frame, varw = false)</code></pre><p>Get the orientation of <code>sys</code> as a <code>RotationMatrix</code> object.</p><p>For frames, the orientation is stored in the metadata field of the system as <code>sys.metadata[:orientation]</code>.</p><p>If <code>varw = true</code>, the angular velocity variables <code>w</code> of the frame is also included in the <code>RotationMatrix</code> object, otherwise <code>w</code> is derived as the time derivative of <code>R</code>. <code>varw = true</code> is primarily used when selecting a component as root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/components.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingConstraintVerticalWheel-Tuple{}" href="#Multibody.RollingConstraintVerticalWheel-Tuple{}"><code>Multibody.RollingConstraintVerticalWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingConstraintVerticalWheel(;
    name,
    radius = 0.3,
    lateral_sliding_constraint = true,
)</code></pre><p>Rolling constraint for wheel that is always perpendicular to x-z plane</p><p>Joint for a wheel rolling on the x-z plane of the world frame intended for an idealized wheelset. To meet this objective, the wheel always runs upright and enables no slip in the longitudinal direction of the wheel/ground contact. On the contrary, the wheel can optionally slip in the lateral direction which is reasonable for the wheelset where just one of the wheels should be laterally constrained. The frame <code>frame_a</code> is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. A wheel body collecting the mass and inertia</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>name</code>: Name of the rolling wheel joint component</li><li><code>radius</code>: Wheel radius</li><li><code>lateral_sliding_constraint</code>: true, if lateral sliding constraint taken into account, = false if lateral force = 0 (needed to avoid overconstraining if two ideal rolling wheels are connect on one axis)</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: Frame for the wheel joint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L511-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheel-Tuple{}" href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheel(; name, radius, m, I_axis, I_long, width=0.035, x0, y0, kwargs...)</code></pre><p>Ideal rolling wheel on flat surface y=0 (5 positional, 3 velocity degrees of freedom)</p><p>A wheel rolling on the x-z plane of the world frame including wheel mass. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. The wheel can not take off but it can incline toward the ground. The frame <code>frame_a</code> is placed in the wheel center point and rotates with the wheel itself. A <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint rotationg around <code>n = [0, 1, 0]</code> is required to attach the wheel to a wheel axis.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>name</code>: Name of the rolling wheel component</li><li><code>radius</code>: Radius of the wheel</li><li><code>m</code>: Mass of the wheel</li><li><code>I_axis</code>: Moment of inertia of the wheel along its axis</li><li><code>I_long</code>: Moment of inertia of the wheel perpendicular to its axis</li><li><code>width</code>: Width of the wheel (default: 0.035)</li><li><code>x0</code>: Initial x-position of the wheel axis</li><li><code>z0</code>: Initial z-position of the wheel axis</li><li><code>kwargs...</code>: Additional keyword arguments passed to the <code>RollingWheelJoint</code> function</li></ul><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles  (y: like rotational velocity of a spinning coin, z: wheel forward spin speed, x: wheel falling over speed)</li></ul><p><strong>Named components:</strong></p><ul><li><code>frame_a</code>: Frame for the wheel component</li><li><code>wheeljoint</code>: Rolling wheel joint representing the wheel&#39;s contact with the road surface</li></ul><div class="admonition is-success"><header class="admonition-header">Rendering tip</header><div class="admonition-body"><p>Due to the symmetry of the wheel, it can be hard to discern how the wheel is rotating in animations. Try enabling rendering of the frame of the wheel by setting </p><pre><code class="nohighlight hljs">wheel.frame_a.render =&gt; true;
wheel.frame_a.length =&gt; 1.1radius;
wheel.frame_a.radius =&gt; 0.02radius;</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L182-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelJoint-Tuple{}" href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelJoint(; name, radius, angles, x0, y0, z0)</code></pre><p>Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane y=0). See <a href="#Multibody.RollingWheel-Tuple{}"><code>RollingWheel</code></a> for a realistic wheel model with inertia.</p><p>A joint for a wheel rolling on the x-z plane of the world frame. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. This is simply gained by two non-holonomic constraint equations on velocity level defined for both longitudinal and lateral direction of the wheel. There is also a holonomic constraint equation on position level granting a permanent contact of the wheel to the ground, i.e. the wheel can not take off.</p><p>The origin of the frame <code>frame_a</code> is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. The z-axis of <code>frame_a</code> is identical with the wheel spin axis, i.e. the wheel rotates about z-axis of <code>frame_a</code>. A wheel body collecting the mass and inertia should be connected to this frame.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>angles</code>: Angles to rotate world-frame into frame_a around y-, z-, x-axis</li><li><code>surface</code>: By default, the wheel is rolling on a flat xz plane. A function <code>surface = (x, z)-&gt;y</code> may be provided to define a road surface. The function should return the height of the road at <code>(x, z)</code>.</li></ul><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>y</code>: y-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li><li><code>r_road_0</code>: Position vector from world frame to contact point on road, resolved in world frame</li><li><code>f_wheel_0</code>: Force vector on wheel, resolved in world frame</li><li><code>f_n</code>: Contact force acting on wheel in normal direction</li><li><code>f_lat</code>: Contact force acting on wheel in lateral direction</li><li><code>f_long</code>: Contact force acting on wheel in longitudinal direction</li><li><code>err</code>: Absolute value of <code>(r_road_0 - frame_a.r_0) - radius</code> (must be zero; used for checking)</li><li><code>e_axis_0</code>: Unit vector along wheel axis, resolved in world frame</li><li><code>delta_0</code>: Distance vector from wheel center to contact point</li><li><code>e_n_0</code>: Unit vector in normal direction of road at contact point, resolved in world frame</li><li><code>e_lat_0</code>: Unit vector in lateral direction of road at contact point, resolved in world frame</li><li><code>e_long_0</code>: Unit vector in longitudinal direction of road at contact point, resolved in world frame</li><li><code>s</code>: Road surface parameter 1</li><li><code>w</code>: Road surface parameter 2</li><li><code>e_s_0</code>: Road heading at <code>(s,w)</code>, resolved in world frame (unit vector)</li><li><code>v_0</code>: Velocity of wheel center, resolved in world frame</li><li><code>w_0</code>: Angular velocity of wheel, resolved in world frame</li><li><code>vContact_0</code>: Velocity of contact point, resolved in world frame</li></ul><p><strong>Connector frames</strong></p><ul><li><code>frame_a</code>: Frame for the wheel joint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelSet-Tuple{}" href="#Multibody.RollingWheelSet-Tuple{}"><code>Multibody.RollingWheelSet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelSet(;
    name,
    radius = 0.3,
    m_wheel = 1.0,
    I_axis = 1.0,
    I_long = 1.0,
    track = 1.0,
    state_priority = 1,
    x0 = 0,
    z0 = 0,
    phi0 = 0,
    theta1_0 = 0,
    theta2_0 = 0,
    der_theta1_0 = 0,
    der_theta2_0 = 0,
    width_wheel = 0.01,
    color = [0.3, 0.3, 0.3, 1],
    render = true,
    iscut = false,
)</code></pre><p>Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis</p><p>Two wheels are connected by an axis and can rotate around this axis. The wheels are rolling on the x-z plane of the world frame. The coordinate system attached to the center of the wheel axis (<code>frame_middle</code>) is constrained so that it is always parallel to the x-z plane. If all generalized coordinates are zero, <code>frame_middle</code> is parallel to the world frame.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>iscut</code>: if more than one wheel set is connected to the same rigid body, <code>iscut</code> must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.</li><li><code>radius</code>: Radius of one wheel</li><li><code>m_wheel</code>: Mass of one wheel</li><li><code>I_axis</code>: Moment of inertia of one wheel around its rotation axis</li><li><code>I_long</code>: Moment of inertia of one wheel perpendicular to its rotation axis</li><li><code>track</code>: Distance between the two wheels (= axle track)</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_middle</code>: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)</li><li><code>frame1</code>: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>frame2</code>: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>axis1</code>: 1-dim. Rotational flange that drives the left wheel</li><li><code>axis2</code>: 1-dim. Rotational flange that drives the right wheel</li><li><code>support</code>: Support of 1D axes</li></ul><p>To connect driving torques or friction to rotation of the wheels, connect between <code>axis1</code> and <code>support</code>, and <code>axis2</code> and <code>support</code> respectively. To connect the wheel set to, e.g., a body, connect the <code>frame_middle</code> to the body frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L746-L789">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelSetJoint-Tuple{}" href="#Multibody.RollingWheelSetJoint-Tuple{}"><code>Multibody.RollingWheelSetJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RollingWheelSetJoint(;
    name,
    radius = 0.3,
    track = 1.0,
    state_priority = 1,
    x0 = 0,
    z0 = 0,
    phi0 = 0,
    theta1_0 = 0,
    theta2_0 = 0,
    der_theta1_0 = 0,
    der_theta2_0 = 0,
    render = true,
    iscut = false,
)</code></pre><p>Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)</p><p>An assembly joint for a wheelset rolling on the x-z plane of the world frame. The frames <code>frame1</code> and <code>frame2</code> are connected to rotating wheels; the <code>frame_middle</code> moves in a plane parallel to the x-z plane of the world and should be connected to the vehicle body.</p><p>To work properly, the gravity acceleration vector g of the world must point in the negative y-axis (default)</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>iscut</code>: if more than one wheel set is connected to the same rigid body, <code>iscut</code> must be set to true for all but one set. This avoids overconstraining the system by replacing the planar joint giving the set coordinates by an unconstrained FreeMotion joint.</li><li><code>radius</code>: Radius of one wheel</li><li><code>track</code>: Distance between the two wheels (= axle track)</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_middle</code>: Frame fixed in middle of axis connecting both wheels (z-axis: along wheel axis, y-axis: upwards)</li><li><code>frame1</code>: Frame fixed in center point of left wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>frame2</code>: Frame fixed in center point of right wheel, rotating with the wheel (z-axis: along wheel axis, y-axis: upwards when wheel angle is zero)</li><li><code>axis1</code>: 1-dim. Rotational flange that drives the joint</li><li><code>axis2</code>: 1-dim. Rotational flange that drives the joint</li><li><code>support</code>: Support of 1-dim axes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L606-L641">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SlipWheelJoint-Tuple{}" href="#Multibody.SlipWheelJoint-Tuple{}"><code>Multibody.SlipWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlipWheelJoint(; name, radius, angles = zeros(3), der_angles = zeros(3), x0 = 0, y0 = radius, z0 = 0, sequence, iscut = false, surface = nothing, vAdhesion_min = 0.1, vSlide_min = 0.1, sAdhesion = 0.1, sSlide = 0.1, mu_A = 0.8, mu_S = 0.6, phi_roll = 0, w_roll = 0)</code></pre><p>Joint for a wheel with slip rolling on a surface.</p><p><strong>Parameters</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>vAdhesion_min</code>: Minimum adhesion velocity</li><li><code>vSlide_min</code>: Minimum sliding velocity</li><li><code>sAdhesion</code>: Adhesion slippage</li><li><code>sSlide</code>: Sliding slippage</li><li><code>mu_A</code>: Friction coefficient at adhesion</li><li><code>mu_S</code>: Friction coefficient at sliding</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L267-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SlippingWheel-Tuple{}" href="#Multibody.SlippingWheel-Tuple{}"><code>Multibody.SlippingWheel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlippingWheel(; name, radius, m, I_axis, I_long, width = 0.035, x0=0, z0=0,
                  angles = zeros(3), der_angles = zeros(3), kwargs...)</code></pre><p>Wheel with slip rolling on a surface.</p><p><strong>Parameters</strong></p><ul><li><code>radius</code>: Radius of the wheel</li><li><code>m</code>: Mass of the wheel</li><li><code>I_axis</code>: Moment of inertia of the wheel along its axis</li><li><code>I_long</code>: Moment of inertia of the wheel perpendicular to its axis</li><li><code>width</code>: Width of the wheel (for rendering)</li><li><code>x0</code>: Initial x-position of the wheel axis</li><li><code>z0</code>: Initial z-position of the wheel axis</li></ul><p><strong>Variables</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around y-, z-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code>: Frame for the wheel component</li></ul><p><strong>Examples</strong></p><p>See <a href="https://help.juliahub.com/multibody/dev/examples/wheel/">Docs: Wheels</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/wheels.jl#L443-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.BodyShape" href="#Multibody.PlanarMechanics.BodyShape"><code>Multibody.PlanarMechanics.BodyShape</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BodyShape(; name, r = [1,0], r_cm = 0.5*r, gy = -9.80665)</code></pre><p>The <code>BodyShape</code> component is similar to a <a href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Body</code></a>, but it has two frames and a vector <code>r</code> that describes the translation between them, while the body has a single frame only.</p><p><strong>Parameters</strong></p><ul><li><code>r</code>: (Structural) Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li><code>r_cm</code>: (Structural) Vector from <code>frame_a</code> to the center of mass resolved in <code>frame_a</code></li></ul><p><strong>Subsystems</strong></p><ul><li><code>translation</code>: <a href="#Multibody.PlanarMechanics.FixedTranslation">FixedTranslation</a> Fixed translation between <code>frame_a</code> and <code>frame_b</code></li><li><code>translation_cm</code>: <a href="#Multibody.PlanarMechanics.FixedTranslation">FixedTranslation</a> Fixed translation between <code>frame_a</code> and the center of mass</li><li><code>body</code>: <a href="#Multibody.PlanarMechanics.Body-Tuple{}">Body</a> Body component placed at center of mass. This component holds the inertial properties</li></ul><p><strong>Connectors</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L97-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Damper" href="#Multibody.PlanarMechanics.Damper"><code>Multibody.PlanarMechanics.Damper</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Damper(; name, d = 1, s_small = 1.e-10)</code></pre><p>Linear (velocity dependent) damper</p><p><strong>Parameters:</strong></p><ul><li><code>d</code>: [N.s/m] Damping constant </li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L273-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.DifferentialGear" href="#Multibody.PlanarMechanics.DifferentialGear"><code>Multibody.PlanarMechanics.DifferentialGear</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DifferentialGear(; name)</code></pre><p>A 1D-rotational component that is a variant of a planetary gear and can be used to distribute the torque equally among the wheels on one axis.</p><p><strong>Connectors:</strong></p><ul><li><code>flange_b</code> (Rotational.Flange) Flange for the input torque</li><li><code>flange_left</code> (Rotational.Flange) Flange for the left output torque</li><li><code>flange_right</code> (Rotational.Flange) Flange for the right output torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L778-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Fixed" href="#Multibody.PlanarMechanics.Fixed"><code>Multibody.PlanarMechanics.Fixed</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fixed(; name, r = [0.0, 0.0], phi = 0.0)</code></pre><p>Frame fixed in the planar world frame at a given position and orientation</p><p><strong>Parameters:</strong></p><ul><li><code>r</code>: [m, m] Fixed absolute x,y-position, resolved in world frame</li><li><code>phi</code>: [rad] Fixed angle</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_b</code>: 2-dim. Coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.FixedTranslation" href="#Multibody.PlanarMechanics.FixedTranslation"><code>Multibody.PlanarMechanics.FixedTranslation</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixedTranslation(; name, r::AbstractArray, l)</code></pre><p>A fixed translation between two components (rigid rod)</p><p><strong>Parameters:</strong></p><ul><li><code>rx</code>: [m] Fixed x-length of the rod resolved w.r.t to body frame_a at phi = 0</li><li><code>ry</code>: [m] Fixed y-length of the rod resolved w.r.t to body frame_a at phi = 0</li><li><code>radius</code>: [m] Radius of the rod in animations</li><li><code>render</code>: [Bool] Render the rod in animations</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L144-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.IdealPlanetary" href="#Multibody.PlanarMechanics.IdealPlanetary"><code>Multibody.PlanarMechanics.IdealPlanetary</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdealPlanetary(; name, ratio = 2)</code></pre><p>The IdealPlanetary gear box is an ideal gear without inertia, elasticity, damping or backlash consisting of an inner sun wheel, an outer ring wheel and a planet wheel located between sun and ring wheel. The bearing of the planet wheel shaft is fixed in the planet carrier. The component can be connected to other elements at the sun, ring and/or carrier flanges. It is not possible to connect to the planet wheel. If inertia shall not be neglected, the sun, ring and carrier inertias can be easily added by attaching inertias (= model Inertia) to the corresponding connectors. The inertias of the planet wheels are always neglected.</p><p>The ideal planetary gearbox is uniquely defined by the ratio of the number of ring teeth <span>$z_r$</span> with respect to the number of sun teeth <span>$z_s$</span>. For example, if there are 100 ring teeth and 50 sun teeth then ratio = <span>$z_r/z_s = 2$</span>. The number of planet teeth <span>$z_p$</span> has to fulfill the following relationship:</p><p class="math-container">\[z_p = (z_r - z_s) / 2\]</p><p>Therefore, in the above example <span>$z_p = 25$</span> is required.</p><p>According to the overall convention, the positive direction of all vectors, especially the absolute angular velocities and cut-torques in the flanges, are along the axis vector displayed in the icon.</p><p><strong>Parameters:</strong></p><ul><li><code>ratio</code>: Number of ring teeth/sun teeth</li></ul><p><strong>Connectors:</strong></p><ul><li><code>sun</code> (Rotational.Flange) Sun wheel</li><li><code>carrier</code> (Rotational.Flange) Planet carrier</li><li><code>ring</code> (Rotational.Flange) Ring wheel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L741-L761">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SimpleWheel" href="#Multibody.PlanarMechanics.SimpleWheel"><code>Multibody.PlanarMechanics.SimpleWheel</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleWheel(; name, radius = 0.3, color = [1, 0, 0, 1], μ = 1e9)</code></pre><p>Simple wheel model with viscous lateral friction and a driving torque</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> (Frame) Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>thrust</code> (RealInput) Input for the longitudinal force applied to the wheel</li></ul><p><strong>Parameters:</strong></p><ul><li><code>μ</code>: [Ns/m] Viscous friction coefficient</li><li><code>radius</code>: [m] Radius of the wheel</li><li><code>color</code>: Color of the wheel in animations</li></ul><p><strong>Variables:</strong></p><ul><li><code>θ</code>: [rad] Wheel angle</li><li><code>Vx</code>: [m/s] Longitudinal velocity (resolved in local frame)</li><li><code>Vy</code>: [m/s] Lateral velocity (resolved in local frame)</li><li><code>Fy</code>: [N] Lateral friction force</li><li><code>Fx</code>: [N] Applied longitudinal wheel force</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L425-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Spring" href="#Multibody.PlanarMechanics.Spring"><code>Multibody.PlanarMechanics.Spring</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spring(; name, c_x = 1, c_y = 1, c_phi = 1e5, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)</code></pre><p>Linear 2D translational spring</p><p><strong>Parameters:</strong></p><ul><li><code>c_x</code>: [N/m] Spring constant in x dir</li><li><code>c_y</code>: [N/m] Spring constant in y dir</li><li><code>c_phi</code>: [N.m/rad] Spring constant in phi dir</li><li><code>s_relx0</code>: [m] Unstretched spring length</li><li><code>s_rely0</code>: [m] Unstretched spring length</li><li><code>phi_rel0</code>: [rad] Unstretched spring angle</li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li><li><code>num_windings</code>: [Int] Number of windings of the coil when rendered</li><li><code>color = [0,0,1,1]</code> Color of the spring in animations</li><li><code>render = true</code> Render the spring in animations</li><li><code>radius = 0.1</code> Radius of spring when rendered</li><li><code>N = 200</code> Number of points in mesh when rendered</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L200-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SpringDamper" href="#Multibody.PlanarMechanics.SpringDamper"><code>Multibody.PlanarMechanics.SpringDamper</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpringDamper(; name, c_x = 1, c_y = 1, c_phi = 1e5, d_x = 1, d_y = 1, d_phi = 1, s_relx0 = 0, s_rely0 = 0, phi_rel0 = 0, s_small = 1.e-10)</code></pre><p>Linear 2D translational spring damper model</p><p><strong>Parameters:</strong></p><ul><li><code>c_x</code>: [N/m] Spring constant in x dir</li><li><code>c_y</code>: [N/m] Spring constant in y dir</li><li><code>c_phi</code>: [N.m/rad] Spring constant in phi dir</li><li><code>d_x</code>: [N.s/m] Damping constant in x dir</li><li><code>d_y</code>: [N.s/m] Damping constant in y dir</li><li><code>d_phi</code>: [N.m.s/rad] Damping constant in phi dir</li><li><code>s_relx0</code>: [m] Unstretched spring length</li><li><code>s_rely0</code>: [m] Unstretched spring length</li><li><code>phi_rel0</code>: [rad] Unstretched spring angle</li><li><code>s_small</code>: [m] Prevent zero-division if distance between frame<em>a and frame</em>b is zero</li><li><code>num_windings</code>: [Int] Number of windings of the coil when rendered</li><li><code>color = [0,0,1,1]</code> Color of the spring in animations</li><li><code>render = true</code> Render the spring in animations</li><li><code>radius = 0.1</code> Radius of spring when rendered</li><li><code>N = 200</code> Number of points in mesh when rendered</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>frame_b</code> <a href="#Multibody.PlanarMechanics.Frame">Frame</a> Coordinate system fixed to the component with one cut-force and cut-torque</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L334-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.Body-Tuple{}" href="#Multibody.PlanarMechanics.Body-Tuple{}"><code>Multibody.PlanarMechanics.Body</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Body(; name, m=1, I=0.1, r=0, gy=-9.80665, radius=0.1, render=true, color=Multibody.purple)</code></pre><p>Body component with mass and inertia</p><p><strong>Parameters:</strong></p><ul><li><code>m</code>: [kg] mass of the body</li><li><code>I</code>: [kg.m²] inertia of the body with respect to the origin of <code>frame</code> along the z-axis of <code>frame</code></li><li><code>r</code>: [m, m] Translational position x,y-position</li><li><code>gy</code>: [m/s²] gravity field acting on the mass in the y-direction, positive value acts in the positive direction defaults to -9.80665</li><li><code>radius</code>: [m] Radius of the body in animations</li><li><code>render</code>: [Bool] Render the body in animations</li><li><code>color</code>: [Array{Float64,1}] Color of the body in animations</li></ul><p><strong>Variables:</strong></p><ul><li><code>r</code>: [m, m] x,y position</li><li><code>v</code>: [m/s, m/s] x,y velocity</li><li><code>a</code>: [m/s², m/s²] x,y acceleration</li><li><code>phi</code>: [rad] rotation angle (counterclockwise)</li><li><code>w</code>: [rad/s] angular velocity</li><li><code>α</code>: [rad/s²] angular acceleration</li></ul><p><strong>Connectors:</strong></p><ul><li><code>frame</code>: 2-dim. Coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L31-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}" href="#Multibody.PlanarMechanics.SlipBasedWheelJoint-Tuple{}"><code>Multibody.PlanarMechanics.SlipBasedWheelJoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlipBasedWheelJoint(;
    name,
    r = [1, 0],
    N,
    vAdhesion_min,
    vSlide_min,
    sAdhesion,
    sSlide,
    mu_A,
    mu_S,
    render = true,
    color = [0.1, 0.1, 0.1, 1],
    z = 0,
    diameter = 0.1,
    width = diameter * 0.6,
    radius = 0.1,
    w_roll = nothing,
)</code></pre><p>Slip-based wheel joint</p><p>The ideal wheel joint models the behavior of a wheel rolling on a x,y-plane whose contact patch has slip-dependent friction characteristics. This is an approximation for wheels with a rim and a rubber tire.</p><p>The force depends with friction characteristics on the slip. The slip is split into two components:</p><ul><li>lateral slip: the lateral velocity divided by the rolling velocity.</li><li>longitudinal slip: the longitudinal slip velocity divided by the rolling velocity.</li></ul><p>For low rolling velocity this definition become ill-conditioned. Hence a dry-friction model is used for low rolling velocities. For <strong>zero rolling velocity</strong>, the intitialization might fail if automatic differentiation is used. Either start with a non-zero (but tiny) rolling velocity or pass <code>autodiff=false</code> to the solver.</p><p>The radius of the wheel can be specified by the parameter <code>radius</code>. The driving direction (for <code>phi = 0</code>) can be specified by the parameter <code>r</code>. The normal load is set by <code>N</code>.</p><p>The wheel contains a 2D connector <code>frame_a</code> for the steering on the plane. The rolling motion of the wheel can be actuated by the 1D connector <code>flange_a</code>.</p><p>In addition there is an input <code>dynamicLoad</code> for a dynamic component of the normal load.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code> (Frame) Coordinate system fixed to the component with one cut-force and cut-torque</li><li><code>flange_a</code> (Rotational.Flange) Flange for the rolling motion</li><li><code>dynamicLoad</code> (Blocks.RealInput) Input for the dynamic component of the normal load (must be connected)</li></ul><p><strong>Terminology:</strong></p><ul><li><em>Adhesion</em> refers to the peak of the traction curve, where the slip is such that the maximum amount of traction is generated.</li><li><em>Sliding velocity</em> refers to the velocity at which the traction curve saturates and stays constant with increased slip velocity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L597-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}" href="#Multibody.PlanarMechanics.limit_S_form-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit_S_form(x_min, x_max, y_min, y_max, x)</code></pre><p>Returns a S-shaped transition</p><p>A smooth transition between points <code>(x_min, y_min)</code> and <code>(x_max, y_max)</code>. The transition is done in such a way that the 1st function&#39;s derivative is continuous for all <code>x</code>. The higher derivatives are discontinuous at input points.</p><pre><code class="nohighlight hljs">x_min = -0.4
x_max = 0.6
y_max = 1.4
y_min = 1.2

julia&gt; plot(x-&gt;Multibody.PlanarMechanics.limit_S_form(x_min, x_max, y_min, y_max, x), -1, 1, legend=false)
         ┌────────────────────────────────────────┐ 
   1.406 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⡠⠔⠒⠒⠒⠒⠒⠒⠒⠂⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠃⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡔⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   1.194 │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠖⠉⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
         └────────────────────────────────────────┘ 
         ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L544-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}" href="#Multibody.PlanarMechanics.limit_S_triple-NTuple{5, Any}"><code>Multibody.PlanarMechanics.limit_S_triple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limit_S_triple(x_max, x_sat, y_max, y_sat, x)</code></pre><p>Returns a point-symmetric Triple S-Function</p><p>A point symmetric interpolation between points <code>(0, 0), (x_max, y_max) and (x_sat, y_sat)</code>, provided <code>x_max &lt; x_sat</code>. The approximation is done in such a way that the 1st function&#39;s derivative is zero at points <code>(x_max, y_max)</code> and <code>(x_sat, y_sat)</code>. Thus, the 1st function&#39;s derivative is continuous for all <code>x</code>. The higher derivatives are discontinuous at these points.</p><pre><code class="nohighlight hljs">x_max = 0.2
x_sat = 0.5
y_max = 1.4
y_sat = 1.2

plot(x-&gt;Multibody.PlanarMechanics.limit_S_triple(x_max, x_sat, y_max, y_sat, x), -1, 1)
vline!([x_max x_sat], label=[&quot;x_max&quot; &quot;x_sat&quot;])

            ┌────────────────────────────────────────┐ 
    1.48385 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⢀⡔⠢⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⡜⠀⠀⠀⠈⠉⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠂⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⡧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠃⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            │⠀⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⣀⡀⠀⠀⠀⡜⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
   -1.48377 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠒⠦⠼⠁⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ 
            └────────────────────────────────────────┘ 
            ⠀-1.06⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1.06⠀ </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/components.jl#L497-L532">source</a></section></article><h2 id="Forces"><a class="docs-heading-anchor" href="#Forces">Forces</a><a id="Forces-1"></a><a class="docs-heading-anchor-permalink" href="#Forces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BasicTorque-Tuple{}" href="#Multibody.BasicTorque-Tuple{}"><code>Multibody.BasicTorque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BasicTorque(; name, resolve_frame = :world)</code></pre><p>Low-level torque component used to build <a href="#Multibody.Torque-Tuple{}"><code>Torque</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Damper-Tuple{}" href="#Multibody.Damper-Tuple{}"><code>Multibody.Damper</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Damper(; d, name, kwargs)</code></pre><p>Linear damper acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = d D(s)\]</p><p>where <code>d</code> is the (viscous) damping parameter, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> and <code>D(s)</code> is the time derivative of <code>s</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: Damping coefficient</li></ul><p><strong>Rendering</strong></p><ul><li><code>radius = 0.1</code>: Radius of damper when rendered</li><li><code>length_fraction = 0.2</code>: Fraction of the length of the damper that is rendered</li><li><code>color = [0.5, 0.5, 0.5, 1]</code>: Color of the damper when rendered</li></ul><p>See also <a href="#Multibody.SpringDamperParallel-Tuple{}"><code>SpringDamperParallel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L455-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Force-Tuple{}" href="#Multibody.Force-Tuple{}"><code>Multibody.Force</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Force(; name, resolve_frame = :frame_b)</code></pre><p>Force acting between two frames, defined by 3 input signals and resolved in frame <code>world</code>, <code>frame_a</code>, <code>frame_b</code> (default)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li><li><code>force</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of force resolved in frame defined by <code>resolve_frame</code>.</li></ul><p><strong>Keyword arguments:</strong></p><ul><li><code>resolve_frame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_b</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L177-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Spring-Tuple{}" href="#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spring(; c, name, m = 0, lengthfraction = 0.5, s_unstretched = 0, kwargs)</code></pre><p>Linear spring acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = c s\]</p><p>where <code>c</code> is the spring stiffness parameter, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code>.</p><p>Optionally, the mass of the spring is taken into account by a point mass located on the line between <code>frame_a</code> and <code>frame_b</code> (default: middle of the line). If the spring mass is zero, the additional equations to handle the mass are removed.</p><p><strong>Arguments:</strong></p><ul><li><code>c</code>: Spring stiffness</li><li><code>m</code>: Mass of the spring (can be zero)</li><li><code>lengthfraction</code>: Location of spring mass with respect to <code>frame_a</code> as a fraction of the distance from <code>frame_a</code> to <code>frame_b</code> (=0: at <code>frame_a</code>; =1: at <code>frame_b</code>)</li><li><code>s_unstretched</code>: Length of the spring when it is unstretched</li><li><code>kwargs</code>: are passed to <code>LineForceWithMass</code></li></ul><p><strong>Rendering</strong></p><ul><li><code>num_windings = 6</code>: Number of windings of the coil when rendered</li><li><code>color = [0,0,1,1]</code>: Color of the spring when rendered</li><li><code>radius = 0.1</code>: Radius of spring when rendered</li><li><code>N = 200</code>: Number of points in mesh when rendered. Rendering time can be reduced somewhat by reducing this number.</li></ul><p>See also <a href="#Multibody.SpringDamperParallel-Tuple{}"><code>SpringDamperParallel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L361-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SpringDamperParallel-Tuple{}" href="#Multibody.SpringDamperParallel-Tuple{}"><code>Multibody.SpringDamperParallel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpringDamperParallel(; name, c, d, s_unstretched)</code></pre><p>Linear spring and linear damper in parallel acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = c (s - s_{unstretched}) + d \cdot D(s)\]</p><p>where <code>c</code>, <code>s_unstretched</code> and <code>d</code> are parameters, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> and <code>D(s)</code> is the time derivative of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L494-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Torque-Tuple{}" href="#Multibody.Torque-Tuple{}"><code>Multibody.Torque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Torque(; name, resolve_frame = :frame_b)</code></pre><p>Torque acting between two frames, defined by 3 input signals and resolved in frame <code>world</code>, <code>frame_a</code>, <code>frame_b</code> (default)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li><li><code>torque</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of torque resolved in frame defined by <code>resolve_frame</code>.</li></ul><p><strong>Keyword arguments:</strong></p><ul><li><code>resolve_frame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_b</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L51-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.WorldForce-Tuple{}" href="#Multibody.WorldForce-Tuple{}"><code>Multibody.WorldForce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WorldForce(; name, resolve_frame = :world)</code></pre><p>External force acting at <code>frame_b</code>, defined by 3 input signals and resolved in frame <code>:world</code> or <code>:frame_b</code>.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_b</code>: Frame at which the force is acting</li><li><code>force</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of force resolved in frame defined by <code>resolve_frame</code>.</li></ul><p><strong>Rendering options</strong></p><ul><li><code>scale = 0.1</code>: scaling factor for the force [m/N]</li><li><code>color = [0,1,0,0.5]</code>: color of the force arrow in rendering</li><li><code>radius = 0.05</code>: radius of the force arrow in rendering</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L204-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.WorldTorque-Tuple{}" href="#Multibody.WorldTorque-Tuple{}"><code>Multibody.WorldTorque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WorldTorque(; name, resolve_frame = :world)</code></pre><p>External torque acting at <code>frame_b</code>, defined by 3 input signals and resolved in frame <code>:world</code> or <code>:frame_b</code>.</p><p><strong>Connectors:</strong></p><ul><li><code>frame_b</code>: Frame at which the torque is acting</li><li><code>torque</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of torque resolved in frame defined by <code>resolve_frame</code>.</li></ul><p><strong>Rendering options</strong></p><ul><li><code>scale = 0.1</code>: scaling factor for the force [m/N]</li><li><code>color = [0,1,0,0.5]</code>: color of the force arrow in rendering</li><li><code>radius = 0.05</code>: radius of the force arrow in rendering</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/forces.jl#L92-L105">source</a></section></article><h2 id="Sensors"><a class="docs-heading-anchor" href="#Sensors">Sensors</a><a id="Sensors-1"></a><a class="docs-heading-anchor-permalink" href="#Sensors" title="Permalink"></a></h2><p>A sensor is an object that translates quantities in the mechanical domain into causal signals which can interact with causal components from <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/">ModelingToolkitStandardLibrary.Blocks</a>, such as control systems etc.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.CutForce-Tuple{}" href="#Multibody.CutForce-Tuple{}"><code>Multibody.CutForce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BasicCutForce(; name, resolve_frame)</code></pre><p>Basic sensor to measure cut force vector. Contains a connector of type <code>Blocks.RealOutput</code> with name <code>force</code>.</p><ul><li><code>resolve_frame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/sensors.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.CutTorque-Tuple{}" href="#Multibody.CutTorque-Tuple{}"><code>Multibody.CutTorque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CutTorque(; name, resolve_frame)</code></pre><p>Basic sensor to measure cut torque vector. Contains a connector of type <code>Blocks.RealOutput</code> with name <code>torque</code>.</p><ul><li><code>resolve_frame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/sensors.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PartialCutForceBaseSensor-Tuple{}" href="#Multibody.PartialCutForceBaseSensor-Tuple{}"><code>Multibody.PartialCutForceBaseSensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialCutForceBaseSensor(; name, resolve_frame = :frame_a)</code></pre><ul><li><code>resolve_frame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/sensors.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Power-Tuple{}" href="#Multibody.Power-Tuple{}"><code>Multibody.Power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Power(; name)</code></pre><p>A sensor measuring mechanical power transmitted from <code>frame_a</code> to <code>frame_b</code>.</p><p><strong>Connectors:</strong></p><p><code>power</code> of type <code>RealOutput</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/sensors.jl#L151-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.PartialAbsoluteBaseSensor" href="#Multibody.PlanarMechanics.PartialAbsoluteBaseSensor"><code>Multibody.PlanarMechanics.PartialAbsoluteBaseSensor</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialAbsoluteBaseSensor(;name)</code></pre><p>Partial absolute sensor models for sensors defined by equations (frame_resolve must be connected exactly once)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: 2-dim. Coordinate system from which kinematic quantities are measured</li><li><code>frame_resolve</code>: 2-dim. Coordinate system in which vector is optionally resolved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.PartialAbsoluteSensor" href="#Multibody.PlanarMechanics.PartialAbsoluteSensor"><code>Multibody.PlanarMechanics.PartialAbsoluteSensor</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialAbsoluteSensor(;name)</code></pre><p>Partial absolute sensor model for sensors defined by components</p><p><strong>Connectors:</strong></p><ul><li>`frame: 2-dim. Coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.PartialRelativeBaseSensor" href="#Multibody.PlanarMechanics.PartialRelativeBaseSensor"><code>Multibody.PlanarMechanics.PartialRelativeBaseSensor</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialRelativeBaseSensor(;name)</code></pre><p>Partial relative sensor models for sensors defined by equations (frame_resolve must be connected exactly once)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: </li><li><code>frame_b</code>: </li><li><code>frame_resolve</code>: </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.PartialRelativeSensor" href="#Multibody.PlanarMechanics.PartialRelativeSensor"><code>Multibody.PlanarMechanics.PartialRelativeSensor</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialRelativeSensor(;name)</code></pre><p>Partial relative sensor model for sensors defined by components</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code>: Coordinate system a</li><li><code>frame_b</code>: Coordinate system b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.AbsolutePosition-Tuple{}" href="#Multibody.PlanarMechanics.AbsolutePosition-Tuple{}"><code>Multibody.PlanarMechanics.AbsolutePosition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbsolutePosition(;name, resolve_in_frame = :frame_a)</code></pre><p>Measure absolute position and orientation of the origin of frame connector</p><p><strong>Connectors:</strong></p><ul><li><code>x</code>: [m] x-position</li><li><code>y</code>: [m] y-position</li><li><code>phi</code>: [rad] rotation angle (counterclockwise)</li></ul><p><strong>Parameters:</strong></p><ul><li><code>resolve_in_frame</code>: Frame in which output x, y, phi is resolved (1: :world, 2: :frame<em>a, 3: :frame</em>resolve)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.BasicAbsolutePosition-Tuple{}" href="#Multibody.PlanarMechanics.BasicAbsolutePosition-Tuple{}"><code>Multibody.PlanarMechanics.BasicAbsolutePosition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BasicAbsolutePosition(;name, resolve_in_frame = :frame_a)</code></pre><p>Measure absolute position and orientation (same as Sensors.AbsolutePosition, but frame_resolve is not conditional and must be connected).</p><p><strong>Connectors:</strong></p><ul><li><code>x</code>: [m] x-position</li><li><code>y</code>: [m] y-position</li><li><code>phi</code>: [rad] rotation angle (counterclockwise)</li><li><code>frame_a</code>: Coordinate system a</li><li><code>frame_resolve</code>: 2-dim. Coordinate system in which vector is optionally resolved</li></ul><p><strong>Parameters:</strong></p><ul><li><code>resolve_in_frame</code>: Frame in which output x, y, phi r is resolved (1: :world, 2: :frame<em>a, 3: :frame</em>resolve)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L90-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.BasicRelativePosition-Tuple{}" href="#Multibody.PlanarMechanics.BasicRelativePosition-Tuple{}"><code>Multibody.PlanarMechanics.BasicRelativePosition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BasicRelativePosition(; name, resolve_in_frame = :frame_a)</code></pre><p>Measure relative position and orientation between the origins of two frame connectors</p><p><strong>Connectors:</strong></p><ul><li><code>rel_x</code>: [m] Relative x-position</li><li><code>rel_y</code>: [m] Relative y-position</li><li><code>rel_phi</code>: [rad] Relative rotation angle (counterclockwise)</li><li><code>frame_a</code>: Coordinate system a</li><li><code>frame_b</code>: Coordinate system b</li><li><code>frame_resolve</code>: </li></ul><p><strong>Parameters:</strong></p><pre><code class="nohighlight hljs">- `resolve_in_frame`: Frame in which output x, y, phi is resolved (1: :world, 2: :frame_a, 3: frame_b 4: :frame_resolve)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L195-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PlanarMechanics.RelativePosition-Tuple{}" href="#Multibody.PlanarMechanics.RelativePosition-Tuple{}"><code>Multibody.PlanarMechanics.RelativePosition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RelativePosition(; name, resolve_in_frame = :frame_a)</code></pre><p>Measure relative position and orientation between the origins of two frame connectors</p><p><strong>Connectors:</strong></p><pre><code class="nohighlight hljs">- `rel_x`: [m] Relative x-position
- `re_y`: [m] Relative y-position
- `rel_phi`: [rad] Relative rotation angle (counterclockwise)
- `frame_a`: Coordinate system a
- `frame_b`: Coordinate system b</code></pre><p><strong>Parameters:</strong></p><pre><code class="nohighlight hljs">- `resolve_in_frame`: Frame in which output x, y, phi is resolved (1: :world, 2: :frame_a, 3: frame_b 4: :frame_resolve)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/PlanarMechanics/sensors.jl#L260-L274">source</a></section></article><h2 id="Orientation-utilities"><a class="docs-heading-anchor" href="#Orientation-utilities">Orientation utilities</a><a id="Orientation-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Orientation-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RotationMatrix" href="#Multibody.RotationMatrix"><code>Multibody.RotationMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RotationMatrix</code></pre><p>A struct representing a 3D orientation as a rotation matrix.</p><p>If <code>ODESystem</code> is called on a <code>RotationMatrix</code> object <code>o</code>, symbolic variables for <code>o.R</code> and <code>o.w</code> are created and the value of <code>o.R</code> is used as the default value for the symbolic <code>R</code>.</p><p><strong>Fields:</strong></p><ul><li><code>R::R3</code>: The rotation 3×3 matrix ∈ SO(3)</li><li><code>w</code>: The angular velocity vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.NumRotationMatrix-Tuple{}" href="#Multibody.NumRotationMatrix-Tuple{}"><code>Multibody.NumRotationMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NumRotationMatrix(; R = collect(1.0 * I(3)), w = zeros(3), name, varw = false)</code></pre><p>Create a new <a href="#Multibody.RotationMatrix"><code>RotationMatrix</code></a> struct with symbolic elements. <code>R,w</code> determine default values.</p><p>The primary difference between <code>NumRotationMatrix</code> and <code>RotationMatrix</code> is that the <code>NumRotationMatrix</code> constructor is used in the constructor of a <a href="#Multibody.Frame"><code>Frame</code></a> in order to introduce the frame variables, whereas <code>RorationMatrix</code> (the struct) only wraps existing variables.</p><ul><li><code>varw</code>: If true, <code>w</code> is a variable, otherwise it is derived from the derivative of <code>R</code> as <code>w = get_w(R)</code>.</li></ul><p>Never call this function directly from a component constructor, instead call <code>f = Frame(); R = ori(f)</code> and add <code>f</code> to the subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.absolute_rotation-Tuple{Any, Any}" href="#Multibody.absolute_rotation-Tuple{Any, Any}"><code>Multibody.absolute_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R2 = absolute_rotation(R1, Rrel)</code></pre><ul><li><code>R1</code>: <code>Orientation</code> object to rotate frame 0 into frame 1</li><li><code>Rrel</code>: <code>Orientation</code> object to rotate frame 1 into frame 2</li><li><code>R2</code>: <code>Orientation</code> object to rotate frame 0 into frame 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L163-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.axes_rotations" href="#Multibody.axes_rotations"><code>Multibody.axes_rotations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axes_rotations(sequence, angles, der_angles; name = :R_ar)</code></pre><p>Generate a rotation matrix for a rotation around the specified axes (Euler/Cardan angles).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.axis_rotation-Tuple{Any, Any}" href="#Multibody.axis_rotation-Tuple{Any, Any}"><code>Multibody.axis_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axis_rotation(sequence, angle; name = :R)</code></pre><p>Generate a rotation matrix for a rotation around the specified axis.</p><ul><li><code>sequence</code>: The axis to rotate around (1: x-axis, 2: y-axis, 3: z-axis)</li><li><code>angle</code>: The angle of rotation (in radians)</li></ul><p>Returns a <code>RotationMatrix</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L301-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.connect_orientation-Tuple{Any, Any}" href="#Multibody.connect_orientation-Tuple{Any, Any}"><code>Multibody.connect_orientation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect_orientation(R1,R2; iscut=false)</code></pre><p>Connect two rotation matrices together, optionally introducing a cut joint. A normal connection of two rotation matrices introduces 9 constraints, while a cut connection introduces 3 constraints only. This is useful to open kinematic loops, see <a href="examples/kinematic_loops/#Using-cut-joints">Using cut joints</a> (docs page) for an example where this is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_frame-Tuple{Any, Any, Any}" href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>Multibody.get_frame</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T_W_F = get_frame(sol, frame, t)</code></pre><p>Extract a 4×4 transformation matrix ∈ SE(3) from a solution at time <code>t</code>.</p><p>The transformation matrix returned, <span>$T_W^F$</span>, is such that when a homogenous-coordinate vector <span>$p_F$</span>, expressed in the local <code>frame</code> of reference <span>$F$</span> is multiplied by <span>$T_W^F$</span> as <span>$Tp$</span>, the resulting vector is <span>$p_W$</span> expressed in the world frame:</p><p class="math-container">\[p_W = T_W^F  p_F\]</p><p>See also <a href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>get_trans</code></a> and <a href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>, <a href="examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L400-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_rot-Tuple{Any, Any, Any}" href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>Multibody.get_rot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R_W_F = get_rot(sol, frame, t)</code></pre><p>Extract a 3×3 rotation matrix ∈ SO(3) from a solution at time <code>t</code>.</p><p>The rotation matrix returned, <span>$R_W^F$</span>, is such that when a vector <span>$p_F$</span> expressed in the local <code>frame</code> of reference <span>$F$</span> is multiplied by <span>$R_W^F$</span> as <span>$Rp$</span>, the resulting vector is <span>$p_W$</span> expressed in the world frame:</p><p class="math-container">\[p_W = R_W^F  p_F\]</p><p>The columns of <span>$R_W_F$</span> indicate are the basis vectors of the frame <span>$F$</span> expressed in the world coordinate frame.</p><p>See also <a href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>get_trans</code></a>, <a href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>get_frame</code></a>, <a href="examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L373-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_trans-Tuple{Any, Any, Number}" href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>Multibody.get_trans</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trans(sol, frame, t)</code></pre><p>Extract the translational part of a frame from a solution at time <code>t</code>. See also <a href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>, <a href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>get_frame</code></a>, <a href="examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L391-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_w-Tuple{AbstractMatrix}" href="#Multibody.get_w-Tuple{AbstractMatrix}"><code>Multibody.get_w</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_w(R)</code></pre><p>Compute the angular velocity <code>w</code> from the rotation matrix <code>R</code> and its derivative <code>DR = D.(R)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.planar_rotation-Tuple{Any, Any, Any}" href="#Multibody.planar_rotation-Tuple{Any, Any, Any}"><code>Multibody.planar_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">planar_rotation(axis, phi, phid)</code></pre><p>Generate a rotation matrix for a rotation around the specified axis (axis-angle representation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve1-Tuple{RotationMatrix, Any}" href="#Multibody.resolve1-Tuple{RotationMatrix, Any}"><code>Multibody.resolve1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">h1 = resolve1(R21, h2)</code></pre><p><code>R12</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h2</code> is a vector resolved in frame 2. <code>h1</code> is the same vector in frame 1.</p><p>Typical usage (local to world):</p><pre><code class="language-julia hljs">r_wb = resolve1(ori(frame_a), r_ab)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve2-Tuple{RotationMatrix, Any}" href="#Multibody.resolve2-Tuple{RotationMatrix, Any}"><code>Multibody.resolve2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">h2 = resolve2(R21, h1)</code></pre><p><code>R21</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h1</code> is a vector resolved in frame 1. <code>h2</code> is the same vector in frame 2.</p><p>Typical usage (world to local):</p><pre><code class="language-julia hljs">g_a = resolve2(ori(frame_a), a_0 - g_0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/orientation.jl#L110-L120">source</a></section></article><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2><h2 id="Trajectory-planning"><a class="docs-heading-anchor" href="#Trajectory-planning">Trajectory planning</a><a id="Trajectory-planning-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-planning" title="Permalink"></a></h2><p>Two methods of planning trajectories are available</p><ul><li><a href="#Multibody.point_to_point-Tuple{Any}"><code>point_to_point</code></a>: Generate a minimum-time point-to-point trajectory with specified start and endpoints, not exceeding specified speed and acceleration limits.</li><li><a href="#Multibody.traj5-Tuple{Any}"><code>traj5</code></a>: Generate a 5:th order polynomial trajectory with specified start and end points. Additionally allows specification of start and end values for velocity and acceleration.</li></ul><p>Components that make use of these trajectory generators is provided:</p><ul><li><a href="#Multibody.KinematicPTP-Tuple{}"><code>KinematicPTP</code></a></li><li><a href="#Multibody.Kinematic5-Tuple{}"><code>Kinematic5</code></a></li></ul><p>These both have output connectors of type <code>RealOutput</code> called <code>q, qd, qdd</code> for positions, velocities and accelerations.</p><p>See <a href="examples/robot/#Industrial-robot">Industrial robot</a> for an example making use of the <a href="#Multibody.point_to_point-Tuple{Any}"><code>point_to_point</code></a> planner.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Kinematic5-Tuple{}" href="#Multibody.Kinematic5-Tuple{}"><code>Multibody.Kinematic5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kinematic5(; time, name, q0 = 0, q1 = 1, qd0 = 0, qd1 = 0, qdd0 = 0, qdd1 = 0)</code></pre><p>A component emitting a 5:th order polynomial trajectory created using <a href="#Multibody.traj5-Tuple{Any}"><code>traj5</code></a>. <code>traj5</code> is a simple trajectory planner that plans a 5:th order polynomial trajectory between two points, subject to specified boundary conditions on the position, velocity and acceleration.</p><p><strong>Arguments</strong></p><ul><li><code>time</code>: Time vector, e.g., <code>0:0.01:10</code></li><li><code>name</code>: Name of the component</li></ul><p><strong>Outputs</strong></p><ul><li><code>q</code>: Position</li><li><code>qd</code>: Velocity</li><li><code>qdd</code>: Acceleration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L200-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.KinematicPTP-Tuple{}" href="#Multibody.KinematicPTP-Tuple{}"><code>Multibody.KinematicPTP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KinematicPTP(; time, name, q0 = 0, q1 = 1, qd_max=1, qdd_max=1)</code></pre><p>A component emitting a trajectory created by the <a href="#Multibody.point_to_point-Tuple{Any}"><code>point_to_point</code></a> trajectory generator.</p><p><strong>Arguments</strong></p><ul><li><code>time</code>: Time vector, e.g., <code>0:0.01:10</code></li><li><code>name</code>: Name of the component</li><li><code>q0</code>: Initial position</li><li><code>q1</code>: Final position</li><li><code>qd_max</code>: Maximum velocity</li><li><code>qdd_max</code>: Maximum acceleration</li></ul><p><strong>Outputs</strong></p><ul><li><code>q</code>: Position</li><li><code>qd</code>: Velocity</li><li><code>qdd</code>: Acceleration</li></ul><p>See also <a href="#Multibody.Kinematic5-Tuple{}"><code>Kinematic5</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L156-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PathPlanning1-Tuple{}" href="#Multibody.PathPlanning1-Tuple{}"><code>Multibody.PathPlanning1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate reference angles for specified kinematic movement</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PathToAxisControlBus-Tuple{}" href="#Multibody.PathToAxisControlBus-Tuple{}"><code>Multibody.PathToAxisControlBus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Map path planning to one axis control bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RealPassThrough-Tuple{}" href="#Multibody.RealPassThrough-Tuple{}"><code>Multibody.RealPassThrough</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealPassThrough(; name)</code></pre><p>Pass a Real signal through without modification</p><p><strong>Connectors</strong></p><ul><li><code>input</code></li><li><code>output</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L239-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.traj5-Tuple{Any}" href="#Multibody.traj5-Tuple{Any}"><code>Multibody.traj5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q, qd, qdd = traj5(t; q0, q1, q̇0 = zero(q0), q̇1 = zero(q0), q̈0 = zero(q0), q̈1 = zero(q0))</code></pre><p>Generate a 5:th order polynomial trajectory with specified end points, vels and accs.</p><p>See also <a href="#Multibody.point_to_point-Tuple{Any}"><code>point_to_point</code></a> and <a href="#Multibody.Kinematic5-Tuple{}"><code>Kinematic5</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/path_planning.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.point_to_point-Tuple{Any}" href="#Multibody.point_to_point-Tuple{Any}"><code>Multibody.point_to_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q,qd,qdd,t_end = point_to_point(time; q0 = 0.0, q1 = 1.0, t0 = 0, qd_max = 1, qdd_max = 1)</code></pre><p>Generate a minimum-time point-to-point trajectory with specified start and endpoints, not exceeding specified speed and acceleration limits.</p><p>The trajectory produced by this function will typically exhibit piecewise constant accleration, piecewise linear velocity and piecewise quadratic position curves.</p><p>If a vector of <code>time</code> points is provided, the function returns matrices <code>q,qd,qdd</code> of size <code>(length(time), n_dims)</code>. If a scalar <code>time</code> point is provided, the function returns <code>q,qd,qdd</code> as vectors with the specified dimension (same dimension as <code>q0</code>). <code>t_end</code> is the time at which the trajectory will reach the specified end position.</p><p><strong>Arguments:</strong></p><ul><li><code>time</code>: A scalar or a vector of time points.</li><li><code>q0</code>: Initial coordinate, may be a scalar or a vector.</li><li><code>q1</code>: End coordinate</li><li><code>t0</code>: Tiem at which the motion starts. If <code>time</code> contains time points before <code>t0</code>, the trajectory will stand still at <code>q0</code> until <code>time</code> reaches <code>t0</code>.</li><li><code>qd_max</code>: Maximum allowed speed.</li><li><code>qdd_max</code>: Maximum allowed acceleration.</li></ul><p>See also <a href="#Multibody.KinematicPTP-Tuple{}"><code>KinematicPTP</code></a> and <a href="#Multibody.traj5-Tuple{Any}"><code>traj5</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/036c0dad7ae5efc27b7e5264c3e1a38338671218/src/robot/ptp.jl#L17-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/pendulum/">Getting started: Pendulum »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 18:05">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
