<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Multibody.jl</title><meta name="title" content="Home · Multibody.jl"/><meta property="og:title" content="Home · Multibody.jl"/><meta property="twitter:title" content="Home · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Notable-difference-from-Modelica"><span>Notable difference from Modelica</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Frames"><span>Frames</span></a></li><li><a class="tocitem" href="#Joints"><span>Joints</span></a></li><li><a class="tocitem" href="#Components"><span>Components</span></a></li><li><a class="tocitem" href="#Forces"><span>Forces</span></a></li><li><a class="tocitem" href="#Sensors"><span>Sensors</span></a></li><li><a class="tocitem" href="#Orientation-utilities"><span>Orientation utilities</span></a></li><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="examples/pendulum/">Getting started: Pendulum</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="examples/spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="examples/three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="examples/sensors/">Sensors</a></li><li><a class="tocitem" href="examples/spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="examples/gearbox/">Gearbox</a></li><li><a class="tocitem" href="examples/free_motion/">Free motions</a></li></ul></li><li><a class="tocitem" href="rendering/">3D rendering</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multibody"><a class="docs-heading-anchor" href="#Multibody">Multibody</a><a id="Multibody-1"></a><a class="docs-heading-anchor-permalink" href="#Multibody" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/YingboMa/Multibody.jl">Multibody</a>.</p><p>Welcome to the world of Multibody.jl, a powerful and flexible component of JuliaSim designed to model, analyze, and simulate multibody systems in Julia. As a state-of-the-art tool, Multibody.jl enables users to efficiently study the dynamics of complex mechanical systems in various fields, such as robotics, biomechanics, aerospace, and vehicle dynamics.</p><p>Built on top of the Julia language and the JuliaSim suite of tools for modeling, simulation, optimization and control, Multibody.jl harnesses the power of Julia&#39;s high-performance computing capabilities, making it a go-to choice for both researchers and engineers who require fast simulations and real-time performance. With an intuitive syntax and a comprehensive set of features, this package seamlessly integrates with other Julia and JuliaSim libraries, enabling users to tackle diverse and sophisticated problems in multibody dynamics.</p><p>In this documentation, you will find everything you need to get started with Multibody.jl, from basic component descriptions to detailed examples showcasing the package&#39;s capabilities. As you explore this documentation, you&#39;ll learn how to create complex models, work with forces and torques, simulate various types of motions, and visualize your results in both 2D and 3D. Whether you are a seasoned researcher or a newcomer to the field, Multibody.jl will empower you to bring your ideas to life and unlock new possibilities in the fascinating world of multibody dynamics.</p><h2 id="Notable-difference-from-Modelica"><a class="docs-heading-anchor" href="#Notable-difference-from-Modelica">Notable difference from Modelica</a><a id="Notable-difference-from-Modelica-1"></a><a class="docs-heading-anchor-permalink" href="#Notable-difference-from-Modelica" title="Permalink"></a></h2><ul><li>The torque variable in Multibody.jl is typically called <code>tau</code> rather than <code>t</code> to not conflict with the often used independent variable <code>t</code> used to denote time.</li><li>Multibody.jl occasionally requires the user to specify which component should act as the root of the kinematic tree. This only occurs when bodies are connected directly to force components without a joint parallel to the force component.</li><li>In Multibody.jl, the orientation object of a <a href="#Multibody.Frame"><code>Frame</code></a> is accessed using he function <a href="#Multibody.ori"><code>ori</code></a>.</li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Multibody.world"><code>Multibody.world</code></a></li><li><a href="#Multibody.RotationMatrix"><code>Multibody.RotationMatrix</code></a></li><li><a href="#Multibody.BasicTorque-Tuple{}"><code>Multibody.BasicTorque</code></a></li><li><a href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a></li><li><a href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a></li><li><a href="#Multibody.CutForce-Tuple{}"><code>Multibody.CutForce</code></a></li><li><a href="#Multibody.CutTorque-Tuple{}"><code>Multibody.CutTorque</code></a></li><li><a href="#Multibody.Damper-Tuple{}"><code>Multibody.Damper</code></a></li><li><a href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a></li><li><a href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a></li><li><a href="#Multibody.Force-Tuple{}"><code>Multibody.Force</code></a></li><li><a href="#Multibody.Frame"><code>Multibody.Frame</code></a></li><li><a href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a></li><li><a href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a></li><li><a href="#Multibody.NumRotationMatrix-Tuple{}"><code>Multibody.NumRotationMatrix</code></a></li><li><a href="#Multibody.PartialCutForceBaseSensor-Tuple{}"><code>Multibody.PartialCutForceBaseSensor</code></a></li><li><a href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a></li><li><a href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a></li><li><a href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a></li><li><a href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a></li><li><a href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a></li><li><a href="#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a></li><li><a href="#Multibody.SpringDamperParallel-Tuple{}"><code>Multibody.SpringDamperParallel</code></a></li><li><a href="#Multibody.Torque-Tuple{}"><code>Multibody.Torque</code></a></li><li><a href="#Multibody.absoluteRotation-Tuple{Any, Any}"><code>Multibody.absoluteRotation</code></a></li><li><a href="#Multibody.axisRotation-Tuple{Any, Any}"><code>Multibody.axisRotation</code></a></li><li><a href="#Multibody.get_w-Tuple{AbstractMatrix}"><code>Multibody.get_w</code></a></li><li><a href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a></li><li><a href="#Multibody.ori"><code>Multibody.ori</code></a></li><li><a href="rendering/#Multibody.render"><code>Multibody.render</code></a></li><li><a href="rendering/#Multibody.render!"><code>Multibody.render!</code></a></li><li><a href="#Multibody.resolve1-Tuple{RotationMatrix, Any}"><code>Multibody.resolve1</code></a></li><li><a href="#Multibody.resolve2-Tuple{RotationMatrix, Any}"><code>Multibody.resolve2</code></a></li><li><a href="#Multibody.rotx"><code>Multibody.rotx</code></a></li><li><a href="#Multibody.roty"><code>Multibody.roty</code></a></li><li><a href="#Multibody.rotz"><code>Multibody.rotz</code></a></li></ul><h2 id="Frames"><a class="docs-heading-anchor" href="#Frames">Frames</a><a id="Frames-1"></a><a class="docs-heading-anchor-permalink" href="#Frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Frame" href="#Multibody.Frame"><code>Multibody.Frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Frame(; name)</code></pre><p><code>Frame</code> is the fundamental 3D connector in the multibody library. Most components have one or several <code>Frame</code> connectors that can be connected together.</p><p>The <code>Frame</code> connector has internal variables for</p><ul><li><code>r_0</code>: The position vector from the world frame to the frame origin, resolved in the world frame</li><li><code>f</code>: The cut force resolved in the connector frame</li><li><code>tau</code>: The cut torque resolved in the connector frame</li><li>Depending on usage, also rotation and rotational velocity variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/frames.jl#L22-L32">source</a></section></article><h2 id="Joints"><a class="docs-heading-anchor" href="#Joints">Joints</a><a id="Joints-1"></a><a class="docs-heading-anchor-permalink" href="#Joints" title="Permalink"></a></h2><p>A joint restricts the number of degrees of freedom (DOF) of a body. For example, a free floating body has 6 DOF, but if it is attached to a <a href="#Multibody.Revolute-Tuple{}"><code>Revolute</code></a> joint, the joint restricts all but one rotational degree of freedom (a revolute joint acts like a hinge). Similarily, a <a href="#Multibody.Prismatic-Tuple{}"><code>Prismatic</code></a> joint restricts all but one translational degree of freedom (a prismatic joint acts like a slider).</p><p>A <a href="#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> joints restricts all translational degrees of freedom, but allows all rotational degrees of freedom. It thus transmits no torque.</p><p>Some joints offer the option to add 1-dimensional components to them by providing the keyword <code>useAxisFlange = true</code>. This allows us to add, e.g., springs, dampers, sensors, and actuators to the joint.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FreeMotion-Tuple{}" href="#Multibody.FreeMotion-Tuple{}"><code>Multibody.FreeMotion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FreeMotion(; name, enforceState = true, sequence, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, phi = 0, phi_d = 0, phi_dd = 0, w_rel_b = 0, r_rel_a = 0, v_rel_a = 0, a_rel_a = 0)</code></pre><p>Joint which <em>does not</em> constrain the motion between <code>frame_a</code> and <code>frame_b</code>. Such a joint is only meaningful if the relative distance and orientation between <code>frame_a</code> and <code>frame_b</code>, and their derivatives, shall be used as state.</p><p>Note, that bodies such as <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>, have potential state variables describing the distance and orientation, and their derivatives, between the world frame and a body fixed frame. Therefore, if these potential state variables are suited, a <code>FreeMotion</code> joint is not needed.</p><p>The state of the FreeMotion object consits of:</p><p>The relative position vector <code>r_rel_a</code> from the origin of <code>frame_a</code> to the origin of <code>frame_b</code>, resolved in <code>frame_a</code> and the relative velocity <code>v_rel_a</code> of the origin of <code>frame_b</code> with respect to the origin of <code>frame_a</code>, resolved in <code>frame_a (= der(r_rel_a))</code>.</p><p><strong>Arguments</strong></p><ul><li><code>enforceState</code>: Enforce this joint having state, this is often desired and is the default choice.</li><li><code>sequence</code>: Rotation sequence</li><li><code>w_rel_a_fixed</code>: = true, if <code>w_rel_a_start</code> are used as initial values, else as guess values</li><li><code>z_rel_a_fixed</code>: = true, if <code>z_rel_a_start</code> are used as initial values, else as guess values</li></ul><p><strong>Initial condition arguments:</strong></p><ul><li><code>phi</code></li><li><code>phi_d</code></li><li><code>phi_dd</code></li><li><code>w_rel_b</code></li><li><code>r_rel_a</code></li><li><code>v_rel_a</code></li><li><code>a_rel_a</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L609-L635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.GearConstraint-Tuple{}" href="#Multibody.GearConstraint-Tuple{}"><code>Multibody.GearConstraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GearConstraint(; name, ratio, checkTotalPower = false, n_a, n_b, r_a, r_b)</code></pre><p>This ideal massless joint provides a gear constraint between frames <code>frame_a</code> and <code>frame_b</code>. The axes of rotation of <code>frame_a</code> and <code>frame_b</code> may be arbitrary.</p><ul><li><code>ratio</code>: Gear ratio</li><li><code>n_a</code>: Axis of rotation of <code>frame_a</code></li><li><code>n_b</code>: Axis of rotation of <code>frame_b</code></li><li><code>r_a</code>: Vector from frame <code>bearing</code> to <code>frame_a</code> resolved in bearing</li><li><code>r_b</code>: Vector from frame <code>bearing</code> to <code>frame_b</code> resolved in bearing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Prismatic-Tuple{}" href="#Multibody.Prismatic-Tuple{}"><code>Multibody.Prismatic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Prismatic(; name, n = [0, 0, 1], useAxisFlange = false, isroot = true)</code></pre><p>Prismatic joint with 1 translational degree-of-freedom</p><ul><li><code>n</code>: The axis of motion (unit vector)</li><li><code>useAxisFlange</code>: If true, the joint will have two additional frames from Mechanical.Translational, <code>axis</code> and <code>support</code>, between which translational components such as springs and dampers can be connected.</li><li><code>isroot</code>: If true, the joint will be considered the root of the system.</li></ul><p>If <code>useAxisFlange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.TranslationalModelica are also available:</p><ul><li><code>axis</code>: 1-dim. translational flange that drives the joint</li><li><code>support</code>: 1-dim. translational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul><p>The function returns an ODESystem representing the prismatic joint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Revolute-Tuple{}" href="#Multibody.Revolute-Tuple{}"><code>Multibody.Revolute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Revolute(; name, phi0 = 0, w0 = 0, n, useAxisFlange = false)</code></pre><p>Revolute joint with 1 rotational degree-of-freedom</p><ul><li><code>phi0</code>: Initial angle</li><li><code>w0</code>: Iniitial angular velocity</li><li><code>n</code>: The axis of rotation</li><li><code>useAxisFlange</code>: If true, the joint will have two additional frames from Mechanical.Rotational, <code>axis</code> and <code>support</code>, between which rotational components such as springs and dampers can be connected.</li></ul><p>If <code>useAxisFlange</code>, flange connectors for ModelicaStandardLibrary.Mechanics.Rotational are also available:</p><ul><li><code>axis</code>: 1-dim. rotational flange that drives the joint</li><li><code>support</code>: 1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheel-Tuple{}" href="#Multibody.RollingWheel-Tuple{}"><code>Multibody.RollingWheel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RollingWheel(; name, radius, m, I_axis, I_long, width=0.035, x0, y0, kwargs...)</code></pre><p>Ideal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)</p><p>A wheel rolling on the x-y plane of the world frame including wheel mass. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. The wheel can not take off but it can incline toward the ground. The frame frame_a is placed in the wheel center point and rotates with the wheel itself.</p><p><strong>Arguments and parameters:</strong></p><ul><li><code>name</code>: Name of the rolling wheel component</li><li><code>radius</code>: Radius of the wheel</li><li><code>m</code>: Mass of the wheel</li><li><code>I_axis</code>: Moment of inertia of the wheel along its axis</li><li><code>I_long</code>: Moment of inertia of the wheel perpendicular to its axis</li><li><code>width</code>: Width of the wheel (default: 0.035)</li><li><code>x0</code>: Initial x-position of the wheel axis</li><li><code>y0</code>: Initial y-position of the wheel axis</li><li><code>kwargs...</code>: Additional keyword arguments passed to the <code>RollingWheelJoint</code> function</li></ul><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>y</code>: y-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around z-, y-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li></ul><p><strong>Named components:</strong></p><ul><li><code>frame_a</code>: Frame for the wheel component</li><li><code>rollingWheel</code>: Rolling wheel joint representing the wheel&#39;s contact with the road surface</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L536-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RollingWheelJoint-Tuple{}" href="#Multibody.RollingWheelJoint-Tuple{}"><code>Multibody.RollingWheelJoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RollingWheelJoint(; name, radius, angles, x0, y0, z0)</code></pre><p>Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0). See <a href="#Multibody.RollingWheel-Tuple{}"><code>RollingWheel</code></a> for a realistic wheel model with inertia.</p><p>A joint for a wheel rolling on the x-y plane of the world frame. The rolling contact is considered being ideal, i.e. there is no slip between the wheel and the ground. This is simply gained by two non-holonomic constraint equations on velocity level defined for both longitudinal and lateral direction of the wheel. There is also a holonomic constraint equation on position level granting a permanent contact of the wheel to the ground, i.e. the wheel can not take off.</p><p>The origin of the frame <code>frame_a</code> is placed in the intersection of the wheel spin axis with the wheel middle plane and rotates with the wheel itself. The y-axis of <code>frame_a</code> is identical with the wheel spin axis, i.e. the wheel rotates about y-axis of <code>frame_a</code>. A wheel body collecting the mass and inertia should be connected to this frame.</p><p><strong>Arguments and parameters:</strong></p><p>name: Name of the rolling wheel joint component radius: Radius of the wheel angles: Angles to rotate world-frame into frame_a around z-, y-, x-axis</p><p><strong>Variables:</strong></p><ul><li><code>x</code>: x-position of the wheel axis</li><li><code>y</code>: y-position of the wheel axis</li><li><code>z</code>: z-position of the wheel axis</li><li><code>angles</code>: Angles to rotate world-frame into <code>frame_a</code> around z-, y-, x-axis</li><li><code>der_angles</code>: Derivatives of angles</li><li><code>r_road_0</code>: Position vector from world frame to contact point on road, resolved in world frame</li><li><code>f_wheel_0</code>: Force vector on wheel, resolved in world frame</li><li><code>f_n</code>: Contact force acting on wheel in normal direction</li><li><code>f_lat</code>: Contact force acting on wheel in lateral direction</li><li><code>f_long</code>: Contact force acting on wheel in longitudinal direction</li><li><code>err</code>: Absolute value of <code>(r_road_0 - frame_a.r_0) - radius</code> (must be zero; used for checking)</li><li><code>e_axis_0</code>: Unit vector along wheel axis, resolved in world frame</li><li><code>delta_0</code>: Distance vector from wheel center to contact point</li><li><code>e_n_0</code>: Unit vector in normal direction of road at contact point, resolved in world frame</li><li><code>e_lat_0</code>: Unit vector in lateral direction of road at contact point, resolved in world frame</li><li><code>e_long_0</code>: Unit vector in longitudinal direction of road at contact point, resolved in world frame</li><li><code>s</code>: Road surface parameter 1</li><li><code>w</code>: Road surface parameter 2</li><li><code>e_s_0</code>: Road heading at <code>(s,w)</code>, resolved in world frame (unit vector)</li><li><code>v_0</code>: Velocity of wheel center, resolved in world frame</li><li><code>w_0</code>: Angular velocity of wheel, resolved in world frame</li><li><code>vContact_0</code>: Velocity of contact point, resolved in world frame</li></ul><p><strong>Connector frames</strong></p><ul><li><code>frame_a</code>: Frame for the wheel joint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L377-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Spherical-Tuple{}" href="#Multibody.Spherical-Tuple{}"><code>Multibody.Spherical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Spherical(; name, enforceState = false, isroot = true, w_rel_a_fixed = false, z_rel_a_fixed = false, sequence_angleStates, phi = 0, phi_d = 0, phi_dd = 0)</code></pre><p>Joint with 3 constraints that define that the origin of <code>frame_a</code> and the origin of <code>frame_b</code> coincide. By default this joint defines only the 3 constraints without any potential state variables. If parameter <code>enforceState</code> is set to true, three states are introduced. The orientation of <code>frame_b</code> is computed by rotating <code>frame_a</code> along the axes defined in parameter vector <code>sequence_angleStates</code> (default = [1,2,3], i.e., the Cardan angle sequence) around the angles used as state. If angles are used as state there is the slight disadvantage that a singular configuration is present leading to a division by zero.</p><ul><li><code>isroot</code>: Indicate that <code>frame_a</code> is the root, otherwise <code>frame_b</code> is the root. Only relevant if <code>enforceState = true</code>.</li><li><code>sequence_angleStates</code>: Rotation sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/joints.jl#L141-L148">source</a></section></article><h2 id="Components"><a class="docs-heading-anchor" href="#Components">Components</a><a id="Components-1"></a><a class="docs-heading-anchor-permalink" href="#Components" title="Permalink"></a></h2><p>The perhaps most fundamental component is a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, this component has a single flange, <code>frame_a</code>, which is used to connect the body to other components. This component has a mass, a vector <code>r_cm</code> from <code>frame_a</code> to the center of mass, and a moment of inertia tensor <code>I</code> in the center of mass. The body can be thought of as a point mass with a moment of inertia tensor.</p><p>A mass with a shape can be modeled using a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a>. The primary difference between a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a> and a <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is that the latter has an additional flange, <code>frame_b</code>, which is used to connect the body to other components. The translation between <code>flange_a</code> and <code>flange_b</code> is determined by the vector <code>r</code>. The <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> is suitable to model, e.g., cylinders, rods, and boxes.</p><p>A rod without a mass (just a translation), is modeled using <a href="#Multibody.FixedTranslation-Tuple{}"><code>FixedTranslation</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.world" href="#Multibody.world"><code>Multibody.world</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>The world component is the root of all multibody models. It is a fixed frame with a parallel gravitational field and a gravity vector specified by the unit direction <code>world.n</code> (defaults to [0, -1, 0]) and magnitude <code>world.g</code> (defaults to 9.81).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Body-Tuple{}" href="#Multibody.Body-Tuple{}"><code>Multibody.Body</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Body(; name, m = 1, r_cm, I = collect(0.001 * LinearAlgebra.I(3)), isroot = false, phi0 = zeros(3), phid0 = zeros(3), r_0=zeros(3))</code></pre><p>Representing a body with 3 translational and 3 rotational degrees-of-freedom.</p><ul><li><code>m</code>: Mass</li><li><code>r_cm</code>: Vector from <code>frame_a</code> to center of mass, resolved in <code>frame_a</code></li><li><code>I</code>: Inertia matrix of the body</li><li><code>isroot</code>: Indicate whether this component is the root of the system, useful when there are no joints in the model.</li><li><code>phi0</code>: Initial orientation, only applicable if <code>isroot = true</code></li><li><code>phid0</code>: Initial angular velocity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L174-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BodyShape-Tuple{}" href="#Multibody.BodyShape-Tuple{}"><code>Multibody.BodyShape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BodyShape(; name, m = 1, r, kwargs...)</code></pre><p>The <code>BodyShape</code> component is similar to a <a href="#Multibody.Body-Tuple{}"><code>Body</code></a>, but it has two frames and a vector <code>r</code> that describes the translation between them, while the body has a single frame only.</p><ul><li><code>r</code>: Vector from <code>frame_a</code> to <code>frame_b</code> resolved in <code>frame_a</code></li><li>All <code>kwargs</code> are passed to the internal <code>Body</code> component.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L276-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedRotation-Tuple{}" href="#Multibody.FixedRotation-Tuple{}"><code>Multibody.FixedRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FixedRotation(; name, r, n, sequence, isroot = false, angle, n_x, n_y)</code></pre><p>Fixed translation followed by a fixed rotation of <code>frame_b</code> with respect to <code>frame_a</code></p><ul><li><code>r</code>: Translation vector</li><li><code>n</code>: Axis of rotation, resolved in frame_a</li><li><code>sequence</code>: DESCRIPTION</li><li><code>angle</code>: Angle of rotation around <code>n</code>, given in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L117-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.FixedTranslation-Tuple{}" href="#Multibody.FixedTranslation-Tuple{}"><code>Multibody.FixedTranslation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FixedTranslation(; name, r)</code></pre><p>Fixed translation of <code>frame_b</code> with respect to <code>frame_a</code> with position vector <code>r</code> resolved in <code>frame_a</code>.</p><p>Can be though of as a massless rod. For a massive rod, see <a href="#Multibody.BodyShape-Tuple{}"><code>BodyShape</code></a> or <a href="@ref"><code>BodyCylinder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.gravity_acceleration-Tuple{Any}" href="#Multibody.gravity_acceleration-Tuple{Any}"><code>Multibody.gravity_acceleration</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the gravity acceleration, resolved in world frame</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.ori" href="#Multibody.ori"><code>Multibody.ori</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ori(frame, varw = false)</code></pre><p>Get the orientation of <code>sys</code> as a <code>RotationMatrix</code> object.</p><p>For frames, the orientation is stored in the metadata field of the system as <code>sys.metadata[:orientation]</code>.</p><p>If <code>varw = true</code>, the angular velocity variables <code>w</code> of the frame is also included in the <code>RotationMatrix</code> object, otherwise <code>w</code> is derived as the time derivative of <code>R</code>. <code>varw = true</code> is primarily used when selecting a component as root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/components.jl#L8-L16">source</a></section></article><h2 id="Forces"><a class="docs-heading-anchor" href="#Forces">Forces</a><a id="Forces-1"></a><a class="docs-heading-anchor-permalink" href="#Forces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.BasicTorque-Tuple{}" href="#Multibody.BasicTorque-Tuple{}"><code>Multibody.BasicTorque</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BasicTorque(; name, resolveInFrame = :world)</code></pre><p>Low-level torque component used to build <a href="#Multibody.Torque-Tuple{}"><code>Torque</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Damper-Tuple{}" href="#Multibody.Damper-Tuple{}"><code>Multibody.Damper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Damper(; d, name, kwargs)</code></pre><p>Linear damper acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = d D(s)\]</p><p>where <code>d</code> is the (viscous) damping parameter, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> and <code>D(s)</code> is the time derivative of <code>s</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: Damping coefficient</li></ul><p>See also <a href="#Multibody.SpringDamperParallel-Tuple{}"><code>SpringDamperParallel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L346-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Force-Tuple{}" href="#Multibody.Force-Tuple{}"><code>Multibody.Force</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Force(; name, resolveInFrame = :frame_b)</code></pre><p>Force acting between two frames, defined by 3 input signals and resolved in frame <code>world</code>, <code>frame_a</code>, <code>frame_b</code> (default)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li><li><code>force</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of force resolved in frame defined by <code>resolveInFrame</code>.</li></ul><p><strong>Keyword arguments:</strong></p><ul><li><code>resolveInFrame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_b</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L115-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Spring-Tuple{}" href="#Multibody.Spring-Tuple{}"><code>Multibody.Spring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Spring(; c, name, m = 0, lengthFraction = 0.5, s_unstretched = 0, kwargs)</code></pre><p>Linear spring acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = c s\]</p><p>where <code>c</code> is the spring stiffness parameter, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code>.</p><p>Optionally, the mass of the spring is taken into account by a point mass located on the line between <code>frame_a</code> and <code>frame_b</code> (default: middle of the line). If the spring mass is zero, the additional equations to handle the mass are removed.</p><p><strong>Arguments:</strong></p><ul><li><code>c</code>: Spring stiffness</li><li><code>m</code>: Mass of the spring (can be zero)</li><li><code>lengthFraction</code>: Location of spring mass with respect to <code>frame_a</code> as a fraction of the distance from <code>frame_a</code> to <code>frame_b</code> (=0: at <code>frame_a</code>; =1: at <code>frame_b</code>)</li><li><code>s_unstretched</code>: Length of the spring when it is unstretched</li><li><code>kwargs</code>: are passed to <code>LineForceWithMass</code></li></ul><p>See also <a href="#Multibody.SpringDamperParallel-Tuple{}"><code>SpringDamperParallel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L266-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.SpringDamperParallel-Tuple{}" href="#Multibody.SpringDamperParallel-Tuple{}"><code>Multibody.SpringDamperParallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SpringDamperParallel(; name, c, d, s_unstretched)</code></pre><p>Linear spring and linear damper in parallel acting as line force between <code>frame_a</code> and <code>frame_b</code>. A force <code>f</code> is exerted on the origin of <code>frame_b</code> and with opposite sign on the origin of <code>frame_a</code> along the line from the origin of <code>frame_a</code> to the origin of <code>frame_b</code> according to the equation:</p><p class="math-container">\[f = c (s - s_{unstretched}) + d \cdot D(s)\]</p><p>where <code>c</code>, <code>s_unstretched</code> and <code>d</code> are parameters, <code>s</code> is the distance between the origin of <code>frame_a</code> and the origin of <code>frame_b</code> and <code>D(s)</code> is the time derivative of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L375-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.Torque-Tuple{}" href="#Multibody.Torque-Tuple{}"><code>Multibody.Torque</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Torque(; name, resolveInFrame = :frame_b)</code></pre><p>Torque acting between two frames, defined by 3 input signals and resolved in frame <code>world</code>, <code>frame_a</code>, <code>frame_b</code> (default)</p><p><strong>Connectors:</strong></p><ul><li><code>frame_a</code></li><li><code>frame_b</code></li><li><code>torque</code>: Of type <code>Blocks.RealInput(3)</code>. x-, y-, z-coordinates of torque resolved in frame defined by <code>resolveInFrame</code>.</li></ul><p><strong>Keyword arguments:</strong></p><ul><li><code>resolveInFrame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_b</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/forces.jl#L51-L63">source</a></section></article><h2 id="Sensors"><a class="docs-heading-anchor" href="#Sensors">Sensors</a><a id="Sensors-1"></a><a class="docs-heading-anchor-permalink" href="#Sensors" title="Permalink"></a></h2><p>A sensor is an object that translates quantities in the mechanical domain into causal signals which can interact with causal components from <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/">ModelingToolkitStandardLibrary.Blocks</a>, such as control systems etc.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.CutForce-Tuple{}" href="#Multibody.CutForce-Tuple{}"><code>Multibody.CutForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BasicCutForce(; name, resolveInFrame)</code></pre><p>Basic sensor to measure cut force vector. Contains a connector of type <code>Blocks.RealOutput</code> with name <code>force</code>.</p><ul><li><code>resolveInFrame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/sensors.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.CutTorque-Tuple{}" href="#Multibody.CutTorque-Tuple{}"><code>Multibody.CutTorque</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CutTorque(; name, resolveInFrame)</code></pre><p>Basic sensor to measure cut torque vector. Contains a connector of type <code>Blocks.RealOutput</code> with name <code>torque</code>.</p><ul><li><code>resolveInFrame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/sensors.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.PartialCutForceBaseSensor-Tuple{}" href="#Multibody.PartialCutForceBaseSensor-Tuple{}"><code>Multibody.PartialCutForceBaseSensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PartialCutForceBaseSensor(; name, resolveInFrame = :frame_a)</code></pre><ul><li><code>resolveInFrame</code>: The frame in which the cut force and cut torque are resolved. Default is <code>:frame_a</code>, options include <code>:frame_a</code> and <code>:world</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/sensors.jl#L25-L29">source</a></section></article><h2 id="Orientation-utilities"><a class="docs-heading-anchor" href="#Orientation-utilities">Orientation utilities</a><a id="Orientation-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Orientation-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RotationMatrix" href="#Multibody.RotationMatrix"><code>Multibody.RotationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RotationMatrix</code></pre><p>A struct representing a 3D orientation as a rotation matrix.</p><p>If <code>ODESystem</code> is called on a <code>RotationMatrix</code> object <code>o</code>, symbolic variables for <code>o.R</code> and <code>o.w</code> are created and the value of <code>o.R</code> is used as the default value for the symbolic <code>R</code>.</p><p><strong>Fields:</strong></p><ul><li><code>R::R3</code>: The rotation 3×3 matrix ∈ SO(3)</li><li><code>w</code>: The angular velocity vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.NumRotationMatrix-Tuple{}" href="#Multibody.NumRotationMatrix-Tuple{}"><code>Multibody.NumRotationMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NumRotationMatrix(; R = collect(1.0 * I(3)), w = zeros(3), name, varw = false)</code></pre><p>Create a new <a href="#Multibody.RotationMatrix"><code>RotationMatrix</code></a> struct with symbolic elements. <code>R,w</code> determine default values.</p><p>The primary difference between <code>NumRotationMatrix</code> and <code>RotationMatrix</code> is that the <code>NumRotationMatrix</code> constructor is used in the constructor of a <a href="#Multibody.Frame"><code>Frame</code></a> in order to introduce the frame variables, whereas <code>RorationMatrix</code> (the struct) only wraps existing variables.</p><ul><li><code>varw</code>: If true, <code>w</code> is a variable, otherwise it is derived from the derivative of <code>R</code> as <code>w = get_w(R)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.absoluteRotation-Tuple{Any, Any}" href="#Multibody.absoluteRotation-Tuple{Any, Any}"><code>Multibody.absoluteRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R2 = absoluteRotation(R1, R_rel)</code></pre><ul><li><code>R1</code>: <code>Orientation</code> object to rotate frame 0 into frame 1</li><li><code>R_rel</code>: <code>Orientation</code> object to rotate frame 1 into frame 2</li><li><code>R2</code>: <code>Orientation</code> object to rotate frame 0 into frame 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.axisRotation-Tuple{Any, Any}" href="#Multibody.axisRotation-Tuple{Any, Any}"><code>Multibody.axisRotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axisRotation(sequence, angle; name = :R)</code></pre><p>Generate a rotation matrix for a rotation around the specified axis.</p><ul><li><code>sequence</code>: The axis to rotate around (1: x-axis, 2: y-axis, 3: z-axis)</li><li><code>angle</code>: The angle of rotation (in radians)</li></ul><p>Returns a <code>RotationMatrix</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_w-Tuple{AbstractMatrix}" href="#Multibody.get_w-Tuple{AbstractMatrix}"><code>Multibody.get_w</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_w(R)</code></pre><p>Compute the angular velocity <code>w</code> from the rotation matrix <code>R</code> and its derivative <code>DR = D.(R)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve1-Tuple{RotationMatrix, Any}" href="#Multibody.resolve1-Tuple{RotationMatrix, Any}"><code>Multibody.resolve1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h1 = resolve1(R21, h2)</code></pre><p><code>R12</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h2</code> is a vector resolved in frame 2. <code>h1</code> is the same vector in frame 1.</p><p>Typical usage:</p><pre><code class="language-julia hljs">resolve1(ori(frame_a), r_ab)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L108-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve2-Tuple{RotationMatrix, Any}" href="#Multibody.resolve2-Tuple{RotationMatrix, Any}"><code>Multibody.resolve2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2 = resolve2(R21, h1)</code></pre><p><code>R21</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h1</code> is a vector resolved in frame 1. <code>h2</code> is the same vector in frame 2.</p><p>Typical usage:</p><pre><code class="language-julia hljs">resolve2(ori(frame_a), a_0 - g_0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L95-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.rotx" href="#Multibody.rotx"><code>Multibody.rotx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotx(t, deg = false)</code></pre><p>Generate a rotation matrix for a rotation around the x-axis.</p><ul><li><code>t</code>: The angle of rotation (in radians, unless <code>deg</code> is set to true)</li><li><code>deg</code>: (Optional) If true, the angle is in degrees</li></ul><p>Returns a 3x3 rotation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L261-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.roty" href="#Multibody.roty"><code>Multibody.roty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roty(t, deg = false)</code></pre><p>Generate a rotation matrix for a rotation around the y-axis.</p><ul><li><code>t</code>: The angle of rotation (in radians, unless <code>deg</code> is set to true)</li><li><code>deg</code>: (Optional) If true, the angle is in degrees</li></ul><p>Returns a 3x3 rotation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L282-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.rotz" href="#Multibody.rotz"><code>Multibody.rotz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotz(t, deg = false)</code></pre><p>Generate a rotation matrix for a rotation around the z-axis.</p><ul><li><code>t</code>: The angle of rotation (in radians, unless <code>deg</code> is set to true)</li><li><code>deg</code>: (Optional) If true, the angle is in degrees</li></ul><p>Returns a 3x3 rotation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/93c830ccc64ec3f9d15f9cb364dc9f885f9a3373/src/orientation.jl#L303-L312">source</a></section></article><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/pendulum/">Getting started: Pendulum »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 30 October 2023 05:37">Monday 30 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
