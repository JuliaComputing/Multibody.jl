<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotations and orientation · Multibody.jl</title><meta name="title" content="Rotations and orientation · Multibody.jl"/><meta property="og:title" content="Rotations and orientation · Multibody.jl"/><meta property="twitter:title" content="Rotations and orientation · Multibody.jl"/><meta name="description" content="Documentation for Multibody.jl."/><meta property="og:description" content="Documentation for Multibody.jl."/><meta property="twitter:description" content="Documentation for Multibody.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Multibody.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/pendulum/">Getting started: Pendulum</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/spring_damper_system/">Spring-damper system</a></li><li><a class="tocitem" href="../examples/spring_mass_system/">Spring-mass system</a></li><li><a class="tocitem" href="../examples/three_springs/">Three springs (series forces)</a></li><li><a class="tocitem" href="../examples/sensors/">Sensors</a></li><li><a class="tocitem" href="../examples/spherical_pendulum/">Spherical pendulum</a></li><li><a class="tocitem" href="../examples/gearbox/">Gearbox</a></li><li><a class="tocitem" href="../examples/free_motion/">Free motions</a></li><li><a class="tocitem" href="../examples/prescribed_pose/">Prescribed motions</a></li><li><a class="tocitem" href="../examples/kinematic_loops/">Kinematic loops</a></li><li><a class="tocitem" href="../examples/robot/">Industrial robot</a></li><li><a class="tocitem" href="../examples/ropes_and_cables/">Ropes, cables and chains</a></li><li><a class="tocitem" href="../examples/swing/">Swing</a></li><li><a class="tocitem" href="../examples/space/">Bodies in space</a></li><li><a class="tocitem" href="../examples/gyroscopic_effects/">Gyroscopic effects</a></li><li><a class="tocitem" href="../examples/wheel/">Wheels</a></li><li><a class="tocitem" href="../examples/suspension/">Suspension systems</a></li><li><a class="tocitem" href="../examples/quad/">Quadrotor with cable-suspended load</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../frames/">Frames</a></li><li><a class="tocitem" href="../joints/">Joints</a></li><li><a class="tocitem" href="../components/">Components</a></li><li><a class="tocitem" href="../forces/">Forces</a></li><li><a class="tocitem" href="../sensors/">Sensors</a></li><li><a class="tocitem" href="../trajectory_planning/">Trajectory planning</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li></ul></li><li class="is-active"><a class="tocitem" href>Rotations and orientation</a><ul class="internal"><li><a class="tocitem" href="#Euler-angles"><span>Euler angles</span></a></li><li><a class="tocitem" href="#Quaternions"><span>Quaternions</span></a></li><li><a class="tocitem" href="#Rotation-matrices"><span>Rotation matrices</span></a></li><li><a class="tocitem" href="#Conversion-between-orientation-formats"><span>Conversion between orientation formats</span></a></li><li><a class="tocitem" href="#Conventions-for-modeling"><span>Conventions for modeling</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../rendering/">3D rendering</a></li><li><a class="tocitem" href="../urdf/">URDF import</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Rotations and orientation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rotations and orientation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/Multibody.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-orientation-and-rotation"><a class="docs-heading-anchor" href="#Working-with-orientation-and-rotation">Working with orientation and rotation</a><a id="Working-with-orientation-and-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-orientation-and-rotation" title="Permalink"></a></h1><p>Orientations and rotations in 3D can be represented in multiple different ways. Components which (may) have a 3D angular state, such as <a href="../components/#Multibody.Body-Tuple{}"><code>Body</code></a>, <a href="../joints/#Multibody.Spherical-Tuple{}"><code>Spherical</code></a> and <a href="../joints/#Multibody.FreeMotion-Tuple{}"><code>FreeMotion</code></a>, offer the user to select the orientation representation, either Euler angles or quaternions.</p><h2 id="Euler-angles"><a class="docs-heading-anchor" href="#Euler-angles">Euler angles</a><a id="Euler-angles-1"></a><a class="docs-heading-anchor-permalink" href="#Euler-angles" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</a> represent orientation using rotations around three axes, and thus uses three numbers to represent the orientation. The benefit of this representation is that it is minimal (only three numbers used), but the drawback is that any 3-number orientation representation suffers from a kinematic singularity. This representation is beneficial when you know that the singularity will not come into play in your simulation.</p><p>Most components that may use Euler angles also allow you to select the sequence of axis around which to perform the rotations, e.g., <code>sequence = [1,2,3]</code> performs rotations around <span>$x$</span> first, then <span>$y$</span> and <span>$z$</span>.</p><h2 id="Quaternions"><a class="docs-heading-anchor" href="#Quaternions">Quaternions</a><a id="Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions" title="Permalink"></a></h2><p>A <a href="https://en.wikipedia.org/wiki/Quaternion">quaternion</a> represents an orientation using 4 numbers. This is a non-minimal representation, but in return it is also singularity free. Multibody.jl uses <em>non-unit quaternions</em><sup class="footnote-reference"><a id="citeref-quat" href="#footnote-quat">[quat]</a></sup> to represent orientation when <code>quat = true</code> is provided to components that support this option. The convention used for quaternions is <span>$[s, v_1, v_2, v_3]$</span>, sometimes also referred to as <span>$[w, i, j, k]$</span>, i.e., the real/scalar part comes first, followed by the three imaginary numbers. When quaternions are used, state variables <code>Q̂</code> denote non-unit quaternions, while normalized unit quaternions are available as observable variables <code>Q</code>. The use of non-unit quaternions allows Multibody to integrate rotations without using dynamic state selection or introducing algebraic equations. </p><p>Multibody.jl depends on <a href="https://github.com/JuliaGeometry/Rotations.jl">Rotations.jl</a> which in turn uses <a href="https://github.com/JuliaGeometry/Quaternions.jl">Quaternions.jl</a> for quaternion computations. If you manually create quaternions using these packages, you may convert them to a vector to provide, e.g., initial conditions, using <code>Rotations.params(Q)</code> (see <a href="#Conversion-between-orientation-formats">Conversion between orientation formats</a> below).</p><h3 id="Examples-using-quaternions"><a class="docs-heading-anchor" href="#Examples-using-quaternions">Examples using quaternions</a><a id="Examples-using-quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-using-quaternions" title="Permalink"></a></h3><ul><li><a href="../examples/free_motion/#Free-motions">Free motions</a> (second example on the page)</li><li><a href="../examples/three_springs/#Three-springs">Three springs</a></li><li><a href="../examples/space/#Bodies-in-space">Bodies in space</a> (may use, see comment)</li></ul><h2 id="Rotation-matrices"><a class="docs-heading-anchor" href="#Rotation-matrices">Rotation matrices</a><a id="Rotation-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-matrices" title="Permalink"></a></h2><p>Rotation matrices represent orientation using a <span>$3\times 3$</span> matrix <span>$\in SO(3)$</span>. These are used in the equations of multibody components and connectors, but should for the most part be invisible to the user. In particular, they should never appear as state variables after simplification. </p><h2 id="Conversion-between-orientation-formats"><a class="docs-heading-anchor" href="#Conversion-between-orientation-formats">Conversion between orientation formats</a><a id="Conversion-between-orientation-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-orientation-formats" title="Permalink"></a></h2><p>You may convert between different representations of orientation using the appropriate constructors from Rotations.jl, for example:</p><pre><code class="language-julia hljs">using Multibody.Rotations
using Multibody.Rotations: params
using Multibody.Rotations.Quaternions
using LinearAlgebra

R = RotMatrix{3}(I(3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 RotMatrix3{Bool} with indices SOneTo(3)×SOneTo(3):
 1  0  0
 0  1  0
 0  0  1</code></pre><pre><code class="language-julia hljs"># Convert R to a quaternion
Q = QuatRotation(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 QuatRotation{Float64} with indices SOneTo(3)×SOneTo(3)(QuaternionF64(1.0, 0.0, 0.0, 0.0)):
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre><pre><code class="language-julia hljs"># Convert Q to a 4-vector
Qvec = params(Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element StaticArraysCore.SVector{4, Float64} with indices SOneTo(4):
 1.0
 0.0
 0.0
 0.0</code></pre><pre><code class="language-julia hljs"># Convert R to Euler angles in the sequence XYZ
E = RotXYZ(R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 RotXYZ{Float64} with indices SOneTo(3)×SOneTo(3)(0.0, 0.0, 0.0):
 1.0  -0.0   0.0
 0.0   1.0  -0.0
 0.0   0.0   1.0</code></pre><pre><code class="language-julia hljs"># Convert E to a 3-vector
Evec = params(E)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.0
 0.0</code></pre><pre><code class="language-julia hljs">rotation_axis(R), rotation_angle(R) # Get an axis-angle representation</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1.0, 0.0, 0.0], 0.0)</code></pre><h2 id="Conventions-for-modeling"><a class="docs-heading-anchor" href="#Conventions-for-modeling">Conventions for modeling</a><a id="Conventions-for-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Conventions-for-modeling" title="Permalink"></a></h2><p>See <a href="../examples/pendulum/#Orientations-and-directions">Orientations and directions</a></p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.RotationMatrix" href="#Multibody.RotationMatrix"><code>Multibody.RotationMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RotationMatrix</code></pre><p>A struct representing a 3D orientation as a rotation matrix.</p><p>If <code>ODESystem</code> is called on a <code>RotationMatrix</code> object <code>o</code>, symbolic variables for <code>o.R</code> and <code>o.w</code> are created and the value of <code>o.R</code> is used as the default value for the symbolic <code>R</code>.</p><p><strong>Fields:</strong></p><ul><li><code>R::R3</code>: The rotation 3×3 matrix ∈ SO(3)</li><li><code>w</code>: The angular velocity vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.NumRotationMatrix-Tuple{}" href="#Multibody.NumRotationMatrix-Tuple{}"><code>Multibody.NumRotationMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NumRotationMatrix(; R = collect(1.0 * I(3)), w = zeros(3), name, varw = false)</code></pre><p>Create a new <a href="#Multibody.RotationMatrix"><code>RotationMatrix</code></a> struct with symbolic elements. <code>R,w</code> determine default values.</p><p>The primary difference between <code>NumRotationMatrix</code> and <code>RotationMatrix</code> is that the <code>NumRotationMatrix</code> constructor is used in the constructor of a <a href="../frames/#Multibody.Frame"><code>Frame</code></a> in order to introduce the frame variables, whereas <code>RorationMatrix</code> (the struct) only wraps existing variables.</p><ul><li><code>varw</code>: If true, <code>w</code> is a variable, otherwise it is derived from the derivative of <code>R</code> as <code>w = get_w(R)</code>.</li></ul><p>Never call this function directly from a component constructor, instead call <code>f = Frame(); R = ori(f)</code> and add <code>f</code> to the subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.absolute_rotation-Tuple{Any, Any}" href="#Multibody.absolute_rotation-Tuple{Any, Any}"><code>Multibody.absolute_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R2 = absolute_rotation(R1, Rrel)</code></pre><ul><li><code>R1</code>: <code>Orientation</code> object to rotate frame 0 into frame 1</li><li><code>Rrel</code>: <code>Orientation</code> object to rotate frame 1 into frame 2</li><li><code>R2</code>: <code>Orientation</code> object to rotate frame 0 into frame 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L163-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.axes_rotations" href="#Multibody.axes_rotations"><code>Multibody.axes_rotations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axes_rotations(sequence, angles, der_angles; name = :R_ar)</code></pre><p>Generate a rotation matrix for a rotation around the specified axes (Euler/Cardan angles).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.axis_rotation-Tuple{Any, Any}" href="#Multibody.axis_rotation-Tuple{Any, Any}"><code>Multibody.axis_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axis_rotation(sequence, angle; name = :R)</code></pre><p>Generate a rotation matrix for a rotation around the specified axis.</p><ul><li><code>sequence</code>: The axis to rotate around (1: x-axis, 2: y-axis, 3: z-axis)</li><li><code>angle</code>: The angle of rotation (in radians)</li></ul><p>Returns a <code>RotationMatrix</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L304-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.connect_orientation-Tuple{Any, Any}" href="#Multibody.connect_orientation-Tuple{Any, Any}"><code>Multibody.connect_orientation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect_orientation(R1,R2; iscut=false)</code></pre><p>Connect two rotation matrices together, optionally introducing a cut joint. A normal connection of two rotation matrices introduces 9 constraints, while a cut connection introduces 3 constraints only. This is useful to open kinematic loops, see <a href="../examples/kinematic_loops/#Using-cut-joints">Using cut joints</a> (docs page) for an example where this is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_frame-Tuple{Any, Any, Any}" href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>Multibody.get_frame</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T_W_F = get_frame(sol, frame, t)</code></pre><p>Extract a 4×4 transformation matrix ∈ SE(3) from a solution at time <code>t</code>.</p><p>The transformation matrix returned, <span>$T_W^F$</span>, is such that when a homogenous-coordinate vector <span>$p_F$</span>, expressed in the local <code>frame</code> of reference <span>$F$</span> is multiplied by <span>$T_W^F$</span> as <span>$Tp$</span>, the resulting vector is <span>$p_W$</span> expressed in the world frame:</p><p class="math-container">\[p_W = T_W^F  p_F\]</p><p>See also <a href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>get_trans</code></a> and <a href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>, <a href="../examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L404-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_rot-Tuple{Any, Any, Any}" href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>Multibody.get_rot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R_W_F = get_rot(sol, frame, t)</code></pre><p>Extract a 3×3 rotation matrix ∈ SO(3) from a solution at time <code>t</code>.</p><p>The rotation matrix returned, <span>$R_W^F$</span>, is such that when a vector <span>$p_F$</span> expressed in the local <code>frame</code> of reference <span>$F$</span> is multiplied by <span>$R_W^F$</span> as <span>$Rp$</span>, the resulting vector is <span>$p_W$</span> expressed in the world frame:</p><p class="math-container">\[p_W = R_W^F  p_F\]</p><p>This is the inverse (transpose) of the rotation matrix stored in frame connectors (e.g. <code>ori(frame).R = get_rot(sol, frame, t)&#39;</code>).</p><p>The columns of <span>$R_W_F$</span> indicate are the basis vectors of the frame <span>$F$</span> expressed in the world coordinate frame.</p><p>See also <a href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>get_trans</code></a>, <a href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>get_frame</code></a>, <a href="../examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L376-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_trans-Tuple{Any, Any, Number}" href="#Multibody.get_trans-Tuple{Any, Any, Number}"><code>Multibody.get_trans</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_trans(sol, frame, t)</code></pre><p>Extract the translational part of a frame from a solution at time <code>t</code>. See also <a href="#Multibody.get_rot-Tuple{Any, Any, Any}"><code>get_rot</code></a>, <a href="#Multibody.get_frame-Tuple{Any, Any, Any}"><code>get_frame</code></a>, <a href="../examples/pendulum/#Orientations-and-directions">Orientations and directions</a> (docs section).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L395-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.get_w-Tuple{AbstractMatrix}" href="#Multibody.get_w-Tuple{AbstractMatrix}"><code>Multibody.get_w</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_w(R)</code></pre><p>Compute the angular velocity <code>w</code> from the rotation matrix <code>R</code> and its derivative <code>DR = D.(R)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.planar_rotation-Tuple{Any, Any, Any}" href="#Multibody.planar_rotation-Tuple{Any, Any, Any}"><code>Multibody.planar_rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">planar_rotation(axis, phi, phid)</code></pre><p>Generate a rotation matrix for a rotation around the specified axis (axis-angle representation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve1-Tuple{RotationMatrix, Any}" href="#Multibody.resolve1-Tuple{RotationMatrix, Any}"><code>Multibody.resolve1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">h1 = resolve1(R21, h2)</code></pre><p><code>R12</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h2</code> is a vector resolved in frame 2. <code>h1</code> is the same vector in frame 1.</p><p>Typical usage (local to world):</p><pre><code class="language-julia hljs">r_wb = resolve1(ori(frame_a), r_ab)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Multibody.resolve2-Tuple{RotationMatrix, Any}" href="#Multibody.resolve2-Tuple{RotationMatrix, Any}"><code>Multibody.resolve2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">h2 = resolve2(R21, h1)</code></pre><p><code>R21</code> is a 3x3 matrix that transforms a vector from frame 1 to frame 2. <code>h1</code> is a vector resolved in frame 1. <code>h2</code> is the same vector in frame 2.</p><p>Typical usage (world to local):</p><pre><code class="language-julia hljs">g_a = resolve2(ori(frame_a), a_0 - g_0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaComputing/Multibody.jl/blob/f40ea06ca97c1f4369968c7fbfce052afb014ffc/src/orientation.jl#L110-L120">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-quat"><a class="tag is-link" href="#citeref-quat">quat</a>&quot;Integrating Rotations using Non-Unit Quaternions&quot;, Caleb Rucker, https://par.nsf.gov/servlets/purl/10097724</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">« Interfaces</a><a class="docs-footer-nextpage" href="../rendering/">3D rendering »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 7 October 2024 11:47">Monday 7 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
